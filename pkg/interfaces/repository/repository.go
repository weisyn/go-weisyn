package repository

// WES区块链统一数据存储层公共接口
//
// 🎯 **设计原则**
// ✅ 单一职责：专注于数据存储和查询，不处理业务逻辑
// ✅ 高性能：提供高效的区块链数据访问服务
// ✅ 架构清晰：严格遵循单一数据源原则，区块是唯一数据写入点
// ✅ 接口精简：聚焦核心区块操作，避免接口膨胀
//
// 🏗️ **架构定位**
// 作为WES区块链系统的核心数据访问层，提供区块的完整生命周期管理。
// 严格遵循"单一数据源"原则：区块是唯一数据写入点，其他数据都从区块实时计算。

import (
	"context"

	core "github.com/weisyn/v1/pb/blockchain/block"
	transaction "github.com/weisyn/v1/pb/blockchain/block/transaction"
	resource "github.com/weisyn/v1/pb/blockchain/block/transaction/resource"
)

// RepositoryManager WES区块链统一数据仓储接口
//
// 🎯 **职责定位**
// 作为WES区块链系统的统一数据访问层，提供区块数据的核心管理功能。
// 专注于区块的存储、查询和索引服务，为上层业务模块提供可靠的数据基础。
//
// 🏗️ **架构特征**
// - 单一数据源：Block作为唯一写入点，确保数据一致性
// - 高效查询：提供基于哈希和高度的快速区块访问
// - 索引优化：通过多种索引方式提升查询性能
// - 接口精简：聚焦核心功能，避免不必要的复杂性
//
// 📋 **核心功能**
// 本接口提供8个核心方法，确保区块链数据管理的完整业务闭环：
//
// 🏗️ **区块数据操作（4方法）**：
// 1. 区块存储：StoreBlock - 区块数据的持久化存储
// 2. 哈希查询：GetBlock - 基于哈希的精确区块获取
// 3. 高度查询：GetBlockByHeight - 基于高度的区块获取
// 4. 链状态查询：GetHighestBlock - 获取最高区块信息
//
// 💰 **交易权利管理（3方法）**：
// 5. 交易查询：GetTransaction - 获取交易及其位置信息
// 6. 账户状态：GetAccountNonce - 获取账户nonce防重放
// 7. 区块交易：GetTransactionsByBlock - 获取区块内所有交易
//
// ⚙️ **资源能力管理（1方法）**：
// 8. 资源查询：GetResourceByContentHash - 通过内容哈希查询资源
type RepositoryManager interface {

	// ==================== 🏗️ 区块数据操作 ====================
	//
	// 🎯 业务域定位：单一数据源的区块存储和查询服务
	// 📊 系统价值：作为WES区块链的时间线容器，是整个系统的数据基础
	// 🔄 架构原则：严格遵循"单一数据源"原则，区块是唯一的数据写入点

	// StoreBlock 存储区块
	//
	// 🎯 **系统定位**：单一数据源写入点
	// 作为WES区块链系统的唯一数据写入接口，负责将验证通过的区块持久化存储。
	// 这是整个系统数据流的源头，确保数据的单一来源和一致性。
	//
	// 🏗️ **架构价值**：
	// - 数据一致性：确保区块数据的原子性写入
	// - 单一数据源：杜绝数据重复存储的架构风险
	// - 时间线完整性：维护区块链时间序列的连续性
	// - 索引维护：存储时自动更新相关索引（高度索引、哈希索引）
	//
	// 📞 **主要调用者**：
	// - domains/block/processor.go 的 processBlock() 方法
	//   业务逻辑：区块处理完成后进行持久化存储
	//
	// 📊 **实现要求**：
	// - 原子性：确保区块数据和索引的同步更新
	// - 幂等性：重复存储相同区块应当安全处理
	// - 性能优化：批量更新索引，减少存储开销
	//
	// 📊 **参数说明**：
	// - ctx：上下文对象，用于超时控制和取消操作
	// - block：待存储的完整区块数据结构
	// 📊 **返回值说明**：
	// - error：存储操作错误信息（如数据库写入失败、区块验证失败等）
	StoreBlock(ctx context.Context, block *core.Block) error

	// GetBlock 获取指定哈希的区块
	//
	// 🎯 **系统定位**：哈希精确查询核心
	// 通过区块哈希获取完整区块数据，这是访问区块链历史数据的基础方法。
	// 所有基于区块的数据计算（交易提取、UTXO计算）都依赖此方法。
	//
	// 🏗️ **架构价值**：
	// - 数据访问基础：为交易提取和UTXO计算提供数据源
	// - 查询高效性：直接哈希查询，最高效的区块访问方式
	// - 历史追溯：支持区块链历史数据的完整追溯
	// - 数据完整性：返回完整的区块数据结构
	//
	// 📞 **主要调用者**：
	// - domains/block/query.go 的 getBlockByHash() 方法
	//   业务逻辑：获取区块数据进行查询处理
	// - domains/block/processor.go 的 processBlock() 方法
	//   业务逻辑：获取父区块进行验证处理
	//
	// 📊 **查询特征**：
	// - 精确匹配：基于SHA256哈希的精确查询
	// - 高性能：直接键值查询，O(1)时间复杂度
	// - 完整数据：返回包含所有交易的完整区块
	//
	// 📊 **参数说明**：
	// - ctx：上下文对象，用于超时控制和取消操作
	// - blockHash：目标区块的哈希值（32字节SHA256）
	// 📊 **返回值说明**：
	// - *core.Block：完整的区块数据结构，包含区块头和所有交易
	// - error：查询错误信息（如区块不存在、哈希格式错误、数据库连接失败等）
	GetBlock(ctx context.Context, blockHash []byte) (*core.Block, error)

	// GetBlockByHeight 按高度获取区块
	//
	// 🎯 **系统定位**：高度索引查询核心
	// 通过区块高度获取区块数据，支持基于区块高度的链式验证和历史查询。
	// 内部通过高度索引快速定位，然后调用底层存储获取完整数据。
	//
	// 🏗️ **架构价值**：
	// - 链式验证：支持基于高度的区块链完整性验证
	// - 历史查询：为时点查询提供精确的高度定位
	// - 索引优化：通过高度索引提升查询性能
	// - 序列访问：支持按时间顺序的区块遍历
	//
	// 📞 **主要调用者**：
	// - domains/block/validator.go 的 validateBlockChain() 等方法
	//   业务逻辑：获取前一个区块进行链式验证
	// - domains/block/query.go 的 getBlockByHeight() 方法
	//   业务逻辑：按高度查询区块数据
	// - services/system/startup/coordinator.go 的多个初始化方法
	//   业务逻辑：系统启动时获取创世区块和最新区块
	//
	// 📊 **查询特征**：
	// - 高度映射：通过 HeightIndex 进行高效查询
	// - 唯一性：每个高度对应唯一区块
	// - 完整数据：返回包含所有交易的完整区块
	//
	// 📊 **参数说明**：
	// - ctx：上下文对象，用于超时控制和取消操作
	// - height：目标区块高度（从0开始的递增整数）
	// 📊 **返回值说明**：
	// - *core.Block：指定高度的完整区块数据结构
	// - error：查询错误信息（如区块高度不存在、索引查询失败等）
	GetBlockByHeight(ctx context.Context, height uint64) (*core.Block, error)

	// GetBlockRange 获取区块高度范围
	//
	// 🎯 **系统定位**：批量区块查询核心
	// 获取指定高度范围内的所有区块，支持区块同步、数据分析等批量处理场景。
	// 内部通过高度索引批量查询，优化大量区块获取的性能。
	//
	// 🏗️ **架构价值**：
	// - 批量处理：一次性获取连续区块范围，提升同步效率
	// - 高效查询：通过批量索引查询减少数据库交互次数
	// - 顺序保证：返回的区块按高度升序排列，确保数据一致性
	// - 同步支持：为节点同步提供高效的批量区块获取能力
	//
	// 📞 **主要调用者**：
	// - domains/sync/block_syncer.go 的批量同步方法
	//   业务逻辑：批量获取历史区块进行节点同步
	// - domains/block/analyzer.go 的数据分析方法
	//   业务逻辑：获取区块范围进行链数据分析和统计
	// - api层的区块查询接口
	//   业务逻辑：为区块浏览器提供批量区块查询服务
	//
	// 📊 **查询特征**：
	// - 范围查询：支持指定起始和结束高度的连续查询
	// - 批量优化：一次性获取多个区块，减少查询开销
	// - 顺序返回：严格按照高度升序返回区块列表
	// - 边界处理：自动处理不存在的高度，只返回有效区块
	//
	// 📊 **参数说明**：
	// - ctx：上下文对象，用于超时控制和取消操作
	// - startHeight：起始区块高度（包含）
	// - endHeight：结束区块高度（包含）
	// 📊 **返回值说明**：
	// - []*core.Block：指定范围内的区块列表，按高度升序排列
	// - error：查询错误信息（如高度范围无效、数据库连接失败等）
	GetBlockRange(ctx context.Context, startHeight, endHeight uint64) ([]*core.Block, error)

	// GetHighestBlock 获取最高区块信息
	//
	// 🎯 **系统定位**：链状态查询核心
	// 返回当前区块链的最高区块信息（高度和哈希），为系统管理和状态检查提供关键信息。
	// 这是系统启动、同步状态检查、链状态监控的基础方法。
	//
	// 🏗️ **架构价值**：
	// - 系统状态：提供链的最新状态信息
	// - 启动检查：系统启动时的状态验证基础
	// - 同步支持：为区块同步提供目标状态
	// - 监控基础：为系统监控提供当前链高信息
	//
	// 📞 **主要调用者**：
	// - services/system/startup/coordinator.go 的系统初始化方法
	//   业务逻辑：获取链的最高区块信息进行系统状态检查
	// - domains/utxo/balance_calculator.go 的 calculateBalanceFromChainData() 方法
	//   业务逻辑：获取链高度，用于余额计算和状态分析
	// - domains/sync/block_syncer.go 等同步相关模块
	//   业务逻辑：同步时获取当前链高度
	// - domains/recovery/diagnostor.go 故障诊断模块
	//   业务逻辑：诊断时获取链状态信息
	//
	// 📊 **查询特征**：
	// - 链状态获取：返回当前链的最新状态信息
	// - 轻量级查询：只返回高度和哈希，不返回完整区块数据
	// - 实时状态：反映当前链的最新状态
	//
	// 📊 **参数说明**：
	// - ctx：上下文对象，用于超时控制和取消操作
	// 📊 **返回值说明**：
	// - height：当前链的最高区块高度
	// - blockHash：最高区块的哈希值（32字节SHA256）
	// - error：查询错误信息（如数据库连接失败、链状态异常等）
	GetHighestBlock(ctx context.Context) (height uint64, blockHash []byte, err error)

	// ==================== 💰 交易权利管理 ====================
	//
	// 🎯 业务域定位：交易状态跟踪和权利验证查询服务
	// 📊 系统价值：支持EUTXO权利转换的交易管理和状态跟踪
	// 🔄 架构原则：交易从区块实时提取，不重复存储，支持权利分析

	// GetTransaction 根据交易哈希获取完整交易及其位置信息
	//
	// 🎯 **系统定位**：交易精确查询与定位核心
	// 通过交易哈希获取完整的交易数据及其在区块链中的精确位置信息。
	// 同时提供交易内容和位置定位，支持权利分析、状态跟踪等复杂业务逻辑。
	//
	// 🏗️ **架构价值**：
	// - 权利分析：为UTXO锁定条件分析提供完整交易上下文
	// - 状态跟踪：提供交易在区块链中的精确位置用于状态追踪
	// - 单一数据源：从区块实时提取，不重复存储交易
	// - 业务完整性：提供交易的完整信息用于复杂业务逻辑
	//
	// 📞 **主要调用者**：
	// - domains/utxo/lock_analyzer.go 的 AnalyzeLockedBalances() 方法
	//   业务逻辑：获取交易详情分析锁定条件
	// - domains/transaction/status_tracker.go
	//   业务逻辑：交易状态跟踪和位置查询
	//
	// 📊 **查询特征**：
	// - 精确定位：基于交易哈希的精确查询和位置返回
	// - 复合信息：同时返回交易数据和位置信息
	// - 单一数据源：从区块实时提取，确保数据一致性
	//
	// 📊 **参数说明**：
	// - ctx：上下文对象，用于超时控制和取消操作
	// - txHash：目标交易的哈希值（32字节SHA256）
	// 📊 **返回值说明**：
	// - blockHash：交易所在区块的哈希值（32字节SHA256）
	// - txIndex：交易在区块中的索引位置（从0开始）
	// - transaction：完整的交易数据结构，包含所有输入输出
	// - err：查询错误信息（如交易不存在、哈希格式错误等）
	GetTransaction(ctx context.Context, txHash []byte) (blockHash []byte, txIndex uint32, transaction *transaction.Transaction, err error)

	// GetAccountNonce 获取账户当前nonce
	//
	// 🎯 **系统定位**：防重放攻击核心
	// 获取指定账户地址的当前nonce值（下一个可用的交易序号），
	// 为交易创建、重放攻击防护、账户状态管理提供关键信息。
	//
	// 🏗️ **架构价值**：
	// - 交易安全：防止交易重放攻击的核心机制
	// - 状态管理：账户级别的状态跟踪
	// - 并发支持：为并发交易创建提供序号管理
	// - 一致性保证：确保交易序号的全局一致性
	//
	// 📞 **主要调用者**：
	// - domains/transaction/manager.go
	//   业务逻辑：交易创建时获取nonce进行重放攻击防护
	// - domains/transaction/validator.go
	//   业务逻辑：验证交易nonce的正确性
	//
	// 📊 **查询特征**：
	// - 账户状态：返回账户的当前交易序号状态
	// - 实时维护：随区块添加自动更新，确保数据最新性
	// - 防重放核心：为交易创建提供序号基础
	//
	// 🔄 **维护机制**：区块添加时自动更新
	// 📊 **数据源**：AccountNonceIndex索引系统
	//
	// 📊 **参数说明**：
	// - ctx：上下文对象，用于超时控制和取消操作
	// - address：账户地址（通常为20字节的地址哈希）
	// 📊 **返回值说明**：
	// - uint64：当前账户的nonce值（下一个可用的交易序号）
	// - error：查询错误信息（如地址无效、数据库连接失败等）
	GetAccountNonce(ctx context.Context, address []byte) (uint64, error)

	// GetTransactionsByBlock 获取区块中的所有交易
	//
	// 🎯 **系统定位**：区块内容展示服务
	// 获取指定区块中的所有交易列表，主要服务于外部API和区块内容展示。
	// 通过获取区块然后实时提取所有交易，遵循单一数据源原则。
	//
	// 🏗️ **架构价值**：
	// - 外部API支持：为区块浏览器等外部服务提供便利
	// - 内容展示：完整展示区块的交易内容
	// - 单一数据源：从区块实时提取，不重复存储
	// - 批量处理：一次性获取区块内所有交易，提升效率
	//
	// 📞 **主要调用者**：
	// - services/adapters/block.go 的 GetTransactionsByBlock() 方法
	//   业务逻辑：适配器层委托给内部接口获取区块内交易
	// - api/graphql/resolvers 的区块查询解析器
	//   业务逻辑：GraphQL API获取区块的完整交易列表
	// - api/http/handlers 的区块详情处理器
	//   业务逻辑：HTTP API返回区块的交易详情
	//
	// 📊 **查询特征**：
	// - 完整提取：返回区块内的所有交易，按区块内顺序排列
	// - 有序返回：交易顺序与区块内存储顺序完全一致
	// - 实时计算：从区块数据实时提取，确保数据一致性
	//
	// 📊 **参数说明**：
	// - ctx：上下文对象，用于超时控制和取消操作
	// - blockHash：目标区块的哈希值（32字节SHA256）
	// 📊 **返回值说明**：
	// - []*transaction.Transaction：区块内所有交易的有序列表
	// - error：查询错误信息（如区块不存在、数据解析失败等）
	GetTransactionsByBlock(ctx context.Context, blockHash []byte) ([]*transaction.Transaction, error)

	// ==================== ⚙️ 资源能力管理 ====================
	//
	// 🎯 业务域定位：基于内容哈希的资源查询服务
	// 📊 系统价值：支持内容寻址的完整资源获取能力
	// 🔄 架构原则：资源从区块实时提取，不重复存储，遵循单一数据源原则

	// GetResourceByContentHash 根据内容哈希查询完整资源
	//
	// 🎯 **系统定位**：内容寻址查询核心
	// 通过指定的content_hash查询并获取完整的资源定义，
	// 支持基于内容哈希的精确资源定位和数据获取。
	//
	// 🏗️ **架构价值**：
	// - 内容寻址：完美体现基于content_hash的内容寻址架构
	// - 精确查询：32字节SHA256哈希确保全局唯一性和查询准确性
	// - 完整数据：返回包含执行配置的完整Resource结构
	// - 全局唯一：content_hash确保资源的全局唯一性标识
	//
	// 📞 **主要调用者**：
	// - internal/core/engines/contract 的智能合约执行引擎
	//   业务逻辑：通过content_hash获取合约的完整定义和ABI配置
	// - internal/core/engines/aimodel 的AI模型执行引擎
	//   业务逻辑：通过content_hash获取模型的格式和执行参数
	// - domains/resource/manager.go 的资源管理器
	//   业务逻辑：基于内容哈希进行资源查询和管理
	// - api层的资源查询接口
	//   业务逻辑：为外部API提供基于哈希的资源查询服务
	//
	// 📊 **查询特征**：
	// - 高速查询：基于ResourceIndex的O(1)查询性能
	// - 精确匹配：基于content_hash的全局唯一定位
	// - 完整返回：返回包含所有字段的完整Resource定义
	// - 内容寻址：真正的"内容哈希即身份"实现
	//
	// 📊 **参数说明**：
	// - ctx：上下文对象，用于超时控制和取消操作
	// - contentHash：资源内容的SHA256哈希（32字节），作为唯一身份标识
	// 📊 **返回值说明**：
	// - *resource.Resource：完整的资源定义结构，包含所有元信息和执行配置
	// - error：查询错误信息（如资源不存在、哈希格式错误、数据库连接失败等）
	GetResourceByContentHash(ctx context.Context, contentHash []byte) (*resource.Resource, error)
}
