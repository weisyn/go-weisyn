// ================================================================================================
// æ ¸å¿ƒäº¤æ˜“åè®®å®šä¹‰ï¼ˆEUTXO æ¨¡å‹ï¼‰
// ================================================================================================
// é‡è¦è¯´æ˜ï¼ˆå…±è¯†åè®®çº¯å‡€æ€§çº¦æŸï¼‰ï¼š
// - æœ¬æ–‡ä»¶ä»…å®šä¹‰â€œä¸Šé“¾çš„å…±è¯†æ•°æ®ç»“æ„â€ï¼ˆäº¤æ˜“ã€è¾“å…¥/è¾“å‡ºã€é”å®šæ¡ä»¶ã€è¯æ˜ç­‰ï¼‰ã€‚
// - Host ABI / SDK ä¾§ç”¨äºè·¨è¾¹ç•Œä¼ è¾“çš„ DTOï¼ˆå¦‚æ‰¹é‡è¾“å‡ºæè¿°ã€æ‰©å±•è½¬è´¦æ„å›¾ç­‰ï¼‰ï¼Œä¸å¾—æ·»åŠ åˆ°æœ¬ proto ä¸­ï¼Œ
//   åº”æ”¾ç½®äºåº”ç”¨å±‚ï¼ˆå¦‚ pkg/types æˆ–ç‹¬ç«‹ hostabi proto åŒ…ï¼‰ä»¥é¿å…æ±¡æŸ“å…±è¯†å±‚åè®®ã€‚
// - LockingConditionList ç›¸å…³ç¼–è§£ç å·²è¿å‡ºè‡³ Host ABI å±‚å®ç°ï¼ˆpkg/types + pkg/utilsï¼‰ï¼Œåç»­å¦‚éœ€ Protobuf ç‰ˆæœ¬ï¼Œ
//   ä¹Ÿåº”æ”¾åˆ°éå…±è¯†å‘½åç©ºé—´ï¼ˆå¦‚ pb/hostabi/â€¦ï¼‰ã€‚

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.32.1
// source: pb/blockchain/block/transaction/transaction.proto

package transaction

import (
	resource "github.com/weisyn/v1/pb/blockchain/block/transaction/resource"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// ExecutionType - æ‰§è¡Œç±»å‹æšä¸¾
//
// ğŸ¯ ç”¨é€”ï¼šæ ‡è¯†æ‰§è¡Œå¼•æ“ç±»å‹ï¼Œç”¨äºè·¯ç”±åˆ°æ­£ç¡®çš„éªŒè¯é€»è¾‘
type ExecutionType int32

const (
	ExecutionType_EXECUTION_TYPE_UNKNOWN  ExecutionType = 0
	ExecutionType_EXECUTION_TYPE_CONTRACT ExecutionType = 1 // æ™ºèƒ½åˆçº¦ï¼ˆWASMï¼‰
	ExecutionType_EXECUTION_TYPE_AI_MODEL ExecutionType = 2 // AIæ¨¡å‹ï¼ˆONNXï¼‰
)

// Enum value maps for ExecutionType.
var (
	ExecutionType_name = map[int32]string{
		0: "EXECUTION_TYPE_UNKNOWN",
		1: "EXECUTION_TYPE_CONTRACT",
		2: "EXECUTION_TYPE_AI_MODEL",
	}
	ExecutionType_value = map[string]int32{
		"EXECUTION_TYPE_UNKNOWN":  0,
		"EXECUTION_TYPE_CONTRACT": 1,
		"EXECUTION_TYPE_AI_MODEL": 2,
	}
)

func (x ExecutionType) Enum() *ExecutionType {
	p := new(ExecutionType)
	*p = x
	return p
}

func (x ExecutionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ExecutionType) Descriptor() protoreflect.EnumDescriptor {
	return file_pb_blockchain_block_transaction_transaction_proto_enumTypes[0].Descriptor()
}

func (ExecutionType) Type() protoreflect.EnumType {
	return &file_pb_blockchain_block_transaction_transaction_proto_enumTypes[0]
}

func (x ExecutionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ExecutionType.Descriptor instead.
func (ExecutionType) EnumDescriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{0}
}

type SignatureHashType int32

const (
	SignatureHashType_SIGHASH_UNKNOWN             SignatureHashType = 0
	SignatureHashType_SIGHASH_ALL                 SignatureHashType = 1   // 0x01
	SignatureHashType_SIGHASH_NONE                SignatureHashType = 2   // 0x02
	SignatureHashType_SIGHASH_SINGLE              SignatureHashType = 3   // 0x03
	SignatureHashType_SIGHASH_ANYONECANPAY        SignatureHashType = 128 // 0x80
	SignatureHashType_SIGHASH_ALL_ANYONECANPAY    SignatureHashType = 129 // 0x81
	SignatureHashType_SIGHASH_NONE_ANYONECANPAY   SignatureHashType = 130 // 0x82
	SignatureHashType_SIGHASH_SINGLE_ANYONECANPAY SignatureHashType = 131 // 0x83
)

// Enum value maps for SignatureHashType.
var (
	SignatureHashType_name = map[int32]string{
		0:   "SIGHASH_UNKNOWN",
		1:   "SIGHASH_ALL",
		2:   "SIGHASH_NONE",
		3:   "SIGHASH_SINGLE",
		128: "SIGHASH_ANYONECANPAY",
		129: "SIGHASH_ALL_ANYONECANPAY",
		130: "SIGHASH_NONE_ANYONECANPAY",
		131: "SIGHASH_SINGLE_ANYONECANPAY",
	}
	SignatureHashType_value = map[string]int32{
		"SIGHASH_UNKNOWN":             0,
		"SIGHASH_ALL":                 1,
		"SIGHASH_NONE":                2,
		"SIGHASH_SINGLE":              3,
		"SIGHASH_ANYONECANPAY":        128,
		"SIGHASH_ALL_ANYONECANPAY":    129,
		"SIGHASH_NONE_ANYONECANPAY":   130,
		"SIGHASH_SINGLE_ANYONECANPAY": 131,
	}
)

func (x SignatureHashType) Enum() *SignatureHashType {
	p := new(SignatureHashType)
	*p = x
	return p
}

func (x SignatureHashType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SignatureHashType) Descriptor() protoreflect.EnumDescriptor {
	return file_pb_blockchain_block_transaction_transaction_proto_enumTypes[1].Descriptor()
}

func (SignatureHashType) Type() protoreflect.EnumType {
	return &file_pb_blockchain_block_transaction_transaction_proto_enumTypes[1]
}

func (x SignatureHashType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SignatureHashType.Descriptor instead.
func (SignatureHashType) EnumDescriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{1}
}

type SignatureAlgorithm int32

const (
	SignatureAlgorithm_SIGNATURE_ALGORITHM_UNKNOWN         SignatureAlgorithm = 0
	SignatureAlgorithm_SIGNATURE_ALGORITHM_ECDSA_SECP256K1 SignatureAlgorithm = 1
	SignatureAlgorithm_SIGNATURE_ALGORITHM_ECDSA_SECP256R1 SignatureAlgorithm = 2
	SignatureAlgorithm_SIGNATURE_ALGORITHM_ED25519         SignatureAlgorithm = 3
	SignatureAlgorithm_SIGNATURE_ALGORITHM_SCHNORR         SignatureAlgorithm = 4
	SignatureAlgorithm_SIGNATURE_ALGORITHM_RSA_PSS         SignatureAlgorithm = 5
)

// Enum value maps for SignatureAlgorithm.
var (
	SignatureAlgorithm_name = map[int32]string{
		0: "SIGNATURE_ALGORITHM_UNKNOWN",
		1: "SIGNATURE_ALGORITHM_ECDSA_SECP256K1",
		2: "SIGNATURE_ALGORITHM_ECDSA_SECP256R1",
		3: "SIGNATURE_ALGORITHM_ED25519",
		4: "SIGNATURE_ALGORITHM_SCHNORR",
		5: "SIGNATURE_ALGORITHM_RSA_PSS",
	}
	SignatureAlgorithm_value = map[string]int32{
		"SIGNATURE_ALGORITHM_UNKNOWN":         0,
		"SIGNATURE_ALGORITHM_ECDSA_SECP256K1": 1,
		"SIGNATURE_ALGORITHM_ECDSA_SECP256R1": 2,
		"SIGNATURE_ALGORITHM_ED25519":         3,
		"SIGNATURE_ALGORITHM_SCHNORR":         4,
		"SIGNATURE_ALGORITHM_RSA_PSS":         5,
	}
)

func (x SignatureAlgorithm) Enum() *SignatureAlgorithm {
	p := new(SignatureAlgorithm)
	*p = x
	return p
}

func (x SignatureAlgorithm) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SignatureAlgorithm) Descriptor() protoreflect.EnumDescriptor {
	return file_pb_blockchain_block_transaction_transaction_proto_enumTypes[2].Descriptor()
}

func (SignatureAlgorithm) Type() protoreflect.EnumType {
	return &file_pb_blockchain_block_transaction_transaction_proto_enumTypes[2]
}

func (x SignatureAlgorithm) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SignatureAlgorithm.Descriptor instead.
func (SignatureAlgorithm) EnumDescriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{2}
}

type Address_AddressType int32

const (
	Address_P2PKH Address_AddressType = 0 // Pay-to-Public-Key-Hash (æ ‡å‡†åœ°å€)
	Address_P2SH  Address_AddressType = 1 // Pay-to-Script-Hash (å¤šé‡ç­¾ååœ°å€)
)

// Enum value maps for Address_AddressType.
var (
	Address_AddressType_name = map[int32]string{
		0: "P2PKH",
		1: "P2SH",
	}
	Address_AddressType_value = map[string]int32{
		"P2PKH": 0,
		"P2SH":  1,
	}
)

func (x Address_AddressType) Enum() *Address_AddressType {
	p := new(Address_AddressType)
	*p = x
	return p
}

func (x Address_AddressType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Address_AddressType) Descriptor() protoreflect.EnumDescriptor {
	return file_pb_blockchain_block_transaction_transaction_proto_enumTypes[3].Descriptor()
}

func (Address_AddressType) Type() protoreflect.EnumType {
	return &file_pb_blockchain_block_transaction_transaction_proto_enumTypes[3]
}

func (x Address_AddressType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Address_AddressType.Descriptor instead.
func (Address_AddressType) EnumDescriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{1, 0}
}

type TimeLock_TimeSource int32

const (
	TimeLock_TIME_SOURCE_BLOCK_TIMESTAMP TimeLock_TimeSource = 0 // åŒºå—æ—¶é—´æˆ³ï¼ˆé»˜è®¤ï¼Œå»ä¸­å¿ƒåŒ–ï¼‰
	TimeLock_TIME_SOURCE_MEDIAN_TIME     TimeLock_TimeSource = 1 // ä¸­ä½æ•°æ—¶é—´ï¼ˆæ›´ç¨³å®šï¼‰
	TimeLock_TIME_SOURCE_ORACLE          TimeLock_TimeSource = 2 // é¢„è¨€æœºæ—¶é—´ï¼ˆé«˜ç²¾åº¦åœºæ™¯ï¼‰
)

// Enum value maps for TimeLock_TimeSource.
var (
	TimeLock_TimeSource_name = map[int32]string{
		0: "TIME_SOURCE_BLOCK_TIMESTAMP",
		1: "TIME_SOURCE_MEDIAN_TIME",
		2: "TIME_SOURCE_ORACLE",
	}
	TimeLock_TimeSource_value = map[string]int32{
		"TIME_SOURCE_BLOCK_TIMESTAMP": 0,
		"TIME_SOURCE_MEDIAN_TIME":     1,
		"TIME_SOURCE_ORACLE":          2,
	}
)

func (x TimeLock_TimeSource) Enum() *TimeLock_TimeSource {
	p := new(TimeLock_TimeSource)
	*p = x
	return p
}

func (x TimeLock_TimeSource) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TimeLock_TimeSource) Descriptor() protoreflect.EnumDescriptor {
	return file_pb_blockchain_block_transaction_transaction_proto_enumTypes[4].Descriptor()
}

func (TimeLock_TimeSource) Type() protoreflect.EnumType {
	return &file_pb_blockchain_block_transaction_transaction_proto_enumTypes[4]
}

func (x TimeLock_TimeSource) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TimeLock_TimeSource.Descriptor instead.
func (TimeLock_TimeSource) EnumDescriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{15, 0}
}

type ResourceOutput_StorageStrategy int32

const (
	ResourceOutput_STORAGE_STRATEGY_CONTENT_ADDRESSED ResourceOutput_StorageStrategy = 0 // å†…å®¹å¯»å€å­˜å‚¨ï¼ˆé»˜è®¤ï¼‰
	ResourceOutput_STORAGE_STRATEGY_HYBRID            ResourceOutput_StorageStrategy = 1 // æ··åˆå­˜å‚¨ï¼ˆçƒ­æ•°æ®+å†…å®¹å¯»å€ï¼‰
	ResourceOutput_STORAGE_STRATEGY_ON_CHAIN          ResourceOutput_StorageStrategy = 2 // é“¾ä¸Šå­˜å‚¨ï¼ˆå°å‹èµ„æºï¼‰
)

// Enum value maps for ResourceOutput_StorageStrategy.
var (
	ResourceOutput_StorageStrategy_name = map[int32]string{
		0: "STORAGE_STRATEGY_CONTENT_ADDRESSED",
		1: "STORAGE_STRATEGY_HYBRID",
		2: "STORAGE_STRATEGY_ON_CHAIN",
	}
	ResourceOutput_StorageStrategy_value = map[string]int32{
		"STORAGE_STRATEGY_CONTENT_ADDRESSED": 0,
		"STORAGE_STRATEGY_HYBRID":            1,
		"STORAGE_STRATEGY_ON_CHAIN":          2,
	}
)

func (x ResourceOutput_StorageStrategy) Enum() *ResourceOutput_StorageStrategy {
	p := new(ResourceOutput_StorageStrategy)
	*p = x
	return p
}

func (x ResourceOutput_StorageStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ResourceOutput_StorageStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_pb_blockchain_block_transaction_transaction_proto_enumTypes[5].Descriptor()
}

func (ResourceOutput_StorageStrategy) Type() protoreflect.EnumType {
	return &file_pb_blockchain_block_transaction_transaction_proto_enumTypes[5]
}

func (x ResourceOutput_StorageStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ResourceOutput_StorageStrategy.Descriptor instead.
func (ResourceOutput_StorageStrategy) EnumDescriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{31, 0}
}

// *
// Hash - ç»Ÿä¸€çš„å“ˆå¸Œç±»å‹
// å›ºå®š32å­—èŠ‚çš„SHA-256å“ˆå¸Œï¼Œç¡®ä¿ç±»å‹å®‰å…¨å’Œä¸€è‡´æ€§
type Hash struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         []byte                 `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"` // å›ºå®š32å­—èŠ‚SHA-256å“ˆå¸Œ
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Hash) Reset() {
	*x = Hash{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Hash) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Hash) ProtoMessage() {}

func (x *Hash) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Hash.ProtoReflect.Descriptor instead.
func (*Hash) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{0}
}

func (x *Hash) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

// *
// Address - åŒºå—é“¾åœ°å€ç³»ç»Ÿ
//
// Bitcoiné£æ ¼çš„åœ°å€è®¾è®¡ï¼š
// - ä½¿ç”¨Base58Checkç¼–ç 
// - 20å­—èŠ‚åœ°å€å“ˆå¸Œ + ç‰ˆæœ¬å­—èŠ‚ + æ ¡éªŒå’Œ
// - æ”¯æŒè‡ªå®šä¹‰JSONåºåˆ—åŒ–ä¸ºç”¨æˆ·å‹å¥½æ ¼å¼
type Address struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// 20å­—èŠ‚åœ°å€å“ˆå¸Œï¼ˆRIPEMD160(SHA256(å…¬é’¥))ï¼‰
	RawHash []byte `protobuf:"bytes,1,opt,name=raw_hash,json=rawHash,proto3" json:"raw_hash,omitempty"`
	// Base58Checkç¼–ç çš„å®Œæ•´åœ°å€å­—ç¬¦ä¸²
	EncodedAddress string `protobuf:"bytes,2,opt,name=encoded_address,json=encodedAddress,proto3" json:"encoded_address,omitempty"`
	// åœ°å€ç±»å‹
	AddressType Address_AddressType `protobuf:"varint,3,opt,name=address_type,json=addressType,proto3,enum=pb.blockchain.core.Address_AddressType" json:"address_type,omitempty"`
	// ç‰ˆæœ¬å­—èŠ‚
	VersionByte   uint32 `protobuf:"varint,4,opt,name=version_byte,json=versionByte,proto3" json:"version_byte,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Address) Reset() {
	*x = Address{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Address) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Address) ProtoMessage() {}

func (x *Address) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Address.ProtoReflect.Descriptor instead.
func (*Address) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{1}
}

func (x *Address) GetRawHash() []byte {
	if x != nil {
		return x.RawHash
	}
	return nil
}

func (x *Address) GetEncodedAddress() string {
	if x != nil {
		return x.EncodedAddress
	}
	return ""
}

func (x *Address) GetAddressType() Address_AddressType {
	if x != nil {
		return x.AddressType
	}
	return Address_P2PKH
}

func (x *Address) GetVersionByte() uint32 {
	if x != nil {
		return x.VersionByte
	}
	return 0
}

// *
// TokenId - ä»£å¸æ ‡è¯†ç¬¦
// æ”¯æŒåŸç”Ÿä»£å¸ï¼ˆç©ºå€¼ï¼‰å’Œè‡ªå®šä¹‰ä»£å¸çš„ç»Ÿä¸€æ ‡è¯†
type TokenId struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         []byte                 `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"` // ä»£å¸IDï¼Œç©ºå€¼è¡¨ç¤ºåŸç”Ÿä»£å¸
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TokenId) Reset() {
	*x = TokenId{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenId) ProtoMessage() {}

func (x *TokenId) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenId.ProtoReflect.Descriptor instead.
func (*TokenId) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{2}
}

func (x *TokenId) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

// *
// SignatureData - æ•°å­—ç­¾åæ•°æ®
// å…·ä½“çš„ç­¾åæ ¼å¼ï¼Œé¿å…æ¨¡ç³Šçš„bytesï¼Œæ”¯æŒå¤šç§ç­¾åç®—æ³•
type SignatureData struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         []byte                 `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"` // ç­¾åæ•°æ®ï¼ˆ64-256å­—èŠ‚ï¼Œä¾ç®—æ³•è€Œå®šï¼‰
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignatureData) Reset() {
	*x = SignatureData{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignatureData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignatureData) ProtoMessage() {}

func (x *SignatureData) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignatureData.ProtoReflect.Descriptor instead.
func (*SignatureData) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{3}
}

func (x *SignatureData) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

// *
// PublicKey - å…¬é’¥æ•°æ®
// æ ‡å‡†çš„å…¬é’¥æ ¼å¼ï¼Œæ”¯æŒå¤šç§å¯†ç å­¦ç®—æ³•
type PublicKey struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         []byte                 `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"` // å…¬é’¥æ•°æ®ï¼ˆ33-65å­—èŠ‚ï¼Œä¾ç®—æ³•å’Œå‹ç¼©æ ¼å¼è€Œå®šï¼‰
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublicKey) Reset() {
	*x = PublicKey{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublicKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicKey) ProtoMessage() {}

func (x *PublicKey) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicKey.ProtoReflect.Descriptor instead.
func (*PublicKey) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{4}
}

func (x *PublicKey) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

// *
// OutPoint - UTXOä½ç½®å¼•ç”¨
// æä¾›å¯¹åŒºå—é“¾ä¸­ç‰¹å®šUTXOçš„ç²¾ç¡®å®šä½
type OutPoint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TxId          []byte                 `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`                       // äº¤æ˜“æ ‡è¯†ç¬¦ï¼ˆSHA-256å“ˆå¸Œï¼‰
	OutputIndex   uint32                 `protobuf:"varint,2,opt,name=output_index,json=outputIndex,proto3" json:"output_index,omitempty"` // è¾“å‡ºç´¢å¼•ï¼ˆåœ¨äº¤æ˜“è¾“å‡ºåˆ—è¡¨ä¸­çš„ä½ç½®ï¼‰
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OutPoint) Reset() {
	*x = OutPoint{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutPoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutPoint) ProtoMessage() {}

func (x *OutPoint) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutPoint.ProtoReflect.Descriptor instead.
func (*OutPoint) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{5}
}

func (x *OutPoint) GetTxId() []byte {
	if x != nil {
		return x.TxId
	}
	return nil
}

func (x *OutPoint) GetOutputIndex() uint32 {
	if x != nil {
		return x.OutputIndex
	}
	return 0
}

// *
// Transaction - EUTXOçŠ¶æ€è½¬æ¢å™¨ï¼ˆæ ¸å¿ƒäº¤æ˜“ç»“æ„ï¼‰
//
// ğŸ¯ æœ¬è´¨å®šä¹‰ï¼ˆæ ¸å¿ƒç†å¿µï¼‰ï¼š
// **Transaction = ç»è¿‡æˆæƒçš„ UTXO çŠ¶æ€è½¬æ¢å‡½æ•°**
//
// æ›´ç›´ç™½åœ°è¯´ï¼šTX = è¯æ˜ä½ æœ‰æƒä½¿ç”¨æŸäº› UTXO + å®šä¹‰å¦‚ä½•åˆ›å»ºæ–°çš„ UTXO
//
// ğŸ”‘ ä¸‰å±‚é€’è¿›ç»“æ„ï¼š
//
// ã€ç¬¬1å±‚ - æœ€æ ¸å¿ƒï¼šæƒé™éªŒè¯ã€‘
// â€¢ å¯¹äºæ¯ä¸ªè¾“å…¥ï¼šå¿…é¡»è¯æ˜"ä½ æœ‰ä»€ä¹ˆæƒåˆ©ä½¿ç”¨è¿™ä¸ªUTXOï¼Ÿ"
// â€¢ éªŒè¯æ–¹å¼ï¼šUnlockingProof å¿…é¡»åŒ¹é… LockingCondition
// â€¢ 7ç§è¯æ˜æ–¹å¼å¯¹åº”7ç§é”å®šæ¡ä»¶
// â€¢ âš ï¸ è¿™æ˜¯å®‰å…¨çš„åŸºçŸ³ï¼šæ²¡æœ‰æƒé™ = ä¸èƒ½æ‰§è¡Œä»»ä½•æ“ä½œ
// â€¢ ä½¿ç”¨æ–¹å¼ï¼šConsumeï¼ˆæ¶ˆè´¹ï¼ŒUTXOç§»é™¤ï¼‰/ Referenceï¼ˆå¼•ç”¨ï¼ŒUTXOä¿æŒï¼‰
//
// ã€ç¬¬2å±‚ - åŠŸèƒ½å±‚ï¼šè¾“å‡ºåˆ›å»ºã€‘
// â€¢ å¯¹äºæ¯ä¸ªè¾“å‡ºï¼šå®šä¹‰"åˆ›å»ºä»€ä¹ˆç±»å‹çš„UTXOï¼Ÿç»™è°ï¼Ÿä»€ä¹ˆæƒé™ï¼Ÿ"
// â€¢ è¾“å‡ºç±»å‹ï¼šAssetï¼ˆä»·å€¼ï¼‰/ Resourceï¼ˆèƒ½åŠ›ï¼‰/ Stateï¼ˆè¯æ®ï¼‰
// â€¢ æ‰€æœ‰è€…ï¼šOwneråœ°å€
// â€¢ é”å®šæ¡ä»¶ï¼šæ–°UTXOçš„è®¿é—®æ§åˆ¶è§„åˆ™
// â€¢ âš ï¸ åˆ›å»ºæœ¬èº«ä¸éœ€è¦æƒé™ï¼Œä½†å¿…é¡»æ»¡è¶³ä»·å€¼å®ˆæ’
//
// ã€ç¬¬3å±‚ - çº¦æŸå±‚ï¼šåˆæ³•æ€§ä¿è¯ã€‘
// â€¢ ä»·å€¼å®ˆæ’ï¼šÎ£(è¾“å…¥) â‰¥ Î£(è¾“å‡º) + Fee
// â€¢ è¾“å…¥æœ‰æ•ˆï¼šæ‰€æœ‰UTXOå¿…é¡»å­˜åœ¨ä¸”æœªè¢«æ¶ˆè´¹
// â€¢ æƒé™éªŒè¯ï¼šæ‰€æœ‰UnlockingProofå¿…é¡»æœ‰æ•ˆ
// â€¢ æ¡ä»¶æ»¡è¶³ï¼šæ—¶é—´é”ã€é«˜åº¦é”ç­‰æ¡ä»¶å¿…é¡»æ»¡è¶³
//
// ğŸ—ï¸ å›ºåŒ–èƒ½åŠ›ï¼ˆæ°¸ä¸æ”¹å˜ï¼‰ï¼š
// 1. ğŸ”— UTXOå¼•ç”¨ï¼šé€šè¿‡OutPointç²¾ç¡®å®šä½
// 2. ğŸ”“ è§£é”æˆæƒï¼š7ç§æ ‡å‡†è§£é”æ–¹å¼ï¼ˆSingleKey/MultiKey/Contract/Delegation/Threshold/Time/Heightï¼‰
// 3. ğŸ¯ è¾“å‡ºåˆ›å»ºï¼š3ç§è½½ä½“ç±»å‹ï¼ˆAsset/Resource/Stateï¼‰
// 4. â° æ—¶é—´æ§åˆ¶ï¼šäº¤æ˜“çº§æ—¶é—´é”å®šå’ŒåŒºå—é«˜åº¦é”å®š
//
// âš ï¸ æ¶æ„çº¦æŸï¼ˆé˜²æ­¢æ±¡æŸ“åè®®å±‚ï¼‰ï¼š
// âŒ ä¸åº”æ·»åŠ ï¼šä¸šåŠ¡ç›¸å…³çš„å­—æ®µï¼ˆå¦‚transfer_typeã€stake_modeç­‰ï¼‰
// âŒ ä¸åº”æ·»åŠ ï¼šä¸šåŠ¡æšä¸¾ï¼ˆå¦‚TRANSFERã€MINTã€BURNã€STAKEç­‰ï¼‰
// âŒ ä¸åº”æ·»åŠ ï¼šç‰¹å®šä¸šåŠ¡çš„é…ç½®ï¼ˆå¦‚staking_configã€swap_paramsç­‰ï¼‰
// âœ… åªèƒ½åŒ…å«ï¼šçº¯ç²¹çš„è¾“å…¥è¾“å‡ºå®šä¹‰å’Œé€šç”¨éªŒè¯å­—æ®µ
//
// ğŸ’¡ ä¸šåŠ¡è¯­ä¹‰å®ç°ï¼ˆåº”ç”¨å±‚è§£é‡Šï¼‰ï¼š
// - è½¬è´¦ï¼š1ä¸ªAssetInput(æ¶ˆè´¹) + 2ä¸ªAssetOutput(è½¬è´¦+æ‰¾é›¶)
// - é“¸é€ ï¼š0ä¸ªInput + Nä¸ªAssetOutput
// - é”€æ¯ï¼šNä¸ªAssetInput(æ¶ˆè´¹) + 0ä¸ªOutput
// - è´¨æŠ¼ï¼šNä¸ªAssetInput + Mä¸ªAssetOutput(å¸¦ContractLock)
// - éƒ¨ç½²ï¼šNä¸ªAssetInput(è´¹ç”¨) + 1ä¸ªResourceOutput
// - è°ƒç”¨ï¼šAssetInput(è´¹ç”¨) + ResourceInput(å¼•ç”¨) + StateOutput(ç»“æœ)
//
// ğŸ¯ ä¸ºä»€ä¹ˆæƒé™éªŒè¯æ˜¯æ ¸å¿ƒï¼Ÿ
// â€¢ æ²¡æœ‰æƒé™éªŒè¯ â†’ ä»»ä½•äººéƒ½å¯ä»¥èŠ±è´¹åˆ«äººçš„UTXO â†’ åŒºå—é“¾æ¯«æ— å®‰å…¨æ€§
// â€¢ æœ‰äº†æƒé™éªŒè¯ â†’ åªæœ‰æŒæœ‰æ­£ç¡®å¯†é’¥/è¯æ˜çš„äººæ‰èƒ½ä½¿ç”¨UTXO â†’ å¯†ç å­¦å®‰å…¨ä¿è¯
// â€¢ UnlockingProof + LockingCondition = åŒºå—é“¾å®‰å…¨çš„åŸºçŸ³
type Transaction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ==================== ğŸ¯ æ ¸å¿ƒå¿…éœ€å­—æ®µ ====================
	Version uint32      `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"` // äº¤æ˜“ç‰ˆæœ¬å·
	Inputs  []*TxInput  `protobuf:"bytes,2,rep,name=inputs,proto3" json:"inputs,omitempty"`    // äº¤æ˜“è¾“å…¥åˆ—è¡¨ï¼ˆUTXOå¼•ç”¨+è§£é”è¯æ˜ï¼‰
	Outputs []*TxOutput `protobuf:"bytes,3,rep,name=outputs,proto3" json:"outputs,omitempty"`  // äº¤æ˜“è¾“å‡ºåˆ—è¡¨ï¼ˆæ–°UTXOåˆ›å»ºï¼‰
	// *
	// è´¦æˆ·nonce - é‡æ”¾æ”»å‡»é˜²æŠ¤ç³»ç»Ÿ
	Nonce uint64 `protobuf:"varint,20,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// *
	// äº¤æ˜“åˆ›å»ºæ—¶é—´æˆ³ï¼ˆå¿…éœ€ï¼‰
	CreationTimestamp uint64 `protobuf:"varint,21,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// *
	// é“¾IDï¼ˆé˜²è·¨é“¾é‡æ”¾æ”»å‡»ï¼‰
	ChainId []byte `protobuf:"bytes,24,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// *
	// äº¤æ˜“æœ‰æ•ˆæœŸçª—å£ï¼ˆå¯é€‰ï¼‰
	//
	// Types that are valid to be assigned to ValidityWindow:
	//
	//	*Transaction_TimeWindow
	//	*Transaction_HeightWindow
	ValidityWindow isTransaction_ValidityWindow `protobuf_oneof:"validity_window"`
	// *
	// ç»Ÿä¸€äº¤æ˜“è´¹ç”¨æœºåˆ¶ï¼ˆå¯é€‰ï¼Œä¸è®¾ç½®åˆ™ä½¿ç”¨UTXOå·®é¢ï¼‰
	//
	// **é»˜è®¤ï¼šUTXOå·®é¢æœºåˆ¶**
	// å¦‚æœæœªè®¾ç½®fee_mechanismï¼Œä½¿ç”¨æœ€ç®€å•çš„UTXOå·®é¢ï¼š
	// äº¤æ˜“è´¹ç”¨ = Î£(è¾“å…¥é‡‘é¢) - Î£(è¾“å‡ºé‡‘é¢)
	//
	// **å¯é€‰ï¼šç‰¹æ®Šçº¦æŸæœºåˆ¶**
	// å½“éœ€è¦ç‰¹æ®Šè´¹ç”¨çº¦æŸæ—¶ï¼Œå¯è®¾ç½®ä»¥ä¸‹æ¨¡å¼ï¼š
	// - minimum_fee: é˜²åƒåœ¾äº¤æ˜“ï¼Œè®¾ç½®è´¹ç”¨ä¸‹é™
	// - proportional_fee: æŒ‰æ¯”ä¾‹æ”¶è´¹ï¼ˆå¦‚ä¸‡åˆ†ä¹‹ä¸‰ï¼‰
	// - contract_fee: åˆçº¦è°ƒç”¨ï¼Œå›ºå®šè´¹ç”¨æ¨¡å¼
	// - priority_fee: ç´§æ€¥äº¤æ˜“ï¼Œä¼˜å…ˆçº§åŠ é€Ÿ
	//
	// Types that are valid to be assigned to FeeMechanism:
	//
	//	*Transaction_MinimumFee
	//	*Transaction_ProportionalFee
	//	*Transaction_ContractFee
	//	*Transaction_PriorityFee
	FeeMechanism isTransaction_FeeMechanism `protobuf_oneof:"fee_mechanism"`
	// *
	// äº¤æ˜“å…ƒæ•°æ®ï¼ˆå¯é€‰ï¼‰
	Metadata *TransactionMetadata `protobuf:"bytes,6,opt,name=metadata,proto3,oneof" json:"metadata,omitempty"`
	// *
	// èµ„æºå¤–æŒ‚é™„ä»¶å¼•ç”¨åˆ—è¡¨ï¼ˆå¯é€‰ï¼‰
	ResourceAttachmentHashes [][]byte `protobuf:"bytes,50,rep,name=resource_attachment_hashes,json=resourceAttachmentHashes,proto3" json:"resource_attachment_hashes,omitempty"` // å¤–æŒ‚èµ„æºé™„ä»¶å“ˆå¸Œåˆ—è¡¨
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *Transaction) Reset() {
	*x = Transaction{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transaction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transaction) ProtoMessage() {}

func (x *Transaction) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transaction.ProtoReflect.Descriptor instead.
func (*Transaction) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{6}
}

func (x *Transaction) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *Transaction) GetInputs() []*TxInput {
	if x != nil {
		return x.Inputs
	}
	return nil
}

func (x *Transaction) GetOutputs() []*TxOutput {
	if x != nil {
		return x.Outputs
	}
	return nil
}

func (x *Transaction) GetNonce() uint64 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

func (x *Transaction) GetCreationTimestamp() uint64 {
	if x != nil {
		return x.CreationTimestamp
	}
	return 0
}

func (x *Transaction) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *Transaction) GetValidityWindow() isTransaction_ValidityWindow {
	if x != nil {
		return x.ValidityWindow
	}
	return nil
}

func (x *Transaction) GetTimeWindow() *TimeBasedWindow {
	if x != nil {
		if x, ok := x.ValidityWindow.(*Transaction_TimeWindow); ok {
			return x.TimeWindow
		}
	}
	return nil
}

func (x *Transaction) GetHeightWindow() *HeightBasedWindow {
	if x != nil {
		if x, ok := x.ValidityWindow.(*Transaction_HeightWindow); ok {
			return x.HeightWindow
		}
	}
	return nil
}

func (x *Transaction) GetFeeMechanism() isTransaction_FeeMechanism {
	if x != nil {
		return x.FeeMechanism
	}
	return nil
}

func (x *Transaction) GetMinimumFee() *MinimumFee {
	if x != nil {
		if x, ok := x.FeeMechanism.(*Transaction_MinimumFee); ok {
			return x.MinimumFee
		}
	}
	return nil
}

func (x *Transaction) GetProportionalFee() *ProportionalFee {
	if x != nil {
		if x, ok := x.FeeMechanism.(*Transaction_ProportionalFee); ok {
			return x.ProportionalFee
		}
	}
	return nil
}

func (x *Transaction) GetContractFee() *ContractExecutionFee {
	if x != nil {
		if x, ok := x.FeeMechanism.(*Transaction_ContractFee); ok {
			return x.ContractFee
		}
	}
	return nil
}

func (x *Transaction) GetPriorityFee() *PriorityFee {
	if x != nil {
		if x, ok := x.FeeMechanism.(*Transaction_PriorityFee); ok {
			return x.PriorityFee
		}
	}
	return nil
}

func (x *Transaction) GetMetadata() *TransactionMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Transaction) GetResourceAttachmentHashes() [][]byte {
	if x != nil {
		return x.ResourceAttachmentHashes
	}
	return nil
}

type isTransaction_ValidityWindow interface {
	isTransaction_ValidityWindow()
}

type Transaction_TimeWindow struct {
	TimeWindow *TimeBasedWindow `protobuf:"bytes,22,opt,name=time_window,json=timeWindow,proto3,oneof"` // åŸºäºæ—¶é—´æˆ³çš„çª—å£æ§åˆ¶
}

type Transaction_HeightWindow struct {
	HeightWindow *HeightBasedWindow `protobuf:"bytes,23,opt,name=height_window,json=heightWindow,proto3,oneof"` // åŸºäºåŒºå—é«˜åº¦çš„çª—å£æ§åˆ¶
}

func (*Transaction_TimeWindow) isTransaction_ValidityWindow() {}

func (*Transaction_HeightWindow) isTransaction_ValidityWindow() {}

type isTransaction_FeeMechanism interface {
	isTransaction_FeeMechanism()
}

type Transaction_MinimumFee struct {
	// æ¨¡å¼2ï¼šæœ€ä½è´¹ç”¨ä¿è¯
	MinimumFee *MinimumFee `protobuf:"bytes,30,opt,name=minimum_fee,json=minimumFee,proto3,oneof"` // æœ€ä½è´¹ç”¨ä¿è¯
}

type Transaction_ProportionalFee struct {
	// æ¨¡å¼3ï¼šæ¯”ä¾‹è´¹ç”¨ï¼ˆä¸‡åˆ†ä¹‹ä¸‰ç­‰ï¼‰
	ProportionalFee *ProportionalFee `protobuf:"bytes,31,opt,name=proportional_fee,json=proportionalFee,proto3,oneof"` // æ¯”ä¾‹è´¹ç”¨
}

type Transaction_ContractFee struct {
	// æ¨¡å¼4ï¼šåˆçº¦æ‰§è¡Œè´¹ç”¨ï¼ˆå›ºå®šè´¹ç”¨æ¨¡å¼ï¼‰
	ContractFee *ContractExecutionFee `protobuf:"bytes,32,opt,name=contract_fee,json=contractFee,proto3,oneof"` // åˆçº¦æ‰§è¡Œè´¹ç”¨
}

type Transaction_PriorityFee struct {
	// æ¨¡å¼5ï¼šä¼˜å…ˆçº§è´¹ç”¨ï¼ˆå¿«é€Ÿç¡®è®¤ï¼‰
	PriorityFee *PriorityFee `protobuf:"bytes,33,opt,name=priority_fee,json=priorityFee,proto3,oneof"` // ä¼˜å…ˆçº§è´¹ç”¨
}

func (*Transaction_MinimumFee) isTransaction_FeeMechanism() {}

func (*Transaction_ProportionalFee) isTransaction_FeeMechanism() {}

func (*Transaction_ContractFee) isTransaction_FeeMechanism() {}

func (*Transaction_PriorityFee) isTransaction_FeeMechanism() {}

// *
// TxInput - UTXOè¾“å…¥å¼•ç”¨ï¼ˆçŠ¶æ€è½¬æ¢çš„è¾“å…¥ï¼‰
//
// ğŸ¯ æ ¸å¿ƒèŒè´£ï¼š
// å®ç°å¯¹å·²æœ‰UTXOçš„ç²¾ç¡®å¼•ç”¨å’Œæ ‡å‡†åŒ–è§£é”ï¼Œæ”¯æŒä¸¤ç§ä½¿ç”¨æ¨¡å¼ã€‚
//
// ğŸ”„ ä¸¤ç§å¼•ç”¨æ¨¡å¼ï¼ˆå›ºåŒ–èƒ½åŠ›ï¼‰ï¼š
// 1. æ¶ˆè´¹å¼•ç”¨ï¼ˆConsumeï¼‰ï¼šUTXOè¢«æ¶ˆè´¹ï¼Œä»å¯ç”¨UTXOé›†åˆä¸­ç§»é™¤
//   - æ ‡è¯†ï¼šis_reference_only = false
//   - ä½¿ç”¨åœºæ™¯ï¼šè½¬è´¦ã€æ”¯ä»˜æ‰‹ç»­è´¹ã€èµ„æºå‡çº§ã€æƒé™è½¬ç§»
//   - ç”Ÿå‘½å‘¨æœŸï¼šä¸€æ—¦è¢«æ¶ˆè´¹ï¼ŒUTXOä»é›†åˆä¸­ç§»é™¤
//   - æƒé™è¦æ±‚ï¼šå¿…é¡»æä¾›æœ‰æ•ˆçš„UnlockingProof
//
// 2. åªè¯»å¼•ç”¨ï¼ˆReferenceï¼‰ï¼šUTXOè¢«å¼•ç”¨ä½†ä¸æ¶ˆè´¹ï¼Œä¿æŒåœ¨UTXOé›†åˆä¸­
//   - æ ‡è¯†ï¼šis_reference_only = true
//   - ä½¿ç”¨åœºæ™¯ï¼šåˆçº¦è°ƒç”¨ã€æ¨¡å‹æ¨ç†ã€æ–‡ä»¶è®¿é—®ã€çŠ¶æ€æŸ¥è¯¢
//   - ç”Ÿå‘½å‘¨æœŸï¼šUTXOä¿æŒåœ¨é›†åˆä¸­ï¼Œæ”¯æŒå¹¶å‘è®¿é—®
//   - æƒé™è¦æ±‚ï¼šå¿…é¡»æä¾›æœ‰æ•ˆçš„UnlockingProofï¼ˆéªŒè¯è®¿é—®æƒé™ï¼‰
//
// ğŸ”‘ è§£é”è¯æ˜ç³»ç»Ÿï¼ˆ7ç§å›ºåŒ–æ–¹å¼ï¼‰ï¼š
// æä¾›å¯¹åº”é”å®šæ¡ä»¶çš„"é’¥åŒ™"ï¼Œæ”¯æŒ7ç§æ ‡å‡†è§£é”æ–¹å¼ï¼š
// - SingleKeyProofï¼šå•å¯†é’¥ç­¾å
// - MultiKeyProofï¼šM-of-Nå¤šé‡ç­¾å
// - ExecutionProofï¼šISPCæ‰§è¡Œè¯æ˜ï¼ˆé€šç”¨ï¼Œé€‚ç”¨äºåˆçº¦/æ¨¡å‹/å…¶ä»–ï¼‰
// - DelegationProofï¼šå§”æ‰˜æˆæƒè¯æ˜
// - ThresholdProofï¼šé—¨é™ç­¾åè¯æ˜
// - TimeProofï¼šæ—¶é—´é”è¯æ˜ï¼ˆé€’å½’åŒ…å«åŸºç¡€è¯æ˜ï¼‰
// - HeightProofï¼šé«˜åº¦é”è¯æ˜ï¼ˆé€’å½’åŒ…å«åŸºç¡€è¯æ˜ï¼‰
//
// âš ï¸ æ¶æ„çº¦æŸï¼š
// âœ… åªå…³å¿ƒï¼šOutPoint(ä½ç½®) + is_reference_only(æ¨¡å¼) + UnlockingProof(æƒé™)
// âŒ ä¸å…³å¿ƒï¼šä¸šåŠ¡è¯­ä¹‰ï¼ˆæ˜¯è½¬è´¦è¿˜æ˜¯è´¨æŠ¼ï¼Ÿç”±åº”ç”¨å±‚è§£é‡Šï¼‰
// âŒ ä¸æ·»åŠ ï¼šä¸šåŠ¡ç›¸å…³å­—æ®µï¼ˆå¦‚input_purposeã€operation_typeç­‰ï¼‰
type TxInput struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	PreviousOutput  *OutPoint              `protobuf:"bytes,1,opt,name=previous_output,json=previousOutput,proto3" json:"previous_output,omitempty"`       // å¼•ç”¨çš„UTXOä½ç½®ï¼ˆäº¤æ˜“å“ˆå¸Œ+è¾“å‡ºç´¢å¼•ï¼‰
	IsReferenceOnly bool                   `protobuf:"varint,2,opt,name=is_reference_only,json=isReferenceOnly,proto3" json:"is_reference_only,omitempty"` // å¼•ç”¨æ¨¡å¼ï¼ˆtrue=åªè¯»å¼•ç”¨ï¼Œfalse=æ¶ˆè´¹å¼•ç”¨ï¼‰
	// è¯´æ˜ï¼šé€šè¿‡ OutPoint å¼•ç”¨ ResourceOutput UTXO
	//   - åªè¯»å¼•ç”¨ï¼šä¸æ¶ˆè´¹UTXOï¼ˆé™æ€èµ„æºè®¿é—®/å¯æ‰§è¡Œèµ„æºè°ƒç”¨ï¼‰
	//   - æ¶ˆè´¹å¼•ç”¨ï¼šæ¶ˆè´¹UTXOï¼ˆæ‰€æœ‰æƒ/æƒé™å˜æ›´ã€æ›¿æ¢å‡çº§ç­‰ï¼‰
	Sequence uint32 `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"` // åºåˆ—å·ï¼ˆç”¨äºRBFã€æ—¶é—´é”ç­‰é«˜çº§åŠŸèƒ½ï¼‰
	// è§£é”è¯æ˜ï¼ˆæä¾›"é’¥åŒ™"æ¥æ‰“å¼€é”å®šæ¡ä»¶ï¼‰
	//
	// Types that are valid to be assigned to UnlockingProof:
	//
	//	*TxInput_SingleKeyProof
	//	*TxInput_MultiKeyProof
	//	*TxInput_ExecutionProof
	//	*TxInput_DelegationProof
	//	*TxInput_ThresholdProof
	//	*TxInput_TimeProof
	//	*TxInput_HeightProof
	UnlockingProof isTxInput_UnlockingProof `protobuf_oneof:"unlocking_proof"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TxInput) Reset() {
	*x = TxInput{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TxInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TxInput) ProtoMessage() {}

func (x *TxInput) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TxInput.ProtoReflect.Descriptor instead.
func (*TxInput) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{7}
}

func (x *TxInput) GetPreviousOutput() *OutPoint {
	if x != nil {
		return x.PreviousOutput
	}
	return nil
}

func (x *TxInput) GetIsReferenceOnly() bool {
	if x != nil {
		return x.IsReferenceOnly
	}
	return false
}

func (x *TxInput) GetSequence() uint32 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *TxInput) GetUnlockingProof() isTxInput_UnlockingProof {
	if x != nil {
		return x.UnlockingProof
	}
	return nil
}

func (x *TxInput) GetSingleKeyProof() *SingleKeyProof {
	if x != nil {
		if x, ok := x.UnlockingProof.(*TxInput_SingleKeyProof); ok {
			return x.SingleKeyProof
		}
	}
	return nil
}

func (x *TxInput) GetMultiKeyProof() *MultiKeyProof {
	if x != nil {
		if x, ok := x.UnlockingProof.(*TxInput_MultiKeyProof); ok {
			return x.MultiKeyProof
		}
	}
	return nil
}

func (x *TxInput) GetExecutionProof() *ExecutionProof {
	if x != nil {
		if x, ok := x.UnlockingProof.(*TxInput_ExecutionProof); ok {
			return x.ExecutionProof
		}
	}
	return nil
}

func (x *TxInput) GetDelegationProof() *DelegationProof {
	if x != nil {
		if x, ok := x.UnlockingProof.(*TxInput_DelegationProof); ok {
			return x.DelegationProof
		}
	}
	return nil
}

func (x *TxInput) GetThresholdProof() *ThresholdProof {
	if x != nil {
		if x, ok := x.UnlockingProof.(*TxInput_ThresholdProof); ok {
			return x.ThresholdProof
		}
	}
	return nil
}

func (x *TxInput) GetTimeProof() *TimeProof {
	if x != nil {
		if x, ok := x.UnlockingProof.(*TxInput_TimeProof); ok {
			return x.TimeProof
		}
	}
	return nil
}

func (x *TxInput) GetHeightProof() *HeightProof {
	if x != nil {
		if x, ok := x.UnlockingProof.(*TxInput_HeightProof); ok {
			return x.HeightProof
		}
	}
	return nil
}

type isTxInput_UnlockingProof interface {
	isTxInput_UnlockingProof()
}

type TxInput_SingleKeyProof struct {
	SingleKeyProof *SingleKeyProof `protobuf:"bytes,10,opt,name=single_key_proof,json=singleKeyProof,proto3,oneof"` // å•å¯†é’¥è§£é”è¯æ˜
}

type TxInput_MultiKeyProof struct {
	MultiKeyProof *MultiKeyProof `protobuf:"bytes,11,opt,name=multi_key_proof,json=multiKeyProof,proto3,oneof"` // å¤šå¯†é’¥è§£é”è¯æ˜
}

type TxInput_ExecutionProof struct {
	ExecutionProof *ExecutionProof `protobuf:"bytes,17,opt,name=execution_proof,json=executionProof,proto3,oneof"` // âœ… ISPCæ‰§è¡Œè¯æ˜ï¼ˆé€šç”¨ï¼Œé€‚ç”¨äºåˆçº¦/æ¨¡å‹/å…¶ä»–ï¼‰
}

type TxInput_DelegationProof struct {
	DelegationProof *DelegationProof `protobuf:"bytes,13,opt,name=delegation_proof,json=delegationProof,proto3,oneof"` // å§”æ‰˜æˆæƒè§£é”è¯æ˜
}

type TxInput_ThresholdProof struct {
	ThresholdProof *ThresholdProof `protobuf:"bytes,14,opt,name=threshold_proof,json=thresholdProof,proto3,oneof"` // é—¨é™ç­¾åè§£é”è¯æ˜
}

type TxInput_TimeProof struct {
	TimeProof *TimeProof `protobuf:"bytes,15,opt,name=time_proof,json=timeProof,proto3,oneof"` // æ—¶é—´é”è§£é”è¯æ˜
}

type TxInput_HeightProof struct {
	HeightProof *HeightProof `protobuf:"bytes,16,opt,name=height_proof,json=heightProof,proto3,oneof"` // é«˜åº¦é”è§£é”è¯æ˜
}

func (*TxInput_SingleKeyProof) isTxInput_UnlockingProof() {}

func (*TxInput_MultiKeyProof) isTxInput_UnlockingProof() {}

func (*TxInput_ExecutionProof) isTxInput_UnlockingProof() {}

func (*TxInput_DelegationProof) isTxInput_UnlockingProof() {}

func (*TxInput_ThresholdProof) isTxInput_UnlockingProof() {}

func (*TxInput_TimeProof) isTxInput_UnlockingProof() {}

func (*TxInput_HeightProof) isTxInput_UnlockingProof() {}

// *
// TxOutput - UTXOè¾“å‡ºåˆ›å»ºï¼ˆçŠ¶æ€è½¬æ¢çš„è¾“å‡ºï¼‰
//
// ğŸ¯ æ ¸å¿ƒå®šä½ï¼š
// åˆ›å»ºæ–°çš„UTXOï¼Œå®ç°ç»Ÿä¸€æƒåˆ©è½½ä½“ç†è®ºçš„ä¸‰å±‚è½½ä½“åˆ›å»ºæ¶æ„ã€‚
//
// ğŸ—ï¸ ä¸‰ç§è¾“å‡ºç±»å‹ï¼ˆå›ºåŒ–èƒ½åŠ›ï¼Œæ°¸ä¸æ”¹å˜ï¼‰ï¼š
//
// 1. **AssetOutput**ï¼šåˆ›å»ºä»·å€¼è½½ä½“UTXO
//   - èŒè´£ï¼šæ‰¿è½½ç»æµä»·å€¼æƒåˆ©ï¼ˆæ‰€æœ‰æƒã€è½¬ç§»æƒã€æ”¶ç›Šæƒï¼‰
//   - ç”¨é€”ï¼šè½¬è´¦ã€æ‰¾é›¶ã€å¥–åŠ±ã€æŠµæŠ¼
//   - ç”Ÿå‘½å‘¨æœŸï¼šæ¶ˆè´¹åç§»é™¤
//   - æƒåˆ©æ§åˆ¶ï¼šé€šè¿‡locking_conditionså®šä¹‰è®¿é—®æƒé™
//   - åº”ç”¨å±‚è§£é‡Šï¼š
//   - åˆ›å»º1ä¸ª â†’ è½¬è´¦æ¥æ”¶
//   - åˆ›å»º2ä¸ª â†’ è½¬è´¦+æ‰¾é›¶
//   - ä»æ— åˆ›å»º â†’ é“¸é€ /åˆ›ä¸–
//   - å¸¦ContractLock â†’ è´¨æŠ¼é”å®š
//
// 2. **ResourceOutput**ï¼šåˆ›å»ºèƒ½åŠ›è½½ä½“UTXO
//   - èŒè´£ï¼šæ‰¿è½½è®¡ç®—èƒ½åŠ›æƒåˆ©ï¼ˆä½¿ç”¨æƒã€æ‰§è¡Œæƒã€é…ç½®æƒï¼‰
//   - ç”¨é€”ï¼šæ™ºèƒ½åˆçº¦éƒ¨ç½²ã€AIæ¨¡å‹ä¸Šä¼ ã€æ–‡æ¡£å‘å¸ƒã€æ•°æ®å­˜å‚¨
//   - ç”Ÿå‘½å‘¨æœŸï¼šåˆ›å»ºåå¯è¢«å¼•ç”¨ï¼ˆé€šè¿‡TxInput.is_reference_only=trueï¼‰
//   - æƒåˆ©æ§åˆ¶ï¼šé€šè¿‡locking_conditionså®šä¹‰åˆå§‹è®¿é—®æ§åˆ¶
//   - åº”ç”¨å±‚è§£é‡Šï¼š
//   - åˆ›å»ºWASMåˆçº¦ â†’ åˆçº¦éƒ¨ç½²
//   - åˆ›å»ºONNXæ¨¡å‹ â†’ æ¨¡å‹éƒ¨ç½²
//   - åˆ›å»ºæ–‡æ¡£/å›¾ç‰‡ â†’ é™æ€èµ„æºä¸Šä¼ 
//
// 3. **StateOutput**ï¼šåˆ›å»ºè¯æ®è½½ä½“UTXO
//   - èŒè´£ï¼šæ‰¿è½½å†å²è¯æ®æƒåˆ©ï¼ˆè¯æ˜æƒã€æŸ¥è¯¢æƒã€è¿½æº¯æƒï¼‰
//   - ç”¨é€”ï¼šæ‰§è¡Œç»“æœã€çŠ¶æ€å¿«ç…§ã€å®¡è®¡è®°å½•
//   - ç”Ÿå‘½å‘¨æœŸï¼šå¯è®¾ç½®TTLï¼Œæ”¯æŒå†å²è¿½æº¯
//   - æƒåˆ©æ§åˆ¶ï¼šé€šè¿‡locking_conditionså®šä¹‰è¯æ®è®¿é—®æƒåˆ©
//   - åº”ç”¨å±‚è§£é‡Šï¼š
//   - åˆçº¦æ‰§è¡Œç»“æœ â†’ æ‰§è¡Œè¯æ˜
//   - æ¨¡å‹æ¨ç†è¾“å‡º â†’ æ¨ç†è®°å½•
//   - çŠ¶æ€å¿«ç…§ â†’ å®¡è®¡è¿½æº¯
//
// âš ï¸ é‡è¦æ¦‚å¿µåŒºåˆ†ï¼ˆé˜²æ­¢è®¾è®¡é”™è¯¯ï¼‰ï¼š
// - TxOutput = åˆ›å»ºæ–°UTXOï¼ˆCreationï¼‰
// - TxInput + OutPoint = å¼•ç”¨å·²å­˜åœ¨çš„UTXOï¼ˆReferenceï¼‰
// - ä¸åº”æ··æ·†"åˆ›å»º"ä¸"å¼•ç”¨"çš„æ¦‚å¿µ
//
// ğŸ”§ å…³é”®è®¾è®¡åŸåˆ™ï¼š
// - èµ„æºåˆ›å»ºï¼šTxOutput.ResourceOutputï¼ˆåŒ…å«å®Œæ•´Resourceå®šä¹‰ï¼‰
// - èµ„æºå¼•ç”¨ï¼šTxInput + OutPoint + is_reference_only=true
// - èµ„æºæ¶ˆè´¹ï¼šTxInput + OutPoint + is_reference_only=false
// - æƒåˆ©ç®¡ç†ï¼šç»Ÿä¸€ä½¿ç”¨locking_conditionsè¡¨è¾¾è®¿é—®æ§åˆ¶
// - å†…å®¹å¯»å€ï¼šèµ„æºå†…å®¹å­˜å‚¨åœ¨å†…å®¹å¯»å€ç½‘ç»œï¼ŒåŒºå—é“¾åªè®°å½•å“ˆå¸Œå’Œå…ƒä¿¡æ¯
//
// âš ï¸ æ¶æ„çº¦æŸï¼š
// âœ… åªå…³å¿ƒï¼šOwner + LockingConditions + OutputContent(ä¸‰é€‰ä¸€)
// âŒ ä¸å…³å¿ƒï¼šä¸šåŠ¡è¯­ä¹‰ï¼ˆæ˜¯è½¬è´¦è¿˜æ˜¯éƒ¨ç½²ï¼Ÿç”±åº”ç”¨å±‚è§£é‡Šï¼‰
// âŒ ä¸æ·»åŠ ï¼šä¸šåŠ¡ç›¸å…³å­—æ®µï¼ˆå¦‚output_purposeã€operation_contextç­‰ï¼‰
// âœ… å›ºåŒ–èƒ½åŠ›ï¼š3ç§è¾“å‡ºç±»å‹æ°¸ä¸æ”¹å˜ï¼Œé€šè¿‡ç»„åˆå®ç°æ‰€æœ‰ä¸šåŠ¡åœºæ™¯
//
// ğŸ’¡ ç†è®ºæ˜ å°„ï¼š
// - TxOutput = æƒåˆ©è½½ä½“åˆ›å»ºå±‚çš„å…·ä½“å®ç°
// - locking_conditions = æƒåˆ©çº¦æŸçš„ç¼–ç å®ç°
// - ä¸‰ç§output_content = ä¸‰ç§æƒåˆ©è½½ä½“ç±»å‹çš„EUTXOåˆ›å»ºå…·ç°åŒ–
// - ç¬¦åˆç»Ÿä¸€æƒåˆ©è½½ä½“ç†è®ºã€EUTXOæƒåˆ©å…·ç°åŒ–ç†è®ºã€ç»Ÿä¸€èµ„æºç®¡ç†ç†è®º
type TxOutput struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Owner             []byte                 `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`                                                  // æ‰€æœ‰è€…åœ°å€ï¼ˆç´¢å¼•/å±•ç¤ºç”¨é€”ï¼Œæƒé™ä»¥locking_conditionsä¸ºå‡†ï¼‰
	LockingConditions []*LockingCondition    `protobuf:"bytes,2,rep,name=locking_conditions,json=lockingConditions,proto3" json:"locking_conditions,omitempty"` // é”å®šæ¡ä»¶åˆ—è¡¨
	// ä¸‰å±‚UTXOè¾“å‡ºç³»ç»Ÿï¼ˆè½½ä½“åˆ›å»ºï¼‰
	//
	// Types that are valid to be assigned to OutputContent:
	//
	//	*TxOutput_Asset
	//	*TxOutput_State
	//	*TxOutput_Resource
	OutputContent isTxOutput_OutputContent `protobuf_oneof:"output_content"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TxOutput) Reset() {
	*x = TxOutput{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TxOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TxOutput) ProtoMessage() {}

func (x *TxOutput) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TxOutput.ProtoReflect.Descriptor instead.
func (*TxOutput) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{8}
}

func (x *TxOutput) GetOwner() []byte {
	if x != nil {
		return x.Owner
	}
	return nil
}

func (x *TxOutput) GetLockingConditions() []*LockingCondition {
	if x != nil {
		return x.LockingConditions
	}
	return nil
}

func (x *TxOutput) GetOutputContent() isTxOutput_OutputContent {
	if x != nil {
		return x.OutputContent
	}
	return nil
}

func (x *TxOutput) GetAsset() *AssetOutput {
	if x != nil {
		if x, ok := x.OutputContent.(*TxOutput_Asset); ok {
			return x.Asset
		}
	}
	return nil
}

func (x *TxOutput) GetState() *StateOutput {
	if x != nil {
		if x, ok := x.OutputContent.(*TxOutput_State); ok {
			return x.State
		}
	}
	return nil
}

func (x *TxOutput) GetResource() *ResourceOutput {
	if x != nil {
		if x, ok := x.OutputContent.(*TxOutput_Resource); ok {
			return x.Resource
		}
	}
	return nil
}

type isTxOutput_OutputContent interface {
	isTxOutput_OutputContent()
}

type TxOutput_Asset struct {
	Asset *AssetOutput `protobuf:"bytes,10,opt,name=asset,proto3,oneof"` // Type 1: åˆ›å»ºä»·å€¼è½½ä½“UTXO
}

type TxOutput_State struct {
	State *StateOutput `protobuf:"bytes,12,opt,name=state,proto3,oneof"` // Type 2: åˆ›å»ºè¯æ®è½½ä½“UTXO
}

type TxOutput_Resource struct {
	Resource *ResourceOutput `protobuf:"bytes,13,opt,name=resource,proto3,oneof"` // Type 3: åˆ›å»ºèƒ½åŠ›è½½ä½“UTXO
}

func (*TxOutput_Asset) isTxOutput_OutputContent() {}

func (*TxOutput_State) isTxOutput_OutputContent() {}

func (*TxOutput_Resource) isTxOutput_OutputContent() {}

// *
// LockingCondition - UTXOé”å®šæ¡ä»¶ï¼ˆå®šä¹‰"è¦æ±‚ä»€ä¹ˆæ‰èƒ½æ¶ˆè´¹"ï¼‰
type LockingCondition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Condition:
	//
	//	*LockingCondition_SingleKeyLock
	//	*LockingCondition_MultiKeyLock
	//	*LockingCondition_ContractLock
	//	*LockingCondition_DelegationLock
	//	*LockingCondition_ThresholdLock
	//	*LockingCondition_TimeLock
	//	*LockingCondition_HeightLock
	Condition     isLockingCondition_Condition `protobuf_oneof:"condition"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LockingCondition) Reset() {
	*x = LockingCondition{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LockingCondition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LockingCondition) ProtoMessage() {}

func (x *LockingCondition) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LockingCondition.ProtoReflect.Descriptor instead.
func (*LockingCondition) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{9}
}

func (x *LockingCondition) GetCondition() isLockingCondition_Condition {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *LockingCondition) GetSingleKeyLock() *SingleKeyLock {
	if x != nil {
		if x, ok := x.Condition.(*LockingCondition_SingleKeyLock); ok {
			return x.SingleKeyLock
		}
	}
	return nil
}

func (x *LockingCondition) GetMultiKeyLock() *MultiKeyLock {
	if x != nil {
		if x, ok := x.Condition.(*LockingCondition_MultiKeyLock); ok {
			return x.MultiKeyLock
		}
	}
	return nil
}

func (x *LockingCondition) GetContractLock() *ContractLock {
	if x != nil {
		if x, ok := x.Condition.(*LockingCondition_ContractLock); ok {
			return x.ContractLock
		}
	}
	return nil
}

func (x *LockingCondition) GetDelegationLock() *DelegationLock {
	if x != nil {
		if x, ok := x.Condition.(*LockingCondition_DelegationLock); ok {
			return x.DelegationLock
		}
	}
	return nil
}

func (x *LockingCondition) GetThresholdLock() *ThresholdLock {
	if x != nil {
		if x, ok := x.Condition.(*LockingCondition_ThresholdLock); ok {
			return x.ThresholdLock
		}
	}
	return nil
}

func (x *LockingCondition) GetTimeLock() *TimeLock {
	if x != nil {
		if x, ok := x.Condition.(*LockingCondition_TimeLock); ok {
			return x.TimeLock
		}
	}
	return nil
}

func (x *LockingCondition) GetHeightLock() *HeightLock {
	if x != nil {
		if x, ok := x.Condition.(*LockingCondition_HeightLock); ok {
			return x.HeightLock
		}
	}
	return nil
}

type isLockingCondition_Condition interface {
	isLockingCondition_Condition()
}

type LockingCondition_SingleKeyLock struct {
	SingleKeyLock *SingleKeyLock `protobuf:"bytes,1,opt,name=single_key_lock,json=singleKeyLock,proto3,oneof"` // å•å¯†é’¥é”å®š
}

type LockingCondition_MultiKeyLock struct {
	MultiKeyLock *MultiKeyLock `protobuf:"bytes,2,opt,name=multi_key_lock,json=multiKeyLock,proto3,oneof"` // å¤šå¯†é’¥é”å®š
}

type LockingCondition_ContractLock struct {
	ContractLock *ContractLock `protobuf:"bytes,3,opt,name=contract_lock,json=contractLock,proto3,oneof"` // åˆçº¦é”å®š
}

type LockingCondition_DelegationLock struct {
	DelegationLock *DelegationLock `protobuf:"bytes,4,opt,name=delegation_lock,json=delegationLock,proto3,oneof"` // å§”æ‰˜é”å®š
}

type LockingCondition_ThresholdLock struct {
	ThresholdLock *ThresholdLock `protobuf:"bytes,5,opt,name=threshold_lock,json=thresholdLock,proto3,oneof"` // é—¨é™ç­¾åé”å®š
}

type LockingCondition_TimeLock struct {
	TimeLock *TimeLock `protobuf:"bytes,6,opt,name=time_lock,json=timeLock,proto3,oneof"` // æ—¶é—´é”å®š
}

type LockingCondition_HeightLock struct {
	HeightLock *HeightLock `protobuf:"bytes,7,opt,name=height_lock,json=heightLock,proto3,oneof"` // é«˜åº¦é”å®š
}

func (*LockingCondition_SingleKeyLock) isLockingCondition_Condition() {}

func (*LockingCondition_MultiKeyLock) isLockingCondition_Condition() {}

func (*LockingCondition_ContractLock) isLockingCondition_Condition() {}

func (*LockingCondition_DelegationLock) isLockingCondition_Condition() {}

func (*LockingCondition_ThresholdLock) isLockingCondition_Condition() {}

func (*LockingCondition_TimeLock) isLockingCondition_Condition() {}

func (*LockingCondition_HeightLock) isLockingCondition_Condition() {}

// *
// SingleKeyLock - å•å¯†é’¥é”å®šæ¡ä»¶
//
// æœ€åŸºç¡€çš„UTXOé”å®šæ–¹å¼ï¼Œæ”¯æŒä¸¤ç§é”å®šæ¨¡å¼ï¼š
// 1. å…¬é’¥é”å®šï¼ˆP2PKï¼‰ï¼šGenesisã€ä¼ä¸šé¢„åˆ†é…ç­‰æœ‰å…¬é’¥çš„åœºæ™¯
// 2. åœ°å€å“ˆå¸Œé”å®šï¼ˆP2PKHï¼‰ï¼šæ™®é€šè½¬è´¦ï¼Œæ¥æ”¶è€…åªæä¾›åœ°å€
// **åœ¨èµ„æºè®¿é—®æ§åˆ¶ä¸­é€‚ç”¨äºç§æœ‰èµ„æºã€ä¸ªäººä¸“å±èµ„æºç­‰åœºæ™¯ã€‚**
//
// ğŸ”’ é”å®šè¦æ±‚ï¼š
// - å…¬é’¥æ¨¡å¼ï¼šå¿…é¡»æä¾›required_public_keyå¯¹åº”ç§é’¥çš„æœ‰æ•ˆç­¾å
// - åœ°å€å“ˆå¸Œæ¨¡å¼ï¼šå¿…é¡»æä¾›å…¬é’¥+ç­¾åï¼Œä¸”hash(å…¬é’¥) == required_address_hash
// - ç­¾åç®—æ³•å¿…é¡»åŒ¹é…required_algorithm
// - ç­¾åå“ˆå¸Œç±»å‹å¿…é¡»åŒ¹é…sighash_type
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹1 - æ™®é€šè½¬è´¦ï¼ˆåœ°å€å“ˆå¸Œé”å®šï¼‰ï¼š
//
//	single_key_lock {
//	  required_address_hash: RIPEMD160(SHA256(å…¬é’¥))  // é‡‡ç”¨Bitcoiné£æ ¼åœ°å€
//	  required_algorithm: ECDSA_SECP256K1
//	  sighash_type: SIGHASH_ALL
//	}
//
// èŠ±è´¹æ—¶éœ€è¦æä¾›ï¼š
//
//	single_key_proof {
//	  signature: ç”¨æˆ·ç§é’¥ç­¾å
//	  public_key: ç”¨æˆ·å…¬é’¥ï¼ˆç”¨äºéªŒè¯å’Œåœ°å€æ¨å¯¼ï¼‰
//	  algorithm: ECDSA_SECP256K1
//	}
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹2 - ç§æœ‰ResourceUTXOï¼ˆä»…æ‰€æœ‰è€…ä½¿ç”¨ï¼‰ï¼š
// åˆ›å»ºç§æœ‰åˆçº¦ResourceUTXOï¼š
//
//	single_key_lock {
//	  required_address_hash: hash("owner_address_123")
//	  required_algorithm: ECDSA_SECP256K1
//	  sighash_type: SIGHASH_ALL
//	  custom_message: "ç§æœ‰AIæ¨¡å‹ - ä»…æ‰€æœ‰è€…ä½¿ç”¨"  // å¯é€‰çš„èµ„æºè¯´æ˜
//	}
//
// æ‰€æœ‰è€…å¼•ç”¨è‡ªå·±çš„åˆçº¦æ—¶ï¼š
//
//	single_key_proof {
//	  signature: "æ‰€æœ‰è€…ç­¾å"
//	  public_key: "æ‰€æœ‰è€…å…¬é’¥"
//	  algorithm: ECDSA_SECP256K1
//	  custom_message_response: "ç¡®è®¤ç§æœ‰èµ„æºä½¿ç”¨"
//	}
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹3 - Genesisèµ„æºåˆ†é…ï¼ˆå…¬é’¥é”å®šï¼‰ï¼š
//
//	single_key_lock {
//	  required_public_key: é¢„åˆ†é…ç”¨æˆ·å…¬é’¥
//	  required_algorithm: ECDSA_SECP256K1
//	  sighash_type: SIGHASH_ALL
//	}
//
// ğŸ¯ ResourceUTXOåº”ç”¨ä»·å€¼ï¼š
// â€¢ **ç§æœ‰èµ„æº**ï¼šä¸ªäººå¼€å‘çš„AIæ¨¡å‹ã€ç§æœ‰æ•°æ®é›†ã€ä¸ªäººåˆçº¦
// â€¢ **ç®€å•é«˜æ•ˆ**ï¼šæœ€ä½çš„éªŒè¯å¤æ‚åº¦ï¼Œæœ€å¿«çš„è®¿é—®é€Ÿåº¦
// â€¢ **å®‰å…¨å¯é **ï¼šåŸºäºæˆç†Ÿçš„ECDSAå¯†ç å­¦ï¼Œç»è¿‡Bitcoinå¤šå¹´éªŒè¯
// â€¢ **å®Œå…¨æ§åˆ¶**ï¼šåªæœ‰ç§é’¥æŒæœ‰è€…èƒ½å¤Ÿè®¿é—®èµ„æºï¼Œæ— éœ€ä¿¡ä»»ç¬¬ä¸‰æ–¹
// â€¢ **æƒé™ç»§æ‰¿**ï¼šé€šè¿‡ç§é’¥è½¬ç§»å®ç°èµ„æºæ‰€æœ‰æƒè½¬ç§»
type SingleKeyLock struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// é”å®šæ¨¡å¼ï¼šå…¬é’¥é”å®š vs åœ°å€å“ˆå¸Œé”å®š
	//
	// Types that are valid to be assigned to KeyRequirement:
	//
	//	*SingleKeyLock_RequiredPublicKey
	//	*SingleKeyLock_RequiredAddressHash
	KeyRequirement    isSingleKeyLock_KeyRequirement `protobuf_oneof:"key_requirement"`
	RequiredAlgorithm SignatureAlgorithm             `protobuf:"varint,3,opt,name=required_algorithm,json=requiredAlgorithm,proto3,enum=pb.blockchain.core.SignatureAlgorithm" json:"required_algorithm,omitempty"` // è¦æ±‚çš„ç­¾åç®—æ³•
	SighashType       SignatureHashType              `protobuf:"varint,4,opt,name=sighash_type,json=sighashType,proto3,enum=pb.blockchain.core.SignatureHashType" json:"sighash_type,omitempty"`                    // ç­¾åå“ˆå¸Œç±»å‹
	CustomMessage     []byte                         `protobuf:"bytes,5,opt,name=custom_message,json=customMessage,proto3,oneof" json:"custom_message,omitempty"`                                                   // å¯é€‰çš„è‡ªå®šä¹‰æ¶ˆæ¯
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *SingleKeyLock) Reset() {
	*x = SingleKeyLock{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SingleKeyLock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SingleKeyLock) ProtoMessage() {}

func (x *SingleKeyLock) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SingleKeyLock.ProtoReflect.Descriptor instead.
func (*SingleKeyLock) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{10}
}

func (x *SingleKeyLock) GetKeyRequirement() isSingleKeyLock_KeyRequirement {
	if x != nil {
		return x.KeyRequirement
	}
	return nil
}

func (x *SingleKeyLock) GetRequiredPublicKey() *PublicKey {
	if x != nil {
		if x, ok := x.KeyRequirement.(*SingleKeyLock_RequiredPublicKey); ok {
			return x.RequiredPublicKey
		}
	}
	return nil
}

func (x *SingleKeyLock) GetRequiredAddressHash() []byte {
	if x != nil {
		if x, ok := x.KeyRequirement.(*SingleKeyLock_RequiredAddressHash); ok {
			return x.RequiredAddressHash
		}
	}
	return nil
}

func (x *SingleKeyLock) GetRequiredAlgorithm() SignatureAlgorithm {
	if x != nil {
		return x.RequiredAlgorithm
	}
	return SignatureAlgorithm_SIGNATURE_ALGORITHM_UNKNOWN
}

func (x *SingleKeyLock) GetSighashType() SignatureHashType {
	if x != nil {
		return x.SighashType
	}
	return SignatureHashType_SIGHASH_UNKNOWN
}

func (x *SingleKeyLock) GetCustomMessage() []byte {
	if x != nil {
		return x.CustomMessage
	}
	return nil
}

type isSingleKeyLock_KeyRequirement interface {
	isSingleKeyLock_KeyRequirement()
}

type SingleKeyLock_RequiredPublicKey struct {
	RequiredPublicKey *PublicKey `protobuf:"bytes,1,opt,name=required_public_key,json=requiredPublicKey,proto3,oneof"` // å…¬é’¥é”å®šæ¨¡å¼ï¼ˆP2PKï¼‰
}

type SingleKeyLock_RequiredAddressHash struct {
	RequiredAddressHash []byte `protobuf:"bytes,2,opt,name=required_address_hash,json=requiredAddressHash,proto3,oneof"` // åœ°å€å“ˆå¸Œé”å®šæ¨¡å¼ï¼ˆP2PKHï¼‰
}

func (*SingleKeyLock_RequiredPublicKey) isSingleKeyLock_KeyRequirement() {}

func (*SingleKeyLock_RequiredAddressHash) isSingleKeyLock_KeyRequirement() {}

// *
// MultiKeyLock - å¤šé‡ç­¾åé”å®šæ¡ä»¶
//
// M-of-Nå¤šé‡ç­¾åé”å®šï¼Œé€‚ç”¨äºä¼ä¸šæ²»ç†ã€è”åˆé’±åŒ…ã€åŸºé‡‘ç®¡ç†ç­‰åœºæ™¯ã€‚
// **åœ¨èµ„æºè®¿é—®æ§åˆ¶ä¸­ç‰¹åˆ«é€‚ç”¨äºå¤šç”¨æˆ·å…±äº«èµ„æºåœºæ™¯ã€‚**
//
// ğŸ”’ é”å®šè¦æ±‚ï¼š
// - å¿…é¡»æä¾›authorized_keysä¸­è‡³å°‘required_signaturesä¸ªå…¬é’¥çš„æœ‰æ•ˆç­¾å
// - æ¯ä¸ªç­¾åå¿…é¡»å¯¹åº”authorized_keysä¸­çš„ä¸åŒå…¬é’¥ï¼ˆé˜²é‡å¤ï¼‰
// - æ‰€æœ‰ç­¾åå¿…é¡»ä½¿ç”¨ç›¸åŒçš„ç­¾åç®—æ³•
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹1 - ä¼ä¸šå¤šç­¾é’±åŒ…ï¼š
// å…¬å¸åˆ›å»º3-of-5å¤šç­¾é’±åŒ…ï¼š
//
//	multi_key_lock {
//	  required_signatures: 3
//	  authorized_keys: [CEOå…¬é’¥, CFOå…¬é’¥, CTOå…¬é’¥, COOå…¬é’¥, è‘£äº‹é•¿å…¬é’¥]
//	  required_algorithm: ECDSA_SECP256K1
//	  require_ordered_signatures: false  // ç­¾åé¡ºåºæ— å…³
//	}
//
// èŠ±è´¹æ—¶éœ€è¦æä¾›3ä¸ªæœ‰æ•ˆç­¾åï¼š
//
//	multi_key_proof {
//	  signatures: [
//	    {key_index: 0, signature: CEOç­¾å},
//	    {key_index: 2, signature: CTOç­¾å},
//	    {key_index: 4, signature: è‘£äº‹é•¿ç­¾å}
//	  ]
//	}
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹2 - å¤šç”¨æˆ·å…±äº«ResourceUTXOï¼ˆ1-of-Nç™½åå•æ¨¡å¼ï¼‰ï¼š
// åˆ›å»ºå¤šç”¨æˆ·å¯è®¿é—®çš„åˆçº¦ResourceUTXOï¼š
//
//	multi_key_lock {
//	  required_signatures: 1              // åªéœ€è¦1ä¸ªç­¾åå³å¯ä½¿ç”¨
//	  authorized_keys: [
//	    æ‰€æœ‰è€…å…¬é’¥,                        // èµ„æºæ‰€æœ‰è€…
//	    ç”¨æˆ·Aå…¬é’¥,                        // æˆæƒç”¨æˆ·A
//	    ç”¨æˆ·Bå…¬é’¥,                        // æˆæƒç”¨æˆ·B
//	    ç”¨æˆ·Cå…¬é’¥                         // æˆæƒç”¨æˆ·C
//	  ]
//	  required_algorithm: ECDSA_SECP256K1
//	  require_ordered_signatures: false   // ä»»æ„ç”¨æˆ·ç­¾åå³å¯
//	}
//
// ç”¨æˆ·Aå¼•ç”¨åˆçº¦æ—¶ï¼š
//
//	multi_key_proof {
//	  signatures: [
//	    {key_index: 1, signature: ç”¨æˆ·Aç­¾å}  // åªéœ€ç”¨æˆ·Aä¸€ä¸ªç­¾å
//	  ]
//	}
//
// ğŸ¯ ResourceUTXOåº”ç”¨ä»·å€¼ï¼š
// â€¢ **å›¢é˜Ÿåä½œ**ï¼šå¤šä¸ªå¼€å‘è€…å…±äº«ä½¿ç”¨åŒä¸€ä¸ªAIæ¨¡å‹æˆ–åˆçº¦
// â€¢ **ä¼ä¸šæœåŠ¡**ï¼šå…¬å¸å†…å¤šä¸ªéƒ¨é—¨è®¿é—®åŒä¸€ä¸ªæ•°æ®å¤„ç†åˆçº¦
// â€¢ **ç™½åå•æ§åˆ¶**ï¼šç²¾ç¡®æ§åˆ¶å“ªäº›ç”¨æˆ·å¯ä»¥è®¿é—®èµ„æºï¼Œè€Œæ— éœ€å¤æ‚çš„æ™ºèƒ½åˆçº¦é€»è¾‘
// â€¢ **æƒé™å‡çº§**ï¼šæ‰€æœ‰è€…å¯ä»¥é€šè¿‡æƒé™å˜æ›´äº¤æ˜“æ·»åŠ æˆ–ç§»é™¤æˆæƒç”¨æˆ·
type MultiKeyLock struct {
	state                    protoimpl.MessageState `protogen:"open.v1"`
	RequiredSignatures       uint32                 `protobuf:"varint,1,opt,name=required_signatures,json=requiredSignatures,proto3" json:"required_signatures,omitempty"`                                         // éœ€è¦çš„æœ€å°‘ç­¾åæ•°ï¼ˆMï¼‰
	AuthorizedKeys           []*PublicKey           `protobuf:"bytes,2,rep,name=authorized_keys,json=authorizedKeys,proto3" json:"authorized_keys,omitempty"`                                                      // æˆæƒå…¬é’¥åˆ—è¡¨ï¼ˆNä¸ªï¼‰
	RequiredAlgorithm        SignatureAlgorithm     `protobuf:"varint,3,opt,name=required_algorithm,json=requiredAlgorithm,proto3,enum=pb.blockchain.core.SignatureAlgorithm" json:"required_algorithm,omitempty"` // è¦æ±‚çš„ç­¾åç®—æ³•
	RequireOrderedSignatures bool                   `protobuf:"varint,4,opt,name=require_ordered_signatures,json=requireOrderedSignatures,proto3" json:"require_ordered_signatures,omitempty"`                     // æ˜¯å¦è¦æ±‚æŒ‰é¡ºåºç­¾å
	SighashType              SignatureHashType      `protobuf:"varint,5,opt,name=sighash_type,json=sighashType,proto3,enum=pb.blockchain.core.SignatureHashType" json:"sighash_type,omitempty"`                    // ç­¾åå“ˆå¸Œç±»å‹
	GovernancePolicy         *string                `protobuf:"bytes,6,opt,name=governance_policy,json=governancePolicy,proto3,oneof" json:"governance_policy,omitempty"`                                          // å¯é€‰çš„æ²»ç†æ”¿ç­–æè¿°
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *MultiKeyLock) Reset() {
	*x = MultiKeyLock{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiKeyLock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiKeyLock) ProtoMessage() {}

func (x *MultiKeyLock) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiKeyLock.ProtoReflect.Descriptor instead.
func (*MultiKeyLock) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{11}
}

func (x *MultiKeyLock) GetRequiredSignatures() uint32 {
	if x != nil {
		return x.RequiredSignatures
	}
	return 0
}

func (x *MultiKeyLock) GetAuthorizedKeys() []*PublicKey {
	if x != nil {
		return x.AuthorizedKeys
	}
	return nil
}

func (x *MultiKeyLock) GetRequiredAlgorithm() SignatureAlgorithm {
	if x != nil {
		return x.RequiredAlgorithm
	}
	return SignatureAlgorithm_SIGNATURE_ALGORITHM_UNKNOWN
}

func (x *MultiKeyLock) GetRequireOrderedSignatures() bool {
	if x != nil {
		return x.RequireOrderedSignatures
	}
	return false
}

func (x *MultiKeyLock) GetSighashType() SignatureHashType {
	if x != nil {
		return x.SighashType
	}
	return SignatureHashType_SIGHASH_UNKNOWN
}

func (x *MultiKeyLock) GetGovernancePolicy() string {
	if x != nil && x.GovernancePolicy != nil {
		return *x.GovernancePolicy
	}
	return ""
}

// *
// ContractLock - æ™ºèƒ½åˆçº¦é”å®šæ¡ä»¶
//
// é€šè¿‡æ™ºèƒ½åˆçº¦é€»è¾‘æ§åˆ¶UTXOçš„ä½¿ç”¨ï¼Œé€‚ç”¨äºDeFiã€è‡ªåŠ¨åŒ–äº¤æ˜“ç­‰å¯ç¼–ç¨‹åœºæ™¯ã€‚
// **åœ¨èµ„æºè®¿é—®æ§åˆ¶ä¸­ç‰¹åˆ«é€‚ç”¨äºå¤æ‚çš„ä»˜è´¹ä½¿ç”¨ã€åŠ¨æ€æƒé™ç®¡ç†ç­‰åœºæ™¯ã€‚**
//
// ğŸ”’ é”å®šè¦æ±‚ï¼š
// - å¿…é¡»é€šè¿‡æŒ‡å®šåˆçº¦çš„éªŒè¯é€»è¾‘
// - åˆçº¦æ‰§è¡Œç»“æœå¿…é¡»è¿”å›true/success
// - çŠ¶æ€è½¬æ¢å¿…é¡»ç¬¦åˆåˆçº¦å®šä¹‰çš„è§„åˆ™
// - æ‰§è¡Œæ—¶é—´å¿…é¡»åœ¨å…è®¸èŒƒå›´å†…
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹1 - DeFiè‡ªåŠ¨åšå¸‚å•†é”å®šï¼š
//
//	contract_lock {
//	  contract_address: 0x1234...AMMåˆçº¦åœ°å€
//	  required_method: "executeSwap"
//	  parameter_schema: "address,uint256,uint256"  // è¾“å…¥å‚æ•°ç±»å‹
//	  state_requirements: ["liquidity > min_liquidity"]
//	  max_execution_time_ms: 5000
//	}
//
// èŠ±è´¹æ—¶éœ€è¦æä¾›ISPCæ‰§è¡Œè¯æ˜ï¼š
//
//	execution_proof {
//	  execution_result_hash: sha256(æ‰§è¡Œç»“æœ)
//	  state_transition_proof: merkle_proof
//	  execution_time_ms: 3500
//	  context: {æ‰§è¡Œå‚æ•°å’ŒçŠ¶æ€å˜æ›´}
//	}
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹2 - ä»˜è´¹ä½¿ç”¨ResourceUTXOï¼ˆä»»ä½•äººå¯å°è¯•ï¼Œä½†éœ€ä»˜è´¹ï¼‰ï¼š
// é€šè¿‡æ™ºèƒ½åˆçº¦å®ç°å¤æ‚çš„ä»˜è´¹è®¿é—®æ§åˆ¶ï¼š
//
//	contract_lock {
//	  contract_address: "access_control_contract_addr"
//	  required_method: "checkAccess"
//	  parameter_schema: "address,uint256"         // ç”¨æˆ·åœ°å€, æ”¯ä»˜é‡‘é¢
//	  state_requirements: [
//	    "user_balance >= required_fee",           // ç”¨æˆ·ä½™é¢å……è¶³
//	    "resource_quota > 0"                      // èµ„æºé…é¢æœªç”¨å®Œ
//	  ]
//	  max_execution_time_ms: 5000
//	  allowed_callers: []                         // ç©ºæ•°ç»„ = ä»»ä½•äººéƒ½å¯ä»¥å°è¯•
//	  deadline_duration_seconds: 3600             // 1å°æ—¶å†…æœ‰æ•ˆ
//	}
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹3 - ä¼ä¸šçº§ResourceUTXOï¼ˆä»…ç‰¹å®šç”¨æˆ·å¯è®¿é—®ï¼‰ï¼š
// é€šè¿‡åˆçº¦å®ç°å¤æ‚çš„ä¼ä¸šæƒé™æ§åˆ¶ï¼š
//
//	contract_lock {
//	  contract_address: "enterprise_access_contract"
//	  required_method: "verifyEmployeeAccess"
//	  parameter_schema: "address,string"          // ç”¨æˆ·åœ°å€, éƒ¨é—¨ä»£ç 
//	  state_requirements: [
//	    "employee_status == ACTIVE",              // å‘˜å·¥çŠ¶æ€æœ‰æ•ˆ
//	    "department_permission[dept] == true"     // éƒ¨é—¨æœ‰æƒé™
//	  ]
//	  max_execution_time_ms: 3000
//	  allowed_callers: [                          // åªæœ‰è¿™äº›åœ°å€å¯ä»¥å°è¯•
//	    "employee_a_address",
//	    "employee_b_address",
//	    "manager_address"
//	  ]
//	}
//
// ğŸ¯ ResourceUTXOåº”ç”¨ä»·å€¼ï¼š
// â€¢ **ä»˜è´¹æ¨¡å‹**ï¼šAIæ¨¡å‹æŒ‰æ¬¡ä»˜è´¹ã€å­˜å‚¨æŒ‰é‡ä»˜è´¹ç­‰å•†ä¸šæ¨¡å¼
// â€¢ **åŠ¨æ€æƒé™**ï¼šæ ¹æ®ç”¨æˆ·ç­‰çº§ã€æ—¶é—´ã€ä½¿ç”¨é¢‘ç‡ç­‰åŠ¨æ€è°ƒæ•´è®¿é—®æƒé™
// â€¢ **å¤æ‚ä¸šåŠ¡é€»è¾‘**ï¼šç§¯åˆ†ç³»ç»Ÿã€ä¼šå‘˜åˆ¶åº¦ã€ä¼ä¸šçº§æƒé™ç®¡ç†ç­‰
// â€¢ **åˆè§„æ£€æŸ¥**ï¼šè‡ªåŠ¨æ‰§è¡ŒKYCã€åæ´—é’±ç­‰åˆè§„è¦æ±‚
// â€¢ **èµ„æºé…é¢ç®¡ç†**ï¼šé™åˆ¶ç”¨æˆ·ä½¿ç”¨æ¬¡æ•°ã€ä½¿ç”¨æ—¶é•¿ç­‰
type ContractLock struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	ContractAddress    []byte                 `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"`               // åˆçº¦åœ°å€
	RequiredMethod     string                 `protobuf:"bytes,2,opt,name=required_method,json=requiredMethod,proto3" json:"required_method,omitempty"`                  // è¦æ±‚è°ƒç”¨çš„æ–¹æ³•å
	ParameterSchema    string                 `protobuf:"bytes,3,opt,name=parameter_schema,json=parameterSchema,proto3" json:"parameter_schema,omitempty"`               // å‚æ•°ç±»å‹å®šä¹‰ï¼ˆABIæ ¼å¼ï¼‰
	StateRequirements  []string               `protobuf:"bytes,4,rep,name=state_requirements,json=stateRequirements,proto3" json:"state_requirements,omitempty"`         // çŠ¶æ€è¦æ±‚åˆ—è¡¨
	MaxExecutionTimeMs uint64                 `protobuf:"varint,5,opt,name=max_execution_time_ms,json=maxExecutionTimeMs,proto3" json:"max_execution_time_ms,omitempty"` // æœ€å¤§æ‰§è¡Œæ—¶é—´é™åˆ¶ï¼ˆæ¯«ç§’ï¼‰
	ContractStateHash  []byte                 `protobuf:"bytes,6,opt,name=contract_state_hash,json=contractStateHash,proto3" json:"contract_state_hash,omitempty"`       // åˆçº¦çŠ¶æ€å“ˆå¸Œï¼ˆç¡®ä¿ä¸€è‡´æ€§ï¼‰
	ExecutionPolicy    *string                `protobuf:"bytes,7,opt,name=execution_policy,json=executionPolicy,proto3,oneof" json:"execution_policy,omitempty"`         // å¯é€‰çš„æ‰§è¡Œç­–ç•¥
	// å¢å¼ºçš„è´¹ç”¨æ§åˆ¶
	MaxTotalFee uint64 `protobuf:"varint,11,opt,name=max_total_fee,json=maxTotalFee,proto3" json:"max_total_fee,omitempty"` // æœ€å¤§æ€»è´¹ç”¨é™åˆ¶
	// å‚æ•°éªŒè¯å¢å¼º
	ParameterHash           []byte   `protobuf:"bytes,20,opt,name=parameter_hash,json=parameterHash,proto3" json:"parameter_hash,omitempty"`                                        // å‚æ•°å“ˆå¸Œï¼ˆé˜²ç¯¡æ”¹ï¼‰
	AllowedCallers          []string `protobuf:"bytes,21,rep,name=allowed_callers,json=allowedCallers,proto3" json:"allowed_callers,omitempty"`                                     // å…è®¸çš„è°ƒç”¨è€…åœ°å€åˆ—è¡¨
	DeadlineDurationSeconds *uint64  `protobuf:"varint,22,opt,name=deadline_duration_seconds,json=deadlineDurationSeconds,proto3,oneof" json:"deadline_duration_seconds,omitempty"` // è°ƒç”¨æˆªæ­¢æ—¶é—´ï¼ˆç›¸å¯¹ç§’æ•°ï¼Œ0=æ— æœŸé™ï¼‰
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *ContractLock) Reset() {
	*x = ContractLock{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContractLock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContractLock) ProtoMessage() {}

func (x *ContractLock) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContractLock.ProtoReflect.Descriptor instead.
func (*ContractLock) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{12}
}

func (x *ContractLock) GetContractAddress() []byte {
	if x != nil {
		return x.ContractAddress
	}
	return nil
}

func (x *ContractLock) GetRequiredMethod() string {
	if x != nil {
		return x.RequiredMethod
	}
	return ""
}

func (x *ContractLock) GetParameterSchema() string {
	if x != nil {
		return x.ParameterSchema
	}
	return ""
}

func (x *ContractLock) GetStateRequirements() []string {
	if x != nil {
		return x.StateRequirements
	}
	return nil
}

func (x *ContractLock) GetMaxExecutionTimeMs() uint64 {
	if x != nil {
		return x.MaxExecutionTimeMs
	}
	return 0
}

func (x *ContractLock) GetContractStateHash() []byte {
	if x != nil {
		return x.ContractStateHash
	}
	return nil
}

func (x *ContractLock) GetExecutionPolicy() string {
	if x != nil && x.ExecutionPolicy != nil {
		return *x.ExecutionPolicy
	}
	return ""
}

func (x *ContractLock) GetMaxTotalFee() uint64 {
	if x != nil {
		return x.MaxTotalFee
	}
	return 0
}

func (x *ContractLock) GetParameterHash() []byte {
	if x != nil {
		return x.ParameterHash
	}
	return nil
}

func (x *ContractLock) GetAllowedCallers() []string {
	if x != nil {
		return x.AllowedCallers
	}
	return nil
}

func (x *ContractLock) GetDeadlineDurationSeconds() uint64 {
	if x != nil && x.DeadlineDurationSeconds != nil {
		return *x.DeadlineDurationSeconds
	}
	return 0
}

// *
// DelegationLock - å§”æ‰˜æˆæƒé”å®šæ¡ä»¶
//
// å…è®¸UTXOæ‰€æœ‰è€…æˆæƒç¬¬ä¸‰æ–¹ä»£ä¸ºæ“ä½œï¼Œé€‚ç”¨äºæ‰˜ç®¡æœåŠ¡ã€è‡ªåŠ¨åŒ–äº¤æ˜“ã€ä»£ç†æŠ•ç¥¨ç­‰åœºæ™¯ã€‚
// **åœ¨èµ„æºè®¿é—®æ§åˆ¶ä¸­ç‰¹åˆ«é€‚ç”¨äºä¸´æ—¶æˆæƒã€ä»£ç†è®¿é—®ã€æ—¶é™æ§åˆ¶ç­‰åœºæ™¯ã€‚**
//
// ğŸ”’ é”å®šè¦æ±‚ï¼š
// - å¿…é¡»æä¾›æœ‰æ•ˆçš„å§”æ‰˜æˆæƒè¯æ˜
// - å§”æ‰˜å¿…é¡»æœªè¿‡æœŸï¼ˆexpiry_duration_blocksæ£€æŸ¥ï¼‰
// - æ“ä½œç±»å‹å¿…é¡»åœ¨æˆæƒèŒƒå›´å†…
// - è¢«å§”æ‰˜æ–¹å¿…é¡»æä¾›æœ‰æ•ˆç­¾å
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹1 - äº¤æ˜“æ‰€æ‰˜ç®¡ï¼š
// ç”¨æˆ·æˆæƒäº¤æ˜“æ‰€ä»£ä¸ºäº¤æ˜“ï¼š
//
//	delegation_lock {
//	  original_owner: ç”¨æˆ·åœ°å€
//	  allowed_delegates: [äº¤æ˜“æ‰€åœ°å€1, äº¤æ˜“æ‰€åœ°å€2]
//	  authorized_operations: ["transfer", "trade", "stake"]
//	  expiry_duration_blocks: 10000  // 10000ä¸ªåŒºå—åè¿‡æœŸ
//	  max_value_per_operation: 1000 * 10^8   // å•æ¬¡æ“ä½œæœ€å¤§é‡‘é¢ï¼ˆBaseUnitï¼‰
//	                                          // å³ï¼š1000 WES = 100,000,000,000 BaseUnit
//	}
//
// äº¤æ˜“æ‰€èŠ±è´¹æ—¶éœ€è¦æä¾›ï¼š
//
//	delegation_proof {
//	  delegation_transaction_id: åŸå§‹å§”æ‰˜äº¤æ˜“ID
//	  delegate_signature: äº¤æ˜“æ‰€ç­¾å
//	  operation_type: "trade"
//	  value_amount: 500 * 10^8  // 500 WES = 50,000,000,000 BaseUnit
//	}
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹2 - ResourceUTXOä¸´æ—¶æˆæƒï¼š
// æ‰€æœ‰è€…å§”æ‰˜å…¶ä»–ç”¨æˆ·ä¸´æ—¶ä½¿ç”¨èµ„æºï¼š
//
//	delegation_lock {
//	  original_owner: "owner_address_123"
//	  allowed_delegates: [
//	    "delegate_a_address",              // è¢«å§”æ‰˜ç”¨æˆ·A
//	    "delegate_b_address"               // è¢«å§”æ‰˜ç”¨æˆ·B
//	  ]
//	  authorized_operations: [
//	    "reference",                       // å…è®¸å¼•ç”¨èµ„æºï¼ˆè°ƒç”¨åˆçº¦ã€è®¿é—®æ–‡ä»¶ç­‰ï¼‰
//	    "execute",                         // å…è®¸æ‰§è¡Œèµ„æºï¼ˆè¿è¡ŒAIæ¨¡å‹ç­‰ï¼‰
//	    "query"                            // å…è®¸æŸ¥è¯¢èµ„æºçŠ¶æ€
//	  ]
//	  expiry_duration_blocks: 14400        // 24å°æ—¶åè¿‡æœŸï¼ˆå‡è®¾10ç§’ä¸€ä¸ªå—ï¼‰
//	  max_value_per_operation: 1000        // æ¯æ¬¡æ“ä½œæœ€å¤§è´¹ç”¨é™åˆ¶
//	  delegation_policy: "ä¸´æ—¶é¡¹ç›®åä½œæˆæƒ"  // æˆæƒè¯´æ˜
//	}
//
// ç”¨æˆ·Aå¼•ç”¨åˆçº¦æ—¶ï¼š
//
//	delegation_proof {
//	  delegation_transaction_id: "å§”æ‰˜äº¤æ˜“ID"
//	  delegation_output_index: 0
//	  delegate_signature: "ç”¨æˆ·Aç­¾å"
//	  operation_type: "reference"          // å¼•ç”¨æ“ä½œ
//	  value_amount: 50                     // æ‰‹ç»­è´¹ç”¨ï¼ˆBaseUnitï¼Œå³ 0.00000050 WESï¼‰
//	  delegate_address: "delegate_a_address"
//	}
//
// ğŸ¯ ResourceUTXOåº”ç”¨ä»·å€¼ï¼š
// â€¢ **ä¸´æ—¶åä½œ**ï¼šé¡¹ç›®å›¢é˜Ÿæˆå‘˜ä¸´æ—¶è®¿é—®AIæ¨¡å‹ã€æ•°æ®é›†ç­‰èµ„æº
// â€¢ **ä»£ç†æœåŠ¡**ï¼šç¬¬ä¸‰æ–¹æœåŠ¡ä»£ç†ç”¨æˆ·æ‰§è¡Œèµ„æºæ“ä½œï¼ˆå¦‚è‡ªåŠ¨åŒ–äº¤æ˜“æœºå™¨äººï¼‰
// â€¢ **æƒé™ç§Ÿå€Ÿ**ï¼šå°†èµ„æºä½¿ç”¨æƒä¸´æ—¶ç§Ÿå€Ÿç»™å…¶ä»–ç”¨æˆ·ï¼Œåˆ°æœŸè‡ªåŠ¨æ”¶å›
// â€¢ **ä¼ä¸šç®¡ç†**ï¼šå‘˜å·¥ç¦»èŒæ—¶è‡ªåŠ¨æ’¤é”€èµ„æºè®¿é—®æƒï¼Œæ— éœ€æ‰‹åŠ¨æ“ä½œ
// â€¢ **å®‰å…¨æ§åˆ¶**ï¼šé™åˆ¶æ¯æ¬¡æ“ä½œçš„æœ€å¤§ä»·å€¼ï¼Œé˜²æ­¢å§”æ‰˜è¢«æ»¥ç”¨
//
// ğŸ“‹ authorized_operationsæ ‡å‡†å€¼ï¼ˆResourceUTXOä¸“ç”¨ï¼‰ï¼š
// â€¢ "reference" - å¼•ç”¨èµ„æºï¼ˆis_reference_only=trueï¼‰
// â€¢ "execute" - æ‰§è¡Œèµ„æºï¼ˆç‰¹å®šäºå¯æ‰§è¡Œèµ„æºï¼‰
// â€¢ "query" - æŸ¥è¯¢èµ„æºçŠ¶æ€å’Œå…ƒä¿¡æ¯
// â€¢ "consume" - æ¶ˆè´¹èµ„æºï¼ˆis_reference_only=falseï¼Œç”¨äºæƒé™å˜æ›´ç­‰ï¼‰
// â€¢ "transfer" - è½¬ç§»æ‰€æœ‰æƒï¼ˆä»…ç”¨äºAssetUTXOï¼‰
// â€¢ "stake" - è´¨æŠ¼æ“ä½œï¼ˆä»…ç”¨äºAssetUTXOï¼‰
// â€¢ "vote" - æŠ•ç¥¨æ“ä½œï¼ˆæ²»ç†ç±»åœºæ™¯ï¼‰
type DelegationLock struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	OriginalOwner        []byte                 `protobuf:"bytes,1,opt,name=original_owner,json=originalOwner,proto3" json:"original_owner,omitempty"`                               // åŸå§‹æ‰€æœ‰è€…åœ°å€
	AllowedDelegates     [][]byte               `protobuf:"bytes,2,rep,name=allowed_delegates,json=allowedDelegates,proto3" json:"allowed_delegates,omitempty"`                      // å…è®¸çš„è¢«å§”æ‰˜è€…åˆ—è¡¨
	AuthorizedOperations []string               `protobuf:"bytes,3,rep,name=authorized_operations,json=authorizedOperations,proto3" json:"authorized_operations,omitempty"`          // æˆæƒçš„æ“ä½œç±»å‹
	ExpiryDurationBlocks *uint64                `protobuf:"varint,4,opt,name=expiry_duration_blocks,json=expiryDurationBlocks,proto3,oneof" json:"expiry_duration_blocks,omitempty"` // å§”æ‰˜æœ‰æ•ˆæœŸï¼ˆç›¸å¯¹åŒºå—æ•°ï¼Œ0=æ°¸ä¸è¿‡æœŸï¼‰
	MaxValuePerOperation uint64                 `protobuf:"varint,5,opt,name=max_value_per_operation,json=maxValuePerOperation,proto3" json:"max_value_per_operation,omitempty"`     // å•æ¬¡æ“ä½œæœ€å¤§ä»·å€¼
	DelegationPolicy     []byte                 `protobuf:"bytes,6,opt,name=delegation_policy,json=delegationPolicy,proto3,oneof" json:"delegation_policy,omitempty"`                // å¯é€‰çš„å§”æ‰˜ç­–ç•¥
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *DelegationLock) Reset() {
	*x = DelegationLock{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DelegationLock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DelegationLock) ProtoMessage() {}

func (x *DelegationLock) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DelegationLock.ProtoReflect.Descriptor instead.
func (*DelegationLock) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{13}
}

func (x *DelegationLock) GetOriginalOwner() []byte {
	if x != nil {
		return x.OriginalOwner
	}
	return nil
}

func (x *DelegationLock) GetAllowedDelegates() [][]byte {
	if x != nil {
		return x.AllowedDelegates
	}
	return nil
}

func (x *DelegationLock) GetAuthorizedOperations() []string {
	if x != nil {
		return x.AuthorizedOperations
	}
	return nil
}

func (x *DelegationLock) GetExpiryDurationBlocks() uint64 {
	if x != nil && x.ExpiryDurationBlocks != nil {
		return *x.ExpiryDurationBlocks
	}
	return 0
}

func (x *DelegationLock) GetMaxValuePerOperation() uint64 {
	if x != nil {
		return x.MaxValuePerOperation
	}
	return 0
}

func (x *DelegationLock) GetDelegationPolicy() []byte {
	if x != nil {
		return x.DelegationPolicy
	}
	return nil
}

// *
// ThresholdLock - é—¨é™ç­¾åé”å®šæ¡ä»¶
//
// ä½¿ç”¨é—¨é™å¯†ç å­¦çš„é«˜çº§å¤šç­¾æ–¹æ¡ˆï¼Œé€‚ç”¨äºé“¶è¡Œçº§å®‰å…¨ã€å¤§é¢èµ„äº§ç®¡ç†ç­‰åœºæ™¯ã€‚
//
// ğŸ”’ é”å®šè¦æ±‚ï¼š
// - å¿…é¡»æä¾›è‡³å°‘thresholdä¸ªæœ‰æ•ˆçš„é—¨é™ç­¾åä»½é¢
// - æ¯ä¸ªä»½é¢å¿…é¡»å¯¹åº”ä¸åŒçš„å‚ä¸æ–¹
// - ç»„åˆç­¾åå¿…é¡»èƒ½å¤ŸéªŒè¯é€šè¿‡
// - å‚ä¸æ–¹å¿…é¡»åœ¨é¢„å®šä¹‰çš„é›†åˆä¸­
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹ï¼š
// å¤®è¡Œæ•°å­—è´§å¸å‘è¡Œï¼ˆ5-of-7é—¨é™ï¼‰ï¼š
//
//	threshold_lock {
//	  threshold: 5
//	  total_parties: 7
//	  party_verification_keys: [è¡Œé•¿key, å‰¯è¡Œé•¿key, ç›‘ç®¡key, æŠ€æœ¯key, é£æ§key, å®¡è®¡key, è‘£äº‹key]
//	  signature_scheme: "BLS_THRESHOLD"
//	  security_level: 256  // å®‰å…¨ä½æ•°
//	}
//
// å‘è¡Œæ—¶éœ€è¦æä¾›5ä¸ªä»½é¢ï¼š
//
//	threshold_proof {
//	  shares: [
//	    {party_id: 1, signature_share: è¡Œé•¿ä»½é¢},
//	    {party_id: 3, signature_share: ç›‘ç®¡ä»½é¢},
//	    {party_id: 4, signature_share: æŠ€æœ¯ä»½é¢},
//	    {party_id: 5, signature_share: é£æ§ä»½é¢},
//	    {party_id: 7, signature_share: è‘£äº‹ä»½é¢}
//	  ]
//	  combined_signature: ç»„åˆåçš„ç­¾å
//	}
type ThresholdLock struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	Threshold             uint32                 `protobuf:"varint,1,opt,name=threshold,proto3" json:"threshold,omitempty"`                                                       // é—¨é™å€¼ï¼ˆéœ€è¦çš„æœ€å°‘ä»½é¢æ•°ï¼‰
	TotalParties          uint32                 `protobuf:"varint,2,opt,name=total_parties,json=totalParties,proto3" json:"total_parties,omitempty"`                             // æ€»å‚ä¸æ–¹æ•°é‡
	PartyVerificationKeys [][]byte               `protobuf:"bytes,3,rep,name=party_verification_keys,json=partyVerificationKeys,proto3" json:"party_verification_keys,omitempty"` // å‚ä¸æ–¹éªŒè¯å¯†é’¥åˆ—è¡¨
	SignatureScheme       string                 `protobuf:"bytes,4,opt,name=signature_scheme,json=signatureScheme,proto3" json:"signature_scheme,omitempty"`                     // é—¨é™ç­¾åæ–¹æ¡ˆï¼ˆBLS_THRESHOLDç­‰ï¼‰
	SecurityLevel         uint32                 `protobuf:"varint,5,opt,name=security_level,json=securityLevel,proto3" json:"security_level,omitempty"`                          // å®‰å…¨çº§åˆ«ï¼ˆä½æ•°ï¼‰
	ThresholdPolicy       []byte                 `protobuf:"bytes,6,opt,name=threshold_policy,json=thresholdPolicy,proto3,oneof" json:"threshold_policy,omitempty"`               // å¯é€‰çš„é—¨é™ç­–ç•¥
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *ThresholdLock) Reset() {
	*x = ThresholdLock{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ThresholdLock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThresholdLock) ProtoMessage() {}

func (x *ThresholdLock) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThresholdLock.ProtoReflect.Descriptor instead.
func (*ThresholdLock) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{14}
}

func (x *ThresholdLock) GetThreshold() uint32 {
	if x != nil {
		return x.Threshold
	}
	return 0
}

func (x *ThresholdLock) GetTotalParties() uint32 {
	if x != nil {
		return x.TotalParties
	}
	return 0
}

func (x *ThresholdLock) GetPartyVerificationKeys() [][]byte {
	if x != nil {
		return x.PartyVerificationKeys
	}
	return nil
}

func (x *ThresholdLock) GetSignatureScheme() string {
	if x != nil {
		return x.SignatureScheme
	}
	return ""
}

func (x *ThresholdLock) GetSecurityLevel() uint32 {
	if x != nil {
		return x.SecurityLevel
	}
	return 0
}

func (x *ThresholdLock) GetThresholdPolicy() []byte {
	if x != nil {
		return x.ThresholdPolicy
	}
	return nil
}

// *
// TimeLock - æ—¶é—´é”å®šæ¡ä»¶
//
// åªæœ‰åœ¨æŒ‡å®šæ—¶é—´åæ‰èƒ½è§£é”çš„UTXOï¼Œé€‚ç”¨äºå®šæœŸå­˜æ¬¾ã€é—å˜±æ‰§è¡Œã€æœŸæƒè¡Œæƒç­‰åœºæ™¯ã€‚
//
// ğŸ”’ é”å®šè¦æ±‚ï¼š
// - å½“å‰æ—¶é—´æˆ³å¿…é¡» >= unlock_timestamp
// - å¿…é¡»åŒæ—¶æ»¡è¶³base_lockçš„æ‰€æœ‰è¦æ±‚
// - æ—¶é—´è¯æ˜å¿…é¡»å¯éªŒè¯ï¼ˆåŒºå—æ—¶é—´æˆ³æˆ–å¯ä¿¡æ—¶é—´æºï¼‰
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹ï¼š
// ä¸€å¹´æœŸå®šæœŸå­˜æ¬¾ï¼ˆ2025å¹´1æœˆ1æ—¥åˆ°æœŸï¼‰ï¼š
//
//	time_lock {
//	  unlock_timestamp: 1735689600  // 2025-11-01 00:00:00 UTC
//	  base_lock {
//	    single_key_lock {
//	      required_public_key: å­˜æ¬¾äººå…¬é’¥
//	      required_algorithm: ECDSA_SECP256K1
//	    }
//	  }
//	  time_source: TIME_SOURCE_BLOCK_TIMESTAMP
//	}
//
// åˆ°æœŸåèŠ±è´¹éœ€è¦æä¾›ï¼š
//
//	time_proof {
//	  current_timestamp: 1735689600+
//	  timestamp_proof: åŒºå—å¤´è¯æ˜
//	  base_proof: {å­˜æ¬¾äººç­¾åè¯æ˜}
//	}
type TimeLock struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	UnlockTimestamp uint64                 `protobuf:"varint,1,opt,name=unlock_timestamp,json=unlockTimestamp,proto3" json:"unlock_timestamp,omitempty"`                              // UTXOè§£é”æ—¶é—´æˆ³
	BaseLock        *LockingCondition      `protobuf:"bytes,2,opt,name=base_lock,json=baseLock,proto3" json:"base_lock,omitempty"`                                                    // åŸºç¡€é”å®šæ¡ä»¶ï¼ˆå¿…éœ€ï¼‰
	TimeSource      TimeLock_TimeSource    `protobuf:"varint,3,opt,name=time_source,json=timeSource,proto3,enum=pb.blockchain.core.TimeLock_TimeSource" json:"time_source,omitempty"` // æ—¶é—´æ¥æºé…ç½®
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TimeLock) Reset() {
	*x = TimeLock{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimeLock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeLock) ProtoMessage() {}

func (x *TimeLock) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimeLock.ProtoReflect.Descriptor instead.
func (*TimeLock) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{15}
}

func (x *TimeLock) GetUnlockTimestamp() uint64 {
	if x != nil {
		return x.UnlockTimestamp
	}
	return 0
}

func (x *TimeLock) GetBaseLock() *LockingCondition {
	if x != nil {
		return x.BaseLock
	}
	return nil
}

func (x *TimeLock) GetTimeSource() TimeLock_TimeSource {
	if x != nil {
		return x.TimeSource
	}
	return TimeLock_TIME_SOURCE_BLOCK_TIMESTAMP
}

// *
// HeightLock - åŒºå—é«˜åº¦é”å®šæ¡ä»¶
//
// åªæœ‰åœ¨æŒ‡å®šåŒºå—é«˜åº¦åæ‰èƒ½è§£é”çš„UTXOï¼Œé€‚ç”¨äºé”ä»“æ¿€åŠ±ã€åˆ†é˜¶æ®µé‡Šæ”¾ã€æŒ–çŸ¿å¥–åŠ±ç­‰åœºæ™¯ã€‚
//
// ğŸ”’ é”å®šè¦æ±‚ï¼š
// - å½“å‰åŒºå—é«˜åº¦å¿…é¡» >= unlock_height
// - å¿…é¡»åŒæ—¶æ»¡è¶³base_lockçš„æ‰€æœ‰è¦æ±‚
// - å¿…é¡»è¾¾åˆ°è¦æ±‚çš„ç¡®è®¤åŒºå—æ•°
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹ï¼š
// å‘˜å·¥è‚¡æƒé”ä»“ï¼ˆé”å®š1000ä¸ªåŒºå—ï¼‰ï¼š
//
//	height_lock {
//	  unlock_height: å½“å‰é«˜åº¦ + 1000
//	  base_lock {
//	    single_key_lock {
//	      required_public_key: å‘˜å·¥å…¬é’¥
//	      required_algorithm: ECDSA_SECP256K1
//	    }
//	  }
//	  confirmation_blocks: 6  // éœ€è¦6ä¸ªç¡®è®¤
//	}
//
// è§£é”æ—¶èŠ±è´¹éœ€è¦æä¾›ï¼š
//
//	height_proof {
//	  current_height: è§£é”é«˜åº¦+
//	  block_header_proof: å½“å‰åŒºå—å¤´è¯æ˜
//	  base_proof: {å‘˜å·¥ç­¾åè¯æ˜}
//	  confirmation_blocks: 6
//	}
type HeightLock struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	UnlockHeight       uint64                 `protobuf:"varint,1,opt,name=unlock_height,json=unlockHeight,proto3" json:"unlock_height,omitempty"`                   // è§£é”åŒºå—é«˜åº¦
	BaseLock           *LockingCondition      `protobuf:"bytes,2,opt,name=base_lock,json=baseLock,proto3" json:"base_lock,omitempty"`                                // åŸºç¡€é”å®šæ¡ä»¶
	ConfirmationBlocks uint32                 `protobuf:"varint,3,opt,name=confirmation_blocks,json=confirmationBlocks,proto3" json:"confirmation_blocks,omitempty"` // éœ€è¦çš„ç¡®è®¤åŒºå—æ•°
	GraceBlocks        *uint64                `protobuf:"varint,4,opt,name=grace_blocks,json=graceBlocks,proto3,oneof" json:"grace_blocks,omitempty"`                // å¯é€‰çš„å®½é™åŒºå—æ•°
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *HeightLock) Reset() {
	*x = HeightLock{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeightLock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeightLock) ProtoMessage() {}

func (x *HeightLock) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeightLock.ProtoReflect.Descriptor instead.
func (*HeightLock) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{16}
}

func (x *HeightLock) GetUnlockHeight() uint64 {
	if x != nil {
		return x.UnlockHeight
	}
	return 0
}

func (x *HeightLock) GetBaseLock() *LockingCondition {
	if x != nil {
		return x.BaseLock
	}
	return nil
}

func (x *HeightLock) GetConfirmationBlocks() uint32 {
	if x != nil {
		return x.ConfirmationBlocks
	}
	return 0
}

func (x *HeightLock) GetGraceBlocks() uint64 {
	if x != nil && x.GraceBlocks != nil {
		return *x.GraceBlocks
	}
	return 0
}

// *
// SingleKeyProof - å•å¯†é’¥è§£é”è¯æ˜
//
// å¯¹åº”SingleKeyLockçš„è§£é”è¯æ˜ï¼Œæ”¯æŒP2PKå’ŒP2PKHä¸¤ç§éªŒè¯æ¨¡å¼ã€‚
//
// ğŸ”‘ è¯æ˜å†…å®¹ï¼š
// - signature: ä½¿ç”¨private_keyå¯¹äº¤æ˜“æ•°æ®çš„ç­¾å
// - public_key: å¯¹åº”å…¬é’¥ï¼ˆç”¨äºéªŒè¯å’Œåœ°å€æ¨å¯¼ï¼‰
// - algorithm: ç­¾åç®—æ³•ï¼ˆå¿…é¡»åŒ¹é…lock.required_algorithmï¼‰
// - sighash_type: ç­¾åå“ˆå¸Œç±»å‹ï¼ˆå¿…é¡»åŒ¹é…lock.sighash_typeï¼‰
//
// ğŸ“ éªŒè¯ç¤ºä¾‹ï¼š
//
// P2PKæ¨¡å¼éªŒè¯ï¼ˆå…¬é’¥é”å®šï¼‰ï¼š
// 1. éªŒè¯public_key == lock.required_public_key
// 2. éªŒè¯algorithm == lock.required_algorithm
// 3. éªŒè¯sighash_type == lock.sighash_type
// 4. ä½¿ç”¨public_keyéªŒè¯signatureå¯¹äº¤æ˜“å“ˆå¸Œçš„æœ‰æ•ˆæ€§
//
// P2PKHæ¨¡å¼éªŒè¯ï¼ˆåœ°å€å“ˆå¸Œé”å®šï¼‰ï¼š
// 1. è®¡ç®—address_hash = RIPEMD160(SHA256(public_key))
// 2. éªŒè¯address_hash == lock.required_address_hash
// 3. éªŒè¯algorithm == lock.required_algorithm
// 4. éªŒè¯sighash_type == lock.sighash_type
// 5. ä½¿ç”¨public_keyéªŒè¯signatureå¯¹äº¤æ˜“å“ˆå¸Œçš„æœ‰æ•ˆæ€§
//
// å¦‚æœæœ‰custom_messageï¼ŒéªŒè¯custom_message_response
type SingleKeyProof struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	Signature             *SignatureData         `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`                                                                   // æ•°å­—ç­¾å
	PublicKey             *PublicKey             `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`                                                  // å¯¹åº”å…¬é’¥
	Algorithm             SignatureAlgorithm     `protobuf:"varint,3,opt,name=algorithm,proto3,enum=pb.blockchain.core.SignatureAlgorithm" json:"algorithm,omitempty"`                       // ç­¾åç®—æ³•
	SighashType           SignatureHashType      `protobuf:"varint,4,opt,name=sighash_type,json=sighashType,proto3,enum=pb.blockchain.core.SignatureHashType" json:"sighash_type,omitempty"` // ç­¾åå“ˆå¸Œç±»å‹
	CustomMessageResponse []byte                 `protobuf:"bytes,5,opt,name=custom_message_response,json=customMessageResponse,proto3,oneof" json:"custom_message_response,omitempty"`      // å¯é€‰çš„è‡ªå®šä¹‰æ¶ˆæ¯å“åº”
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *SingleKeyProof) Reset() {
	*x = SingleKeyProof{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SingleKeyProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SingleKeyProof) ProtoMessage() {}

func (x *SingleKeyProof) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SingleKeyProof.ProtoReflect.Descriptor instead.
func (*SingleKeyProof) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{17}
}

func (x *SingleKeyProof) GetSignature() *SignatureData {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SingleKeyProof) GetPublicKey() *PublicKey {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *SingleKeyProof) GetAlgorithm() SignatureAlgorithm {
	if x != nil {
		return x.Algorithm
	}
	return SignatureAlgorithm_SIGNATURE_ALGORITHM_UNKNOWN
}

func (x *SingleKeyProof) GetSighashType() SignatureHashType {
	if x != nil {
		return x.SighashType
	}
	return SignatureHashType_SIGHASH_UNKNOWN
}

func (x *SingleKeyProof) GetCustomMessageResponse() []byte {
	if x != nil {
		return x.CustomMessageResponse
	}
	return nil
}

// *
// MultiKeyProof - å¤šé‡ç­¾åè§£é”è¯æ˜
//
// å¯¹åº”MultiKeyLockçš„è§£é”è¯æ˜ï¼Œæä¾›M-of-Nå¤šé‡ç­¾åã€‚
//
// ğŸ”‘ è¯æ˜å†…å®¹ï¼š
// - signatures: ç­¾ååˆ—è¡¨ï¼Œæ¯ä¸ªåŒ…å«key_indexå’Œå¯¹åº”ç­¾å
// - ç­¾åæ•°é‡å¿…é¡» >= lock.required_signatures
// - æ¯ä¸ªkey_indexå¿…é¡»æŒ‡å‘lock.authorized_keysä¸­çš„æœ‰æ•ˆå…¬é’¥
// - ä¸å…è®¸é‡å¤ä½¿ç”¨ç›¸åŒçš„key_index
//
// ğŸ“ éªŒè¯ç¤ºä¾‹ï¼š
// 1. éªŒè¯signatures.length >= lock.required_signatures
// 2. éªŒè¯æ¯ä¸ªsignature.key_indexåœ¨æœ‰æ•ˆèŒƒå›´å†…ä¸”ä¸é‡å¤
// 3. é€ä¸ªéªŒè¯ç­¾åå¯¹åº”æ­£ç¡®çš„å…¬é’¥
// 4. éªŒè¯æ‰€æœ‰ç­¾åç®—æ³•ä¸€è‡´ä¸”ç¬¦åˆlock.required_algorithm
type MultiKeyProof struct {
	state         protoimpl.MessageState          `protogen:"open.v1"`
	Signatures    []*MultiKeyProof_SignatureEntry `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"` // ç­¾åæ¡ç›®åˆ—è¡¨
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiKeyProof) Reset() {
	*x = MultiKeyProof{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiKeyProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiKeyProof) ProtoMessage() {}

func (x *MultiKeyProof) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiKeyProof.ProtoReflect.Descriptor instead.
func (*MultiKeyProof) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{18}
}

func (x *MultiKeyProof) GetSignatures() []*MultiKeyProof_SignatureEntry {
	if x != nil {
		return x.Signatures
	}
	return nil
}

// *
// ExecutionProof - ISPCæ‰§è¡Œè¯æ˜ï¼ˆé€šç”¨è®¾è®¡ï¼‰
//
// ğŸ¯ **æ ¸å¿ƒå®šä½**ï¼š
// - ExecutionProof æ˜¯ Transaction çš„ä¸€éƒ¨åˆ†ï¼ˆUnlockingProof ä¸­çš„ä¸€ä¸ªé€‰é¡¹ï¼‰
// - ExecutionProof ä¸èƒ½è„±ç¦» Transaction ç‹¬ç«‹å­˜åœ¨
// - ExecutionProof çš„ç›®çš„æ˜¯è¯æ˜ ISPC æ‰§è¡Œçš„æ­£ç¡®æ€§ï¼Œç”¨äºè§£é” ContractLock
// - ExecutionProof åªå…³æ³¨æ‰§è¡Œå±‚é¢çš„ä¿¡æ¯ï¼ˆè°æ‰§è¡Œã€æ‰§è¡Œä»€ä¹ˆã€æ‰§è¡Œç»“æœï¼‰
// - Transaction çº§åˆ«çš„ä¿¡æ¯ï¼ˆvalueã€transaction_hashã€timestampã€nonceï¼‰éƒ½åº”è¯¥ä» Transaction æœ¬èº«è·å–
//
// ğŸ”‘ **è¯æ˜å†…å®¹**ï¼š
// - execution_result_hash: æ‰§è¡Œç»“æœå“ˆå¸Œï¼ˆé€šç”¨ï¼‰
// - state_transition_proof: çŠ¶æ€è½¬æ¢çš„é»˜å…‹å°”è¯æ˜ï¼ˆé€šç”¨ï¼‰
// - execution_time_ms: å®é™…æ‰§è¡Œæ—¶é—´ï¼ˆå¿…é¡» <= lock.max_execution_time_msï¼‰
// - context: æ‰§è¡Œä¸Šä¸‹æ–‡ï¼ˆé€šç”¨ï¼ŒåŒ…å«èº«ä»½è¯æ˜ï¼‰
//
// ğŸ›¡ï¸ **éšç§ä¿æŠ¤è®¾è®¡**ï¼š
// - input_data_hash: è¾“å…¥æ•°æ®å“ˆå¸Œï¼ˆ32å­—èŠ‚SHA-256ï¼‰ï¼ŒåŸå§‹æ•°æ®ä¸åœ¨é“¾ä¸Š
// - output_data_hash: è¾“å‡ºæ•°æ®å“ˆå¸Œï¼ˆ32å­—èŠ‚SHA-256ï¼‰ï¼ŒåŸå§‹æ•°æ®ä¸åœ¨é“¾ä¸Š
// - metadata["contract_state_before_hash"]: æ‰§è¡Œå‰çŠ¶æ€å“ˆå¸Œï¼ˆ32å­—èŠ‚SHA-256ï¼‰
// - metadata["contract_state_after_hash"]: æ‰§è¡ŒåçŠ¶æ€å“ˆå¸Œï¼ˆ32å­—èŠ‚SHA-256ï¼‰
// - åŸå§‹æ•°æ®å­˜å‚¨åœ¨é“¾ä¸‹æˆ–åŠ å¯†å­˜å‚¨ï¼Œç”¨æˆ·æ§åˆ¶è®¿é—®
// - é€šè¿‡å“ˆå¸ŒéªŒè¯æ•°æ®å®Œæ•´æ€§ï¼ŒZKè¯æ˜éªŒè¯æ‰§è¡Œæ­£ç¡®æ€§
//
// ğŸ“ **éªŒè¯ç¤ºä¾‹**ï¼š
// 1. éªŒè¯resource_address == lock.contract_address
// 2. éªŒè¯execution_time_ms <= lock.max_execution_time_ms
// 3. éªŒè¯execution_result_hashä¸æä¾›çš„ç»“æœè¯æ˜ä¸€è‡´ï¼ˆæ— éœ€åœ¨å…±è¯†è·¯å¾„é‡æ‰§è¡Œï¼‰
// 4. éªŒè¯çŠ¶æ€è½¬æ¢ç¬¦åˆlock.state_requirementsï¼ˆé€šè¿‡çŠ¶æ€å“ˆå¸ŒéªŒè¯ï¼‰
// 5. éªŒè¯å‚æ•°ç¬¦åˆlock.parameter_schemaå®šä¹‰ï¼ˆé€šè¿‡è¾“å…¥å“ˆå¸ŒéªŒè¯ï¼‰
// 6. éªŒè¯æ•°æ®å®Œæ•´æ€§ï¼šé€šè¿‡å“ˆå¸ŒéªŒè¯è¾“å…¥/è¾“å‡ºæ•°æ®æœªè¢«ç¯¡æ”¹
// 7. éªŒè¯caller_identityï¼šé€šè¿‡ç­¾åè¯æ˜caller_addressçš„çœŸå®æ€§ï¼ˆå¯†ç å­¦ä¿è¯ï¼‰
//
// âš ï¸ **è¾¹ç•ŒåŸåˆ™**ï¼š
// - ExecutionProof åªå…³æ³¨æ‰§è¡Œå±‚é¢çš„ä¿¡æ¯ï¼ˆè°æ‰§è¡Œã€æ‰§è¡Œä»€ä¹ˆã€æ‰§è¡Œç»“æœï¼‰
// - Transaction çº§åˆ«çš„ä¿¡æ¯ï¼ˆvalueã€transaction_hashã€timestampã€nonceï¼‰éƒ½åº”è¯¥ä» Transaction æœ¬èº«è·å–
// - IdentityProof.timestampï¼šç”¨äº IdentityProof çš„æ—¶æ•ˆæ€§éªŒè¯ï¼ˆç‹¬ç«‹äº TX timestampï¼‰
type ExecutionProof struct {
	state                protoimpl.MessageState           `protogen:"open.v1"`
	ExecutionResultHash  []byte                           `protobuf:"bytes,1,opt,name=execution_result_hash,json=executionResultHash,proto3" json:"execution_result_hash,omitempty"`    // æ‰§è¡Œç»“æœå“ˆå¸Œï¼ˆ32å­—èŠ‚SHA-256ï¼‰
	StateTransitionProof []byte                           `protobuf:"bytes,2,opt,name=state_transition_proof,json=stateTransitionProof,proto3" json:"state_transition_proof,omitempty"` // çŠ¶æ€è½¬æ¢è¯æ˜ï¼ˆMerkleè¯æ˜ï¼‰
	ExecutionTimeMs      uint64                           `protobuf:"varint,3,opt,name=execution_time_ms,json=executionTimeMs,proto3" json:"execution_time_ms,omitempty"`               // å®é™…æ‰§è¡Œæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
	Context              *ExecutionProof_ExecutionContext `protobuf:"bytes,4,opt,name=context,proto3" json:"context,omitempty"`                                                         // æ‰§è¡Œä¸Šä¸‹æ–‡ï¼ˆé€šç”¨ï¼‰
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *ExecutionProof) Reset() {
	*x = ExecutionProof{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecutionProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecutionProof) ProtoMessage() {}

func (x *ExecutionProof) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecutionProof.ProtoReflect.Descriptor instead.
func (*ExecutionProof) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{19}
}

func (x *ExecutionProof) GetExecutionResultHash() []byte {
	if x != nil {
		return x.ExecutionResultHash
	}
	return nil
}

func (x *ExecutionProof) GetStateTransitionProof() []byte {
	if x != nil {
		return x.StateTransitionProof
	}
	return nil
}

func (x *ExecutionProof) GetExecutionTimeMs() uint64 {
	if x != nil {
		return x.ExecutionTimeMs
	}
	return 0
}

func (x *ExecutionProof) GetContext() *ExecutionProof_ExecutionContext {
	if x != nil {
		return x.Context
	}
	return nil
}

// *
// DelegationProof - å§”æ‰˜æˆæƒè§£é”è¯æ˜
//
// å¯¹åº”DelegationLockçš„è§£é”è¯æ˜ï¼Œæä¾›æœ‰æ•ˆçš„å§”æ‰˜æˆæƒã€‚
//
// ğŸ”‘ è¯æ˜å†…å®¹ï¼š
// - delegation_transaction_id: åŸå§‹å§”æ‰˜äº¤æ˜“çš„ID
// - delegate_signature: è¢«å§”æ‰˜æ–¹çš„ç­¾å
// - operation_type: å½“å‰æ“ä½œç±»å‹ï¼ˆå¿…é¡»åœ¨æˆæƒèŒƒå›´å†…ï¼‰
// - value_amount: æ“ä½œé‡‘é¢ï¼ˆå¿…é¡» <= lock.max_value_per_operationï¼‰
// - execution_time_ms: å®é™…æ‰§è¡Œæ—¶é—´ï¼ˆå¿…é¡» <= lock.max_execution_time_msï¼‰
//
// ğŸ“ éªŒè¯ç¤ºä¾‹ï¼š
// 1. éªŒè¯å§”æ‰˜äº¤æ˜“å­˜åœ¨ä¸”æœ‰æ•ˆ
// 2. éªŒè¯å½“å‰é«˜åº¦ <= lock.expiry_duration_blocksï¼ˆå§”æ‰˜æœªè¿‡æœŸï¼‰
// 3. éªŒè¯operation_typeåœ¨lock.authorized_operationsä¸­
// 4. éªŒè¯value_amount <= lock.max_value_per_operation
// 5. éªŒè¯delegate_signatureæœ‰æ•ˆä¸”æ¥è‡ªæˆæƒçš„è¢«å§”æ‰˜æ–¹
type DelegationProof struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	DelegationTransactionId []byte                 `protobuf:"bytes,1,opt,name=delegation_transaction_id,json=delegationTransactionId,proto3" json:"delegation_transaction_id,omitempty"` // å§”æ‰˜äº¤æ˜“ID
	DelegationOutputIndex   uint32                 `protobuf:"varint,2,opt,name=delegation_output_index,json=delegationOutputIndex,proto3" json:"delegation_output_index,omitempty"`      // å§”æ‰˜è¾“å‡ºç´¢å¼•
	DelegateSignature       *SignatureData         `protobuf:"bytes,3,opt,name=delegate_signature,json=delegateSignature,proto3" json:"delegate_signature,omitempty"`                     // è¢«å§”æ‰˜æ–¹ç­¾å
	OperationType           string                 `protobuf:"bytes,4,opt,name=operation_type,json=operationType,proto3" json:"operation_type,omitempty"`                                 // æ“ä½œç±»å‹
	ValueAmount             uint64                 `protobuf:"varint,5,opt,name=value_amount,json=valueAmount,proto3" json:"value_amount,omitempty"`                                      // æ“ä½œé‡‘é¢ï¼ˆBaseUnitå•ä½ï¼Œuint64èŒƒå›´é™åˆ¶ï¼‰
	// æ³¨æ„ï¼šå¤§é¢æ“ä½œåº”ä½¿ç”¨å­—ç¬¦ä¸²æ ¼å¼çš„amountå­—æ®µ
	DelegateAddress   []byte `protobuf:"bytes,6,opt,name=delegate_address,json=delegateAddress,proto3" json:"delegate_address,omitempty"`             // è¢«å§”æ‰˜æ–¹åœ°å€
	DelegationContext []byte `protobuf:"bytes,7,opt,name=delegation_context,json=delegationContext,proto3,oneof" json:"delegation_context,omitempty"` // å¯é€‰çš„å§”æ‰˜ä¸Šä¸‹æ–‡
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *DelegationProof) Reset() {
	*x = DelegationProof{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DelegationProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DelegationProof) ProtoMessage() {}

func (x *DelegationProof) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DelegationProof.ProtoReflect.Descriptor instead.
func (*DelegationProof) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{20}
}

func (x *DelegationProof) GetDelegationTransactionId() []byte {
	if x != nil {
		return x.DelegationTransactionId
	}
	return nil
}

func (x *DelegationProof) GetDelegationOutputIndex() uint32 {
	if x != nil {
		return x.DelegationOutputIndex
	}
	return 0
}

func (x *DelegationProof) GetDelegateSignature() *SignatureData {
	if x != nil {
		return x.DelegateSignature
	}
	return nil
}

func (x *DelegationProof) GetOperationType() string {
	if x != nil {
		return x.OperationType
	}
	return ""
}

func (x *DelegationProof) GetValueAmount() uint64 {
	if x != nil {
		return x.ValueAmount
	}
	return 0
}

func (x *DelegationProof) GetDelegateAddress() []byte {
	if x != nil {
		return x.DelegateAddress
	}
	return nil
}

func (x *DelegationProof) GetDelegationContext() []byte {
	if x != nil {
		return x.DelegationContext
	}
	return nil
}

// *
// ThresholdProof - é—¨é™ç­¾åè§£é”è¯æ˜
//
// å¯¹åº”ThresholdLockçš„è§£é”è¯æ˜ï¼Œæä¾›é—¨é™ç­¾åçš„ç»„åˆè¯æ˜ã€‚
//
// ğŸ”‘ è¯æ˜å†…å®¹ï¼š
// - shares: é—¨é™ç­¾åä»½é¢åˆ—è¡¨ï¼ˆæ•°é‡ >= lock.thresholdï¼‰
// - combined_signature: ç»„åˆåçš„æœ€ç»ˆç­¾å
// - æ¯ä¸ªä»½é¢å¿…é¡»å¯¹åº”lock.party_verification_keysä¸­çš„æœ‰æ•ˆå¯†é’¥
//
// ğŸ“ éªŒè¯ç¤ºä¾‹ï¼š
// 1. éªŒè¯shares.length >= lock.threshold
// 2. éªŒè¯æ¯ä¸ªparty_idåœ¨æœ‰æ•ˆèŒƒå›´å†…ä¸”ä¸é‡å¤
// 3. éªŒè¯æ¯ä¸ªsignature_shareå¯¹åº”æ­£ç¡®çš„éªŒè¯å¯†é’¥
// 4. éªŒè¯combined_signatureæ˜¯æœ‰æ•ˆçš„é—¨é™ç»„åˆç­¾å
// 5. éªŒè¯ç­¾åæ–¹æ¡ˆç¬¦åˆlock.signature_scheme
type ThresholdProof struct {
	state             protoimpl.MessageState                    `protogen:"open.v1"`
	Shares            []*ThresholdProof_ThresholdSignatureShare `protobuf:"bytes,1,rep,name=shares,proto3" json:"shares,omitempty"`                                                // é—¨é™ç­¾åä»½é¢
	CombinedSignature []byte                                    `protobuf:"bytes,2,opt,name=combined_signature,json=combinedSignature,proto3" json:"combined_signature,omitempty"` // ç»„åˆç­¾å
	SignatureScheme   string                                    `protobuf:"bytes,3,opt,name=signature_scheme,json=signatureScheme,proto3" json:"signature_scheme,omitempty"`       // ç­¾åæ–¹æ¡ˆ
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ThresholdProof) Reset() {
	*x = ThresholdProof{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ThresholdProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThresholdProof) ProtoMessage() {}

func (x *ThresholdProof) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThresholdProof.ProtoReflect.Descriptor instead.
func (*ThresholdProof) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{21}
}

func (x *ThresholdProof) GetShares() []*ThresholdProof_ThresholdSignatureShare {
	if x != nil {
		return x.Shares
	}
	return nil
}

func (x *ThresholdProof) GetCombinedSignature() []byte {
	if x != nil {
		return x.CombinedSignature
	}
	return nil
}

func (x *ThresholdProof) GetSignatureScheme() string {
	if x != nil {
		return x.SignatureScheme
	}
	return ""
}

// *
// TimeProof - æ—¶é—´é”è§£é”è¯æ˜
//
// å¯¹åº”TimeLockçš„è§£é”è¯æ˜ï¼Œæä¾›æ—¶é—´æ¡ä»¶æ»¡è¶³çš„è¯æ˜ã€‚
//
// ğŸ”‘ è¯æ˜å†…å®¹ï¼š
// - current_timestamp: å½“å‰æ—¶é—´æˆ³ï¼ˆå¿…é¡» >= lock.unlock_timestampï¼‰
// - timestamp_proof: æ—¶é—´æˆ³çš„å¯éªŒè¯è¯æ˜
// - base_proof: å¯¹åº”åŸºç¡€é”å®šæ¡ä»¶çš„è§£é”è¯æ˜
//
// ğŸ“ éªŒè¯ç¤ºä¾‹ï¼š
// 1. éªŒè¯current_timestamp >= lock.unlock_timestamp
// 2. æ ¹æ®lock.time_sourceéªŒè¯timestamp_proofçš„æœ‰æ•ˆæ€§
// 3. é€’å½’éªŒè¯base_proofç¬¦åˆlock.base_lockçš„è¦æ±‚
// 4. æ£€æŸ¥å®½é™æœŸç­‰é¢å¤–æ—¶é—´æ¡ä»¶
type TimeProof struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	CurrentTimestamp    uint64                 `protobuf:"varint,1,opt,name=current_timestamp,json=currentTimestamp,proto3" json:"current_timestamp,omitempty"`                           // å½“å‰æ—¶é—´æˆ³
	TimestampProof      []byte                 `protobuf:"bytes,2,opt,name=timestamp_proof,json=timestampProof,proto3" json:"timestamp_proof,omitempty"`                                  // æ—¶é—´æˆ³è¯æ˜
	BaseProof           *UnlockingProof        `protobuf:"bytes,3,opt,name=base_proof,json=baseProof,proto3" json:"base_proof,omitempty"`                                                 // åŸºç¡€è§£é”è¯æ˜
	TimeSource          TimeLock_TimeSource    `protobuf:"varint,4,opt,name=time_source,json=timeSource,proto3,enum=pb.blockchain.core.TimeLock_TimeSource" json:"time_source,omitempty"` // æ—¶é—´æ¥æº
	TimeOracleSignature []byte                 `protobuf:"bytes,5,opt,name=time_oracle_signature,json=timeOracleSignature,proto3,oneof" json:"time_oracle_signature,omitempty"`           // å¯é€‰çš„æ—¶é—´é¢„è¨€æœºç­¾å
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *TimeProof) Reset() {
	*x = TimeProof{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimeProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeProof) ProtoMessage() {}

func (x *TimeProof) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimeProof.ProtoReflect.Descriptor instead.
func (*TimeProof) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{22}
}

func (x *TimeProof) GetCurrentTimestamp() uint64 {
	if x != nil {
		return x.CurrentTimestamp
	}
	return 0
}

func (x *TimeProof) GetTimestampProof() []byte {
	if x != nil {
		return x.TimestampProof
	}
	return nil
}

func (x *TimeProof) GetBaseProof() *UnlockingProof {
	if x != nil {
		return x.BaseProof
	}
	return nil
}

func (x *TimeProof) GetTimeSource() TimeLock_TimeSource {
	if x != nil {
		return x.TimeSource
	}
	return TimeLock_TIME_SOURCE_BLOCK_TIMESTAMP
}

func (x *TimeProof) GetTimeOracleSignature() []byte {
	if x != nil {
		return x.TimeOracleSignature
	}
	return nil
}

// *
// HeightProof - åŒºå—é«˜åº¦è§£é”è¯æ˜
//
// å¯¹åº”HeightLockçš„è§£é”è¯æ˜ï¼Œæä¾›åŒºå—é«˜åº¦æ¡ä»¶æ»¡è¶³çš„è¯æ˜ã€‚
//
// ğŸ”‘ è¯æ˜å†…å®¹ï¼š
// - current_height: å½“å‰åŒºå—é«˜åº¦ï¼ˆå¿…é¡» >= lock.unlock_heightï¼‰
// - block_header_proof: åŒºå—å¤´è¯æ˜æˆ–è½»å®¢æˆ·ç«¯è¯æ˜
// - base_proof: å¯¹åº”åŸºç¡€é”å®šæ¡ä»¶çš„è§£é”è¯æ˜
//
// ğŸ“ éªŒè¯ç¤ºä¾‹ï¼š
// 1. éªŒè¯current_height >= lock.unlock_height
// 2. éªŒè¯block_header_proofè¯æ˜å½“å‰é«˜åº¦çš„æœ‰æ•ˆæ€§
// 3. é€’å½’éªŒè¯base_proofç¬¦åˆlock.base_lockçš„è¦æ±‚
// 4. æ£€æŸ¥ç¡®è®¤åŒºå—æ•°ç­‰é¢å¤–é«˜åº¦æ¡ä»¶
type HeightProof struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	CurrentHeight      uint64                 `protobuf:"varint,1,opt,name=current_height,json=currentHeight,proto3" json:"current_height,omitempty"`                 // å½“å‰åŒºå—é«˜åº¦
	BlockHeaderProof   []byte                 `protobuf:"bytes,2,opt,name=block_header_proof,json=blockHeaderProof,proto3" json:"block_header_proof,omitempty"`       // åŒºå—å¤´è¯æ˜
	BaseProof          *UnlockingProof        `protobuf:"bytes,3,opt,name=base_proof,json=baseProof,proto3" json:"base_proof,omitempty"`                              // åŸºç¡€è§£é”è¯æ˜
	ConfirmationBlocks uint32                 `protobuf:"varint,4,opt,name=confirmation_blocks,json=confirmationBlocks,proto3" json:"confirmation_blocks,omitempty"`  // ç¡®è®¤åŒºå—æ•°
	LightClientProof   []byte                 `protobuf:"bytes,5,opt,name=light_client_proof,json=lightClientProof,proto3,oneof" json:"light_client_proof,omitempty"` // å¯é€‰çš„è½»å®¢æˆ·ç«¯è¯æ˜
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *HeightProof) Reset() {
	*x = HeightProof{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeightProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeightProof) ProtoMessage() {}

func (x *HeightProof) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeightProof.ProtoReflect.Descriptor instead.
func (*HeightProof) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{23}
}

func (x *HeightProof) GetCurrentHeight() uint64 {
	if x != nil {
		return x.CurrentHeight
	}
	return 0
}

func (x *HeightProof) GetBlockHeaderProof() []byte {
	if x != nil {
		return x.BlockHeaderProof
	}
	return nil
}

func (x *HeightProof) GetBaseProof() *UnlockingProof {
	if x != nil {
		return x.BaseProof
	}
	return nil
}

func (x *HeightProof) GetConfirmationBlocks() uint32 {
	if x != nil {
		return x.ConfirmationBlocks
	}
	return 0
}

func (x *HeightProof) GetLightClientProof() []byte {
	if x != nil {
		return x.LightClientProof
	}
	return nil
}

type UnlockingProof struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Proof:
	//
	//	*UnlockingProof_SingleKeyProof
	//	*UnlockingProof_MultiKeyProof
	//	*UnlockingProof_ExecutionProof
	//	*UnlockingProof_DelegationProof
	//	*UnlockingProof_ThresholdProof
	Proof         isUnlockingProof_Proof `protobuf_oneof:"proof"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnlockingProof) Reset() {
	*x = UnlockingProof{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnlockingProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnlockingProof) ProtoMessage() {}

func (x *UnlockingProof) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnlockingProof.ProtoReflect.Descriptor instead.
func (*UnlockingProof) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{24}
}

func (x *UnlockingProof) GetProof() isUnlockingProof_Proof {
	if x != nil {
		return x.Proof
	}
	return nil
}

func (x *UnlockingProof) GetSingleKeyProof() *SingleKeyProof {
	if x != nil {
		if x, ok := x.Proof.(*UnlockingProof_SingleKeyProof); ok {
			return x.SingleKeyProof
		}
	}
	return nil
}

func (x *UnlockingProof) GetMultiKeyProof() *MultiKeyProof {
	if x != nil {
		if x, ok := x.Proof.(*UnlockingProof_MultiKeyProof); ok {
			return x.MultiKeyProof
		}
	}
	return nil
}

func (x *UnlockingProof) GetExecutionProof() *ExecutionProof {
	if x != nil {
		if x, ok := x.Proof.(*UnlockingProof_ExecutionProof); ok {
			return x.ExecutionProof
		}
	}
	return nil
}

func (x *UnlockingProof) GetDelegationProof() *DelegationProof {
	if x != nil {
		if x, ok := x.Proof.(*UnlockingProof_DelegationProof); ok {
			return x.DelegationProof
		}
	}
	return nil
}

func (x *UnlockingProof) GetThresholdProof() *ThresholdProof {
	if x != nil {
		if x, ok := x.Proof.(*UnlockingProof_ThresholdProof); ok {
			return x.ThresholdProof
		}
	}
	return nil
}

type isUnlockingProof_Proof interface {
	isUnlockingProof_Proof()
}

type UnlockingProof_SingleKeyProof struct {
	SingleKeyProof *SingleKeyProof `protobuf:"bytes,1,opt,name=single_key_proof,json=singleKeyProof,proto3,oneof"` // å•å¯†é’¥è§£é”è¯æ˜
}

type UnlockingProof_MultiKeyProof struct {
	MultiKeyProof *MultiKeyProof `protobuf:"bytes,2,opt,name=multi_key_proof,json=multiKeyProof,proto3,oneof"` // å¤šå¯†é’¥è§£é”è¯æ˜
}

type UnlockingProof_ExecutionProof struct {
	ExecutionProof *ExecutionProof `protobuf:"bytes,3,opt,name=execution_proof,json=executionProof,proto3,oneof"` // âœ… ISPCæ‰§è¡Œè¯æ˜ï¼ˆé€šç”¨ï¼Œé€‚ç”¨äºåˆçº¦/æ¨¡å‹/å…¶ä»–ï¼‰
}

type UnlockingProof_DelegationProof struct {
	DelegationProof *DelegationProof `protobuf:"bytes,5,opt,name=delegation_proof,json=delegationProof,proto3,oneof"` // å§”æ‰˜æˆæƒè§£é”è¯æ˜
}

type UnlockingProof_ThresholdProof struct {
	ThresholdProof *ThresholdProof `protobuf:"bytes,6,opt,name=threshold_proof,json=thresholdProof,proto3,oneof"` // é—¨é™ç­¾åè§£é”è¯æ˜
}

func (*UnlockingProof_SingleKeyProof) isUnlockingProof_Proof() {}

func (*UnlockingProof_MultiKeyProof) isUnlockingProof_Proof() {}

func (*UnlockingProof_ExecutionProof) isUnlockingProof_Proof() {}

func (*UnlockingProof_DelegationProof) isUnlockingProof_Proof() {}

func (*UnlockingProof_ThresholdProof) isUnlockingProof_Proof() {}

// *
// AssetOutput - èµ„äº§è¾“å‡ºç³»ç»Ÿ
//
// ğŸ¯ è®¾è®¡ç†å¿µï¼šèµ„äº§è¾“å‡ºåº”è¯¥åŒºåˆ†åŸç”Ÿä»£å¸å’Œåˆçº¦ä»£å¸ï¼Œæä¾›ä¸åŒçš„ä¼˜åŒ–ç­–ç•¥
//
// ç±»å‹åˆ†å·¥ï¼š
// - NativeCoinAssetï¼šåŸç”Ÿä»£å¸ï¼Œæç®€é«˜æ•ˆ
// - ContractTokenAssetï¼šåˆçº¦ä»£å¸ï¼Œå®Œæ•´ç®¡ç†
type AssetOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to AssetContent:
	//
	//	*AssetOutput_NativeCoin
	//	*AssetOutput_ContractToken
	AssetContent  isAssetOutput_AssetContent `protobuf_oneof:"asset_content"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AssetOutput) Reset() {
	*x = AssetOutput{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AssetOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AssetOutput) ProtoMessage() {}

func (x *AssetOutput) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AssetOutput.ProtoReflect.Descriptor instead.
func (*AssetOutput) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{25}
}

func (x *AssetOutput) GetAssetContent() isAssetOutput_AssetContent {
	if x != nil {
		return x.AssetContent
	}
	return nil
}

func (x *AssetOutput) GetNativeCoin() *NativeCoinAsset {
	if x != nil {
		if x, ok := x.AssetContent.(*AssetOutput_NativeCoin); ok {
			return x.NativeCoin
		}
	}
	return nil
}

func (x *AssetOutput) GetContractToken() *ContractTokenAsset {
	if x != nil {
		if x, ok := x.AssetContent.(*AssetOutput_ContractToken); ok {
			return x.ContractToken
		}
	}
	return nil
}

type isAssetOutput_AssetContent interface {
	isAssetOutput_AssetContent()
}

type AssetOutput_NativeCoin struct {
	NativeCoin *NativeCoinAsset `protobuf:"bytes,1,opt,name=native_coin,json=nativeCoin,proto3,oneof"` // åŸç”Ÿä»£å¸
}

type AssetOutput_ContractToken struct {
	ContractToken *ContractTokenAsset `protobuf:"bytes,2,opt,name=contract_token,json=contractToken,proto3,oneof"` // æ™ºèƒ½åˆçº¦å‘è¡Œçš„ä»£å¸
}

func (*AssetOutput_NativeCoin) isAssetOutput_AssetContent() {}

func (*AssetOutput_ContractToken) isAssetOutput_AssetContent() {}

// *
// NativeCoinAsset - åŸç”Ÿä»£å¸èµ„äº§ï¼ˆæç®€è®¾è®¡ï¼‰
//
// ğŸ¯ è®¾è®¡ç†å¿µï¼šåŸç”Ÿä»£å¸åº”è¯¥æ˜¯æœ€ç®€å•ã€æœ€é«˜æ•ˆçš„
//
// ç‰¹ç‚¹ï¼š
// - æ— éœ€åˆçº¦åœ°å€ï¼ˆå°±æ˜¯åŸç”Ÿçš„ï¼‰
// - æ— éœ€ä»£å¸ç±»åˆ«ï¼ˆåªæœ‰ä¸€ç§åŸç”Ÿå¸ï¼‰
// - æ— éœ€å…ƒæ•°æ®ï¼ˆåè®®å±‚å›ºå®šå®šä¹‰ï¼‰
// - é«˜æ€§èƒ½éªŒè¯ï¼ˆæœ€å¸¸ç”¨çš„ä»£å¸ç±»å‹ï¼‰
//
// å›ºå®šå±æ€§ï¼ˆåè®®å±‚å®šä¹‰ï¼‰ï¼š
// - åç§°ï¼šç”±å…·ä½“å®ç°å®šä¹‰
// - ç¬¦å·ï¼šç”±å…·ä½“å®ç°å®šä¹‰
// - ç²¾åº¦ï¼š8ä½å°æ•°ï¼ˆ1 WES = 10^8 BaseUnitï¼‰
// - æ€»ä¾›åº”é‡ï¼šç”±ç»æµæ¨¡å‹æ§åˆ¶
//
// ğŸ“ ä½¿ç”¨ç¤ºä¾‹ï¼š
//
//	native_coin {
//	  amount: "150000000000"           // 1500.0 WES = 150,000,000,000 BaseUnit
//	                                   // è®¡ç®—ï¼š1500 Ã— 10^8 = 150000000000
//	}
type NativeCoinAsset struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Amount        string                 `protobuf:"bytes,1,opt,name=amount,proto3" json:"amount,omitempty"` // åŸç”Ÿå¸æ•°é‡ï¼ˆBaseUnitå•ä½ï¼Œå­—ç¬¦ä¸²æ ¼å¼æ”¯æŒå¤§æ•°ï¼‰
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NativeCoinAsset) Reset() {
	*x = NativeCoinAsset{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NativeCoinAsset) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NativeCoinAsset) ProtoMessage() {}

func (x *NativeCoinAsset) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NativeCoinAsset.ProtoReflect.Descriptor instead.
func (*NativeCoinAsset) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{26}
}

func (x *NativeCoinAsset) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

// *
// ContractTokenAsset - æ™ºèƒ½åˆçº¦ä»£å¸èµ„äº§
//
// ğŸ¯ è®¾è®¡ç†å¿µï¼šåˆçº¦ä»£å¸éœ€è¦å®Œæ•´çš„ç®¡ç†å’Œåˆ†ç±»ä½“ç³»
//
// èŒè´£åˆ†å·¥ï¼š
// - UTXOå±‚ï¼šå­˜å‚¨åŸºæœ¬æ ‡è¯†ä¿¡æ¯å’Œæ•°é‡
// - åˆçº¦å±‚ï¼šç®¡ç†å…ƒæ•°æ®ã€æƒé™ã€ä¸šåŠ¡é€»è¾‘
// - æ˜¾ç¤ºå±‚ï¼šä»åˆçº¦æŸ¥è¯¢nameã€symbolã€decimalsç­‰å±•ç¤ºä¿¡æ¯
//
// ğŸ”§ å…³é”®è®¾è®¡å†³ç­–ï¼š
// 1. **contract_address**ï¼šæ˜ç¡®æ ‡è¯†ä»£å¸æ¥æºåˆçº¦
// 2. **token_identifier**ï¼šç»Ÿä¸€çš„ä»£å¸æ ‡è¯†ç³»ç»Ÿ
// 3. **amount**ï¼šå®é™…æŒæœ‰æ•°é‡ï¼ˆNFTä¸º"1"ï¼‰
// 4. **å…ƒæ•°æ®å¼•ç”¨**ï¼šé€šè¿‡åˆçº¦æŸ¥è¯¢ï¼Œé¿å…UTXOå†—ä½™
//
// ğŸ“Š ä»£å¸æ ‡è¯†ä½“ç³»ï¼š
// - åŒè´¨åŒ–ä»£å¸(FT)ï¼šclass_idæ ‡è¯†ä»£å¸ç±»åˆ«
// - éåŒè´¨åŒ–ä»£å¸(NFT)ï¼šunique_idæ ‡è¯†å”¯ä¸€å®ä¾‹
// - åŠåŒè´¨åŒ–ä»£å¸(SFT)ï¼šbatch_id + instance_id
type ContractTokenAsset struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ContractAddress []byte                 `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // ä»£å¸åˆçº¦åœ°å€
	// Types that are valid to be assigned to TokenIdentifier:
	//
	//	*ContractTokenAsset_FungibleClassId
	//	*ContractTokenAsset_NftUniqueId
	//	*ContractTokenAsset_SemiFungibleId
	TokenIdentifier isContractTokenAsset_TokenIdentifier `protobuf_oneof:"token_identifier"`
	Amount          string                               `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"` // æŒæœ‰æ•°é‡ï¼ˆBaseUnitå•ä½ï¼Œå­—ç¬¦ä¸²æ ¼å¼ï¼‰
	// å¯¹äºNFTï¼Œamountå›ºå®šä¸º"1"ï¼ˆBaseUnitï¼‰
	DisplayCache  *TokenDisplayCache `protobuf:"bytes,20,opt,name=display_cache,json=displayCache,proto3,oneof" json:"display_cache,omitempty"` // å¯é€‰çš„æ˜¾ç¤ºç¼“å­˜
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContractTokenAsset) Reset() {
	*x = ContractTokenAsset{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContractTokenAsset) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContractTokenAsset) ProtoMessage() {}

func (x *ContractTokenAsset) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContractTokenAsset.ProtoReflect.Descriptor instead.
func (*ContractTokenAsset) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{27}
}

func (x *ContractTokenAsset) GetContractAddress() []byte {
	if x != nil {
		return x.ContractAddress
	}
	return nil
}

func (x *ContractTokenAsset) GetTokenIdentifier() isContractTokenAsset_TokenIdentifier {
	if x != nil {
		return x.TokenIdentifier
	}
	return nil
}

func (x *ContractTokenAsset) GetFungibleClassId() []byte {
	if x != nil {
		if x, ok := x.TokenIdentifier.(*ContractTokenAsset_FungibleClassId); ok {
			return x.FungibleClassId
		}
	}
	return nil
}

func (x *ContractTokenAsset) GetNftUniqueId() []byte {
	if x != nil {
		if x, ok := x.TokenIdentifier.(*ContractTokenAsset_NftUniqueId); ok {
			return x.NftUniqueId
		}
	}
	return nil
}

func (x *ContractTokenAsset) GetSemiFungibleId() *SemiFungibleId {
	if x != nil {
		if x, ok := x.TokenIdentifier.(*ContractTokenAsset_SemiFungibleId); ok {
			return x.SemiFungibleId
		}
	}
	return nil
}

func (x *ContractTokenAsset) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *ContractTokenAsset) GetDisplayCache() *TokenDisplayCache {
	if x != nil {
		return x.DisplayCache
	}
	return nil
}

type isContractTokenAsset_TokenIdentifier interface {
	isContractTokenAsset_TokenIdentifier()
}

type ContractTokenAsset_FungibleClassId struct {
	FungibleClassId []byte `protobuf:"bytes,10,opt,name=fungible_class_id,json=fungibleClassId,proto3,oneof"` // åŒè´¨åŒ–ä»£å¸ç±»åˆ«ID
}

type ContractTokenAsset_NftUniqueId struct {
	NftUniqueId []byte `protobuf:"bytes,11,opt,name=nft_unique_id,json=nftUniqueId,proto3,oneof"` // NFTå”¯ä¸€æ ‡è¯†ç¬¦
}

type ContractTokenAsset_SemiFungibleId struct {
	SemiFungibleId *SemiFungibleId `protobuf:"bytes,12,opt,name=semi_fungible_id,json=semiFungibleId,proto3,oneof"` // åŠåŒè´¨åŒ–ä»£å¸ID
}

func (*ContractTokenAsset_FungibleClassId) isContractTokenAsset_TokenIdentifier() {}

func (*ContractTokenAsset_NftUniqueId) isContractTokenAsset_TokenIdentifier() {}

func (*ContractTokenAsset_SemiFungibleId) isContractTokenAsset_TokenIdentifier() {}

// *
// SemiFungibleId - åŠåŒè´¨åŒ–ä»£å¸æ ‡è¯†
//
// ç”¨äºæ ‡è¯†æ‰¹æ¬¡+å®ä¾‹çš„åŒå±‚ç»“æ„ä»£å¸ï¼Œé€‚ç”¨äºæ¼”å”±ä¼šé—¨ç¥¨ã€æ¸¸æˆé“å…·ç­‰åœºæ™¯
type SemiFungibleId struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	BatchId       []byte                 `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`           // æ‰¹æ¬¡ID
	InstanceId    uint64                 `protobuf:"varint,2,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"` // å®ä¾‹ID
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SemiFungibleId) Reset() {
	*x = SemiFungibleId{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SemiFungibleId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SemiFungibleId) ProtoMessage() {}

func (x *SemiFungibleId) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SemiFungibleId.ProtoReflect.Descriptor instead.
func (*SemiFungibleId) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{28}
}

func (x *SemiFungibleId) GetBatchId() []byte {
	if x != nil {
		return x.BatchId
	}
	return nil
}

func (x *SemiFungibleId) GetInstanceId() uint64 {
	if x != nil {
		return x.InstanceId
	}
	return 0
}

// *
// TokenDisplayCache - ä»£å¸æ˜¾ç¤ºç¼“å­˜ï¼ˆå¯é€‰ï¼‰
//
// ğŸ¯ ç”¨é€”ï¼šç¼“å­˜å¸¸ç”¨çš„æ˜¾ç¤ºä¿¡æ¯ï¼Œå‡å°‘åˆçº¦æŸ¥è¯¢
// âš ï¸ æ³¨æ„ï¼šè¿™æ˜¯ä¼˜åŒ–å­—æ®µï¼ŒéªŒè¯æ—¶å¿…é¡»ä»¥åˆçº¦æ•°æ®ä¸ºå‡†
//
// ä½¿ç”¨åœºæ™¯ï¼š
// - é’±åŒ…å¿«é€Ÿæ˜¾ç¤ºä»£å¸ä¿¡æ¯
// - äº¤æ˜“æ‰€ç•Œé¢ä¼˜åŒ–
// - ç§»åŠ¨ç«¯ç¦»çº¿æ˜¾ç¤º
//
// éªŒè¯åŸåˆ™ï¼š
// - æ˜¾ç¤ºæ—¶å¯ä»¥ä½¿ç”¨ç¼“å­˜
// - éªŒè¯æ—¶å¿…é¡»æŸ¥è¯¢åˆçº¦
// - ç¼“å­˜ä¸ä¸€è‡´æ—¶ä»¥åˆçº¦ä¸ºå‡†
type TokenDisplayCache struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Name           string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                            // ä»£å¸åç§°
	Symbol         string                 `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`                                        // ä»£å¸ç¬¦å·
	Decimals       uint32                 `protobuf:"varint,3,opt,name=decimals,proto3" json:"decimals,omitempty"`                                   // å°æ•°ä½æ•°
	IconUri        *string                `protobuf:"bytes,4,opt,name=icon_uri,json=iconUri,proto3,oneof" json:"icon_uri,omitempty"`                 // å›¾æ ‡URI
	CacheTimestamp uint64                 `protobuf:"varint,5,opt,name=cache_timestamp,json=cacheTimestamp,proto3" json:"cache_timestamp,omitempty"` // ç¼“å­˜æ—¶é—´æˆ³
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TokenDisplayCache) Reset() {
	*x = TokenDisplayCache{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenDisplayCache) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenDisplayCache) ProtoMessage() {}

func (x *TokenDisplayCache) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenDisplayCache.ProtoReflect.Descriptor instead.
func (*TokenDisplayCache) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{29}
}

func (x *TokenDisplayCache) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TokenDisplayCache) GetSymbol() string {
	if x != nil {
		return x.Symbol
	}
	return ""
}

func (x *TokenDisplayCache) GetDecimals() uint32 {
	if x != nil {
		return x.Decimals
	}
	return 0
}

func (x *TokenDisplayCache) GetIconUri() string {
	if x != nil && x.IconUri != nil {
		return *x.IconUri
	}
	return ""
}

func (x *TokenDisplayCache) GetCacheTimestamp() uint64 {
	if x != nil {
		return x.CacheTimestamp
	}
	return 0
}

// *
// StateOutput - é›¶çŸ¥è¯†çŠ¶æ€è¯æ˜è¾“å‡ºï¼ˆè¯æ®è½½ä½“UTXOåˆ›å»ºï¼‰
//
// ğŸ¯ æ ¸å¿ƒä»·å€¼ï¼šå•ç‚¹æ‰§è¡Œï¼Œå¤šç‚¹éªŒè¯
//
// ğŸ’¡ è§£å†³çš„æ ¹æœ¬é—®é¢˜ï¼š
// ä¼ ç»ŸåŒºå—é“¾æ— æ³•å¤„ç†å¤§å‹èµ„æºï¼š
// - 2GB AIæ¨¡å‹ï¼šæ— æ³•åœ¨æ‰€æœ‰èŠ‚ç‚¹éƒ¨ç½²å’Œæ‰§è¡Œ
// - 10GBåŒ»ç–—å½±åƒï¼šæ— æ³•åœ¨ç½‘ç»œä¸­å¤åˆ¶å’Œå¤„ç†
// - ä¼ä¸šçº§ç®—æ³•ï¼šæ— æ³•æš´éœ²æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
//
// ğŸš€ åŒºå—é“¾è§£å†³æ–¹æ¡ˆï¼š
// - ä¸šåŠ¡æ–¹å•ç‚¹æ‰§è¡Œï¼šæ‹¥æœ‰èµ„æºçš„èŠ‚ç‚¹æ‰§è¡Œè®¡ç®—å¹¶ç”ŸæˆZKè¯æ˜
// - ç½‘ç»œå¤šç‚¹éªŒè¯ï¼šå…¶ä»–èŠ‚ç‚¹é€šè¿‡éªŒè¯ZKè¯æ˜ç¡®è®¤æ‰§è¡Œæ­£ç¡®æ€§
// - éªŒè¯æˆæœ¬å›ºå®šï¼šéªŒè¯æ—¶é—´å’Œèµ„æºå¤§å°æ— å…³ï¼ˆ~5msï¼Œ~256å­—èŠ‚ï¼‰
//
// ğŸ—ï¸ æƒåˆ©è½½ä½“å®šä½ï¼š
// - ä½œä¸º"è¯æ®è½½ä½“"å®ç°ï¼Œæ‰¿è½½å†å²è¯æ®æƒåˆ©çš„åˆ›å»ºèŒè´£
// - æƒåˆ©å†…å®¹ï¼šè¯æ˜æƒã€æŸ¥è¯¢æƒã€è¿½æº¯æƒ
// - æƒåˆ©æ§åˆ¶ï¼šé€šè¿‡TxOutput.locking_conditionså®šä¹‰è®¿é—®æƒé™
//
// ğŸ”§ æŠ€æœ¯å®ç°ï¼š
// - åŸºäºGnarké›¶çŸ¥è¯†è¯æ˜åº“
// - æ”¯æŒGroth16ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰å’ŒPlonKï¼ˆç ”å‘ç¯å¢ƒï¼‰
// - å®Œæ•´çš„ç”µè·¯ç‰ˆæœ¬ç®¡ç†å’Œå®‰å…¨ä¿éšœæœºåˆ¶
//
// ğŸ“‹ å…¸å‹åº”ç”¨åœºæ™¯ï¼š
// - AIæ¨¡å‹æ¨ç†ï¼šè¯æ˜æ¨ç†æ­£ç¡®æ€§ï¼Œæ— éœ€æš´éœ²æ¨¡å‹å‚æ•°
// - å¤§æ–‡ä»¶å¤„ç†ï¼šè¯æ˜å¤„ç†æ­£ç¡®æ€§ï¼Œæ— éœ€ä¼ è¾“å¤§æ–‡ä»¶
// - ä¼ä¸šç®—æ³•ï¼šè¯æ˜è®¡ç®—æ­£ç¡®æ€§ï¼Œä¿æŠ¤å•†ä¸šæœºå¯†
// - åˆè§„éªŒè¯ï¼šè¯æ˜åˆè§„æ€§ï¼Œä¿æŠ¤æ•æ„Ÿæ•°æ®
type StateOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ========== åŸºæœ¬çŠ¶æ€ä¿¡æ¯ ==========
	StateId      []byte `protobuf:"bytes,1,opt,name=state_id,json=stateId,proto3" json:"state_id,omitempty"`                 // çŠ¶æ€æ ‡è¯†ç¬¦ï¼ˆå…¨å±€å”¯ä¸€ï¼‰
	StateVersion uint64 `protobuf:"varint,2,opt,name=state_version,json=stateVersion,proto3" json:"state_version,omitempty"` // çŠ¶æ€ç‰ˆæœ¬å·ï¼ˆé€’å¢åºåˆ—ï¼‰
	// ========== é›¶çŸ¥è¯†è¯æ˜ï¼ˆæ ¸å¿ƒå†…å®¹ï¼‰==========
	ZkProof *ZKStateProof `protobuf:"bytes,3,opt,name=zk_proof,json=zkProof,proto3" json:"zk_proof,omitempty"` // é›¶çŸ¥è¯†çŠ¶æ€è¯æ˜
	// ========== æ‰§è¡Œç»“æœä¿¡æ¯ ==========
	ExecutionResultHash []byte `protobuf:"bytes,10,opt,name=execution_result_hash,json=executionResultHash,proto3" json:"execution_result_hash,omitempty"` // æ‰§è¡Œç»“æœå“ˆå¸Œï¼ˆå…¬å¼€è¾“å‡ºï¼‰
	// ========== çŠ¶æ€é“¾è¿æ¥ ==========
	ParentStateHash []byte `protobuf:"bytes,20,opt,name=parent_state_hash,json=parentStateHash,proto3,oneof" json:"parent_state_hash,omitempty"` // çˆ¶çŠ¶æ€å“ˆå¸Œï¼ˆçŠ¶æ€é“¾è¿æ¥ï¼‰
	// ========== ç”Ÿå‘½å‘¨æœŸæ§åˆ¶ ==========
	TtlDurationSeconds *uint64 `protobuf:"varint,30,opt,name=ttl_duration_seconds,json=ttlDurationSeconds,proto3,oneof" json:"ttl_duration_seconds,omitempty"` // ç”Ÿå­˜æ—¶é—´ï¼ˆç§’ï¼Œå¯é€‰ï¼‰
	// ========== å…ƒæ•°æ®æ‰©å±• ==========
	Metadata map[string]string `protobuf:"bytes,40,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // ä¸šåŠ¡å…ƒæ•°æ®ï¼ˆå¯é€‰ï¼‰
	// ========== è°ƒè¯•å’Œç›‘æ§ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰==========
	ZkMetadata    *ZKProofMetadata `protobuf:"bytes,50,opt,name=zk_metadata,json=zkMetadata,proto3,oneof" json:"zk_metadata,omitempty"` // ZKè¯æ˜å…ƒæ•°æ®
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StateOutput) Reset() {
	*x = StateOutput{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StateOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StateOutput) ProtoMessage() {}

func (x *StateOutput) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StateOutput.ProtoReflect.Descriptor instead.
func (*StateOutput) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{30}
}

func (x *StateOutput) GetStateId() []byte {
	if x != nil {
		return x.StateId
	}
	return nil
}

func (x *StateOutput) GetStateVersion() uint64 {
	if x != nil {
		return x.StateVersion
	}
	return 0
}

func (x *StateOutput) GetZkProof() *ZKStateProof {
	if x != nil {
		return x.ZkProof
	}
	return nil
}

func (x *StateOutput) GetExecutionResultHash() []byte {
	if x != nil {
		return x.ExecutionResultHash
	}
	return nil
}

func (x *StateOutput) GetParentStateHash() []byte {
	if x != nil {
		return x.ParentStateHash
	}
	return nil
}

func (x *StateOutput) GetTtlDurationSeconds() uint64 {
	if x != nil && x.TtlDurationSeconds != nil {
		return *x.TtlDurationSeconds
	}
	return 0
}

func (x *StateOutput) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *StateOutput) GetZkMetadata() *ZKProofMetadata {
	if x != nil {
		return x.ZkMetadata
	}
	return nil
}

// *
// ResourceOutput - åˆ›å»ºèƒ½åŠ›è½½ä½“UTXOï¼ˆèµ„æºåˆ›å»ºè¾“å‡ºï¼‰
//
// ğŸ¯ åœ¨TXæ¶æ„ä¸­çš„å¹³ç­‰åœ°ä½ï¼š
// ```
// TxOutput (åˆ›å»ºæ–°UTXO)
//
//	â”œâ”€ AssetOutput    (ğŸ’° ä»·å€¼è½½ä½“) â† Token/NFT/SFT
//	â”œâ”€ ResourceOutput (âš™ï¸ èƒ½åŠ›è½½ä½“) â† Contract/Model/File â† æœ¬æ¶ˆæ¯
//	â””â”€ StateOutput    (ğŸ“Š è¯æ®è½½ä½“) â† Execution/Snapshot
//
// âš ï¸ ä¸‰è€…å®Œå…¨å¹³ç­‰ï¼Œæ— ä¸»æ¬¡ä¹‹åˆ†ï¼
// ```
//
// ğŸ¯ è®¾è®¡ç›®çš„ï¼šåœ¨åŒºå—é“¾ä¸Šåˆ›å»ºæ–°çš„èƒ½åŠ›è½½ä½“UTXO
//
// âš ï¸ æ ¸å¿ƒæ¦‚å¿µï¼šTxOutput = åˆ›å»ºï¼Œä¸æ˜¯å¼•ç”¨
// - ResourceOutputï¼šåˆ›å»ºæ–°çš„èƒ½åŠ›è½½ä½“UTXOï¼ŒåŒ…å«å®Œæ•´èµ„æºå®šä¹‰
// - OutPointï¼šå¼•ç”¨å·²å­˜åœ¨çš„UTXOï¼Œæä¾›ç²¾ç¡®å®šä½èƒ½åŠ›
// - ä¸è¦æ··æ·†"åˆ›å»º"ä¸"å¼•ç”¨"çš„æ¦‚å¿µï¼
//
// ğŸ”’ æƒé™éªŒè¯è¦ç‚¹ï¼ˆTXæœ¬è´¨çš„ä½“ç°ï¼‰ï¼š
// 1. **åˆ›å»ºResourceOutputéœ€è¦TXæƒé™éªŒè¯**ï¼š
//   - å¿…é¡»é€šè¿‡Transactionè¿›è¡Œï¼Œä¸èƒ½ç›´æ¥åˆ›å»º
//   - éœ€è¦æ¶ˆè´¹è¾“å…¥UTXOæ”¯ä»˜è´¹ç”¨
//   - UnlockingProof å¿…é¡»åŒ¹é…è¾“å…¥UTXOçš„LockingCondition
//
// 2. **å¼•ç”¨ResourceOutputéœ€è¦TXæƒé™éªŒè¯**ï¼š
//   - TxInput.is_reference_only = true
//   - UnlockingProof å¿…é¡»åŒ¹é… ResourceOutputçš„locking_conditions
//   - å¼•ç”¨æˆåŠŸåUTXOä¿æŒåœ¨é›†åˆä¸­
//
// 3. **æ¶ˆè´¹ResourceOutputéœ€è¦TXæƒé™éªŒè¯**ï¼š
//   - TxInput.is_reference_only = false
//   - UnlockingProof å¿…é¡»åŒ¹é… ResourceOutputçš„locking_conditions
//   - æ¶ˆè´¹æˆåŠŸåUTXOä»é›†åˆä¸­ç§»é™¤ï¼ˆè½¬ç§»/å‡çº§ï¼‰
//
// ğŸ—ï¸ æƒåˆ©è½½ä½“æ˜ å°„ï¼š
// - è¿™æ˜¯èƒ½åŠ›è½½ä½“çš„åˆ›å»ºå®ç°ï¼Œç¬¦åˆç»Ÿä¸€æƒåˆ©è½½ä½“ç†è®º
// - é€šè¿‡TxOutput.locking_conditionså®šä¹‰èµ„æºçš„åˆå§‹æƒåˆ©æ§åˆ¶
// - åç»­é€šè¿‡TxInput + OutPointè¿›è¡Œèƒ½åŠ›è½½ä½“çš„å¼•ç”¨å’Œè½¬ç§»
// - Resource (resource.proto) = å†…å®¹å®šä¹‰ï¼ŒTransaction = æƒé™æ§åˆ¶
//
// ğŸ“‹ æ”¯æŒçš„èµ„æºç±»å‹ï¼š
// - å¯æ‰§è¡Œèµ„æºï¼šæ™ºèƒ½åˆçº¦WASMã€AIæ¨¡å‹ONNXç­‰
// - é™æ€èµ„æºï¼šå›¾ç‰‡ã€æ–‡æ¡£ã€æ•°æ®æ–‡ä»¶ç­‰
// - å®Œæ•´çš„èµ„æºå…ƒä¿¡æ¯å’Œæ‰§è¡Œé…ç½®
//
// ğŸ’¡ è®¾è®¡å“²å­¦ï¼š
// - èµ„æºå†…å®¹é€šè¿‡content_hashè¿›è¡Œå†…å®¹å¯»å€å­˜å‚¨
// - åŒºå—é“¾UTXOåªè®°å½•èµ„æºçš„å®Œæ•´å®šä¹‰å’Œæƒåˆ©æ§åˆ¶
// - å®ç°"å†…å®¹å¯»å€+åŒºå—é“¾é”šå®š"çš„æ··åˆå­˜å‚¨æ¨¡å‹
// - ç¬¦åˆ"å†…å®¹è½½ä½“"ï¼ˆresource.protoï¼‰ä¸"æƒåˆ©è½½ä½“"ï¼ˆtransaction.protoï¼‰åˆ†ç¦»åŸåˆ™
//
// ğŸ¯ å…¸å‹ä¸šåŠ¡åœºæ™¯ï¼ˆåŸºäºè¾“å…¥è¾“å‡ºç»„åˆï¼‰ï¼š
// - éƒ¨ç½²åˆçº¦ï¼šN inputs(è´¹ç”¨) + ResourceOutput(contract) + æ‰¾é›¶
// - éƒ¨ç½²æ¨¡å‹ï¼šN inputs(è´¹ç”¨) + ResourceOutput(aimodel) + æ‰¾é›¶
// - ä¸Šä¼ æ–‡ä»¶ï¼šN inputs(è´¹ç”¨) + ResourceOutput(static) + æ‰¾é›¶
// - åˆçº¦å‡çº§ï¼šæ¶ˆè´¹æ—§ResourceOutput + åˆ›å»ºæ–°ResourceOutput
// - åˆçº¦è°ƒç”¨ï¼šå¼•ç”¨ResourceOutput + StateOutput(ç»“æœ)
type ResourceOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ========== èµ„æºå®Œæ•´å®šä¹‰ï¼ˆç›´æ¥åµŒå…¥Resourceï¼‰==========
	Resource *resource.Resource `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"` // å®Œæ•´çš„èµ„æºå®šä¹‰
	// ========== åˆ›å»ºç›¸å…³ä¿¡æ¯ ==========
	CreationTimestamp uint64 `protobuf:"varint,10,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"` // åˆ›å»ºæ—¶é—´æˆ³
	CreationContext   string `protobuf:"bytes,11,opt,name=creation_context,json=creationContext,proto3" json:"creation_context,omitempty"`        // åˆ›å»ºä¸Šä¸‹æ–‡ï¼ˆå¯é€‰ï¼‰
	// ========== å­˜å‚¨ç­–ç•¥ ==========
	StorageStrategy  ResourceOutput_StorageStrategy `protobuf:"varint,20,opt,name=storage_strategy,json=storageStrategy,proto3,enum=pb.blockchain.core.ResourceOutput_StorageStrategy" json:"storage_strategy,omitempty"` // å­˜å‚¨ç­–ç•¥é€‰æ‹©
	StorageLocations [][]byte                       `protobuf:"bytes,21,rep,name=storage_locations,json=storageLocations,proto3" json:"storage_locations,omitempty"`                                                      // å­˜å‚¨ä½ç½®æç¤ºï¼ˆå†…å®¹å¯»å€ç½‘ç»œï¼‰
	// ========== ç”Ÿå‘½å‘¨æœŸæ§åˆ¶ ==========
	ExpiryTimestamp *uint64 `protobuf:"varint,30,opt,name=expiry_timestamp,json=expiryTimestamp,proto3,oneof" json:"expiry_timestamp,omitempty"` // è¿‡æœŸæ—¶é—´ï¼ˆå¯é€‰ï¼‰
	IsImmutable     bool    `protobuf:"varint,31,opt,name=is_immutable,json=isImmutable,proto3" json:"is_immutable,omitempty"`                   // æ˜¯å¦ä¸å¯å˜ï¼ˆä¸€æ—¦åˆ›å»ºä¸èƒ½æ›´æ–°ï¼‰
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ResourceOutput) Reset() {
	*x = ResourceOutput{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResourceOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResourceOutput) ProtoMessage() {}

func (x *ResourceOutput) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResourceOutput.ProtoReflect.Descriptor instead.
func (*ResourceOutput) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{31}
}

func (x *ResourceOutput) GetResource() *resource.Resource {
	if x != nil {
		return x.Resource
	}
	return nil
}

func (x *ResourceOutput) GetCreationTimestamp() uint64 {
	if x != nil {
		return x.CreationTimestamp
	}
	return 0
}

func (x *ResourceOutput) GetCreationContext() string {
	if x != nil {
		return x.CreationContext
	}
	return ""
}

func (x *ResourceOutput) GetStorageStrategy() ResourceOutput_StorageStrategy {
	if x != nil {
		return x.StorageStrategy
	}
	return ResourceOutput_STORAGE_STRATEGY_CONTENT_ADDRESSED
}

func (x *ResourceOutput) GetStorageLocations() [][]byte {
	if x != nil {
		return x.StorageLocations
	}
	return nil
}

func (x *ResourceOutput) GetExpiryTimestamp() uint64 {
	if x != nil && x.ExpiryTimestamp != nil {
		return *x.ExpiryTimestamp
	}
	return 0
}

func (x *ResourceOutput) GetIsImmutable() bool {
	if x != nil {
		return x.IsImmutable
	}
	return false
}

type TimeBasedWindow struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	NotBeforeTimestamp *uint64                `protobuf:"varint,1,opt,name=not_before_timestamp,json=notBeforeTimestamp,proto3,oneof" json:"not_before_timestamp,omitempty"` // æœ€æ—©æ‰§è¡Œæ—¶é—´
	NotAfterTimestamp  *uint64                `protobuf:"varint,2,opt,name=not_after_timestamp,json=notAfterTimestamp,proto3,oneof" json:"not_after_timestamp,omitempty"`    // è¿‡æœŸæ—¶é—´æˆ³
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *TimeBasedWindow) Reset() {
	*x = TimeBasedWindow{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimeBasedWindow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeBasedWindow) ProtoMessage() {}

func (x *TimeBasedWindow) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimeBasedWindow.ProtoReflect.Descriptor instead.
func (*TimeBasedWindow) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{32}
}

func (x *TimeBasedWindow) GetNotBeforeTimestamp() uint64 {
	if x != nil && x.NotBeforeTimestamp != nil {
		return *x.NotBeforeTimestamp
	}
	return 0
}

func (x *TimeBasedWindow) GetNotAfterTimestamp() uint64 {
	if x != nil && x.NotAfterTimestamp != nil {
		return *x.NotAfterTimestamp
	}
	return 0
}

type HeightBasedWindow struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	NotBeforeHeight *uint64                `protobuf:"varint,1,opt,name=not_before_height,json=notBeforeHeight,proto3,oneof" json:"not_before_height,omitempty"` // æœ€æ—©æ‰§è¡ŒåŒºå—é«˜åº¦
	NotAfterHeight  *uint64                `protobuf:"varint,2,opt,name=not_after_height,json=notAfterHeight,proto3,oneof" json:"not_after_height,omitempty"`    // è¿‡æœŸåŒºå—é«˜åº¦
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *HeightBasedWindow) Reset() {
	*x = HeightBasedWindow{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeightBasedWindow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeightBasedWindow) ProtoMessage() {}

func (x *HeightBasedWindow) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeightBasedWindow.ProtoReflect.Descriptor instead.
func (*HeightBasedWindow) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{33}
}

func (x *HeightBasedWindow) GetNotBeforeHeight() uint64 {
	if x != nil && x.NotBeforeHeight != nil {
		return *x.NotBeforeHeight
	}
	return 0
}

func (x *HeightBasedWindow) GetNotAfterHeight() uint64 {
	if x != nil && x.NotAfterHeight != nil {
		return *x.NotAfterHeight
	}
	return 0
}

// *
// TokenReference - è´¹ç”¨æ”¯ä»˜ä»£å¸ç±»å‹
type TokenReference struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to TokenType:
	//
	//	*TokenReference_NativeToken
	//	*TokenReference_ContractAddress
	TokenType     isTokenReference_TokenType `protobuf_oneof:"token_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TokenReference) Reset() {
	*x = TokenReference{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenReference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenReference) ProtoMessage() {}

func (x *TokenReference) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenReference.ProtoReflect.Descriptor instead.
func (*TokenReference) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{34}
}

func (x *TokenReference) GetTokenType() isTokenReference_TokenType {
	if x != nil {
		return x.TokenType
	}
	return nil
}

func (x *TokenReference) GetNativeToken() bool {
	if x != nil {
		if x, ok := x.TokenType.(*TokenReference_NativeToken); ok {
			return x.NativeToken
		}
	}
	return false
}

func (x *TokenReference) GetContractAddress() []byte {
	if x != nil {
		if x, ok := x.TokenType.(*TokenReference_ContractAddress); ok {
			return x.ContractAddress
		}
	}
	return nil
}

type isTokenReference_TokenType interface {
	isTokenReference_TokenType()
}

type TokenReference_NativeToken struct {
	NativeToken bool `protobuf:"varint,1,opt,name=native_token,json=nativeToken,proto3,oneof"` // åŸç”Ÿä»£å¸
}

type TokenReference_ContractAddress struct {
	ContractAddress []byte `protobuf:"bytes,2,opt,name=contract_address,json=contractAddress,proto3,oneof"` // åˆçº¦ä»£å¸åœ°å€
}

func (*TokenReference_NativeToken) isTokenReference_TokenType() {}

func (*TokenReference_ContractAddress) isTokenReference_TokenType() {}

// *
// MinimumFee - æœ€ä½è´¹ç”¨ä¿è¯
// é˜²åƒåœ¾äº¤æ˜“ï¼šå®é™…è´¹ç”¨ >= minimum_amount
type MinimumFee struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MinimumAmount string                 `protobuf:"bytes,1,opt,name=minimum_amount,json=minimumAmount,proto3" json:"minimum_amount,omitempty"` // æœ€ä½è´¹ç”¨é‡‘é¢ï¼ˆBaseUnitå•ä½ï¼Œå­—ç¬¦ä¸²æ ¼å¼ï¼‰
	FeeToken      *TokenReference        `protobuf:"bytes,2,opt,name=fee_token,json=feeToken,proto3" json:"fee_token,omitempty"`                // æ”¯ä»˜ä»£å¸ç±»å‹
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MinimumFee) Reset() {
	*x = MinimumFee{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MinimumFee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MinimumFee) ProtoMessage() {}

func (x *MinimumFee) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MinimumFee.ProtoReflect.Descriptor instead.
func (*MinimumFee) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{35}
}

func (x *MinimumFee) GetMinimumAmount() string {
	if x != nil {
		return x.MinimumAmount
	}
	return ""
}

func (x *MinimumFee) GetFeeToken() *TokenReference {
	if x != nil {
		return x.FeeToken
	}
	return nil
}

// *
// ProportionalFee - æŒ‰æ¯”ä¾‹æ”¶è´¹
// å¤§é¢è½¬è´¦æŒ‰æ¯”ä¾‹ï¼šè´¹ç”¨ = è½¬è´¦é‡‘é¢ Ã— è´¹ç‡
type ProportionalFee struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	RateBasisPoints uint32                 `protobuf:"varint,1,opt,name=rate_basis_points,json=rateBasisPoints,proto3" json:"rate_basis_points,omitempty"` // è´¹ç‡ï¼ˆä¸‡åˆ†ä¹‹Xï¼‰
	MaxFeeAmount    *string                `protobuf:"bytes,2,opt,name=max_fee_amount,json=maxFeeAmount,proto3,oneof" json:"max_fee_amount,omitempty"`     // æœ€å¤§è´¹ç”¨é™åˆ¶ï¼ˆBaseUnitå•ä½ï¼Œå­—ç¬¦ä¸²æ ¼å¼ï¼‰
	FeeToken        *TokenReference        `protobuf:"bytes,3,opt,name=fee_token,json=feeToken,proto3" json:"fee_token,omitempty"`                         // æ”¯ä»˜ä»£å¸ç±»å‹
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ProportionalFee) Reset() {
	*x = ProportionalFee{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProportionalFee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProportionalFee) ProtoMessage() {}

func (x *ProportionalFee) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProportionalFee.ProtoReflect.Descriptor instead.
func (*ProportionalFee) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{36}
}

func (x *ProportionalFee) GetRateBasisPoints() uint32 {
	if x != nil {
		return x.RateBasisPoints
	}
	return 0
}

func (x *ProportionalFee) GetMaxFeeAmount() string {
	if x != nil && x.MaxFeeAmount != nil {
		return *x.MaxFeeAmount
	}
	return ""
}

func (x *ProportionalFee) GetFeeToken() *TokenReference {
	if x != nil {
		return x.FeeToken
	}
	return nil
}

// *
// ContractExecutionFee - åˆçº¦æ‰§è¡Œè´¹ç”¨
// æ™ºèƒ½åˆçº¦è°ƒç”¨ï¼šå›ºå®šè´¹ç”¨æ¨¡å¼
type ContractExecutionFee struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	BaseFee       string                 `protobuf:"bytes,1,opt,name=base_fee,json=baseFee,proto3" json:"base_fee,omitempty"`                // åŸºç¡€è´¹ç”¨ï¼ˆBaseUnitå•ä½ï¼Œæ¿€åŠ±çŸ¿å·¥æ‰“åŒ…ï¼‰
	ExecutionFee  string                 `protobuf:"bytes,2,opt,name=execution_fee,json=executionFee,proto3" json:"execution_fee,omitempty"` // æ‰§è¡Œè´¹ç”¨ï¼ˆBaseUnitå•ä½ï¼Œå›ºå®šé‡‘é¢ï¼‰
	FeeToken      *TokenReference        `protobuf:"bytes,4,opt,name=fee_token,json=feeToken,proto3" json:"fee_token,omitempty"`             // æ”¯ä»˜ä»£å¸ç±»å‹
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContractExecutionFee) Reset() {
	*x = ContractExecutionFee{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContractExecutionFee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContractExecutionFee) ProtoMessage() {}

func (x *ContractExecutionFee) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContractExecutionFee.ProtoReflect.Descriptor instead.
func (*ContractExecutionFee) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{37}
}

func (x *ContractExecutionFee) GetBaseFee() string {
	if x != nil {
		return x.BaseFee
	}
	return ""
}

func (x *ContractExecutionFee) GetExecutionFee() string {
	if x != nil {
		return x.ExecutionFee
	}
	return ""
}

func (x *ContractExecutionFee) GetFeeToken() *TokenReference {
	if x != nil {
		return x.FeeToken
	}
	return nil
}

// *
// PriorityFee - ä¼˜å…ˆçº§è´¹ç”¨
// å¿«é€Ÿç¡®è®¤ï¼šè´¹ç”¨ = åŸºç¡€è´¹ç”¨ Ã— ä¼˜å…ˆçº§å€ç‡
type PriorityFee struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	BaseFee       string                 `protobuf:"bytes,1,opt,name=base_fee,json=baseFee,proto3" json:"base_fee,omitempty"`                // åŸºç¡€è´¹ç”¨ï¼ˆBaseUnitå•ä½ï¼‰
	PriorityRate  string                 `protobuf:"bytes,2,opt,name=priority_rate,json=priorityRate,proto3" json:"priority_rate,omitempty"` // ä¼˜å…ˆçº§å€ç‡
	FeeToken      *TokenReference        `protobuf:"bytes,3,opt,name=fee_token,json=feeToken,proto3" json:"fee_token,omitempty"`             // æ”¯ä»˜ä»£å¸ç±»å‹
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PriorityFee) Reset() {
	*x = PriorityFee{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PriorityFee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PriorityFee) ProtoMessage() {}

func (x *PriorityFee) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PriorityFee.ProtoReflect.Descriptor instead.
func (*PriorityFee) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{38}
}

func (x *PriorityFee) GetBaseFee() string {
	if x != nil {
		return x.BaseFee
	}
	return ""
}

func (x *PriorityFee) GetPriorityRate() string {
	if x != nil {
		return x.PriorityRate
	}
	return ""
}

func (x *PriorityFee) GetFeeToken() *TokenReference {
	if x != nil {
		return x.FeeToken
	}
	return nil
}

type TransactionMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Memo  *string                `protobuf:"bytes,1,opt,name=memo,proto3,oneof" json:"memo,omitempty"` // æ–‡æœ¬å¤‡æ³¨
	Tags  []string               `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`       // åˆ†ç±»æ ‡ç­¾
	// Types that are valid to be assigned to Payload:
	//
	//	*TransactionMetadata_BinaryData
	//	*TransactionMetadata_JsonData
	//	*TransactionMetadata_StructuredData
	Payload       isTransactionMetadata_Payload `protobuf_oneof:"payload"`
	CustomFields  map[string][]byte             `protobuf:"bytes,20,rep,name=custom_fields,json=customFields,proto3" json:"custom_fields,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // è‡ªå®šä¹‰äºŒè¿›åˆ¶å­—æ®µ
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransactionMetadata) Reset() {
	*x = TransactionMetadata{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransactionMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransactionMetadata) ProtoMessage() {}

func (x *TransactionMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransactionMetadata.ProtoReflect.Descriptor instead.
func (*TransactionMetadata) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{39}
}

func (x *TransactionMetadata) GetMemo() string {
	if x != nil && x.Memo != nil {
		return *x.Memo
	}
	return ""
}

func (x *TransactionMetadata) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *TransactionMetadata) GetPayload() isTransactionMetadata_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *TransactionMetadata) GetBinaryData() []byte {
	if x != nil {
		if x, ok := x.Payload.(*TransactionMetadata_BinaryData); ok {
			return x.BinaryData
		}
	}
	return nil
}

func (x *TransactionMetadata) GetJsonData() string {
	if x != nil {
		if x, ok := x.Payload.(*TransactionMetadata_JsonData); ok {
			return x.JsonData
		}
	}
	return ""
}

func (x *TransactionMetadata) GetStructuredData() *StructuredData {
	if x != nil {
		if x, ok := x.Payload.(*TransactionMetadata_StructuredData); ok {
			return x.StructuredData
		}
	}
	return nil
}

func (x *TransactionMetadata) GetCustomFields() map[string][]byte {
	if x != nil {
		return x.CustomFields
	}
	return nil
}

type isTransactionMetadata_Payload interface {
	isTransactionMetadata_Payload()
}

type TransactionMetadata_BinaryData struct {
	BinaryData []byte `protobuf:"bytes,10,opt,name=binary_data,json=binaryData,proto3,oneof"` // åŸå§‹äºŒè¿›åˆ¶æ•°æ®
}

type TransactionMetadata_JsonData struct {
	JsonData string `protobuf:"bytes,11,opt,name=json_data,json=jsonData,proto3,oneof"` // JSONæ ¼å¼æ•°æ®
}

type TransactionMetadata_StructuredData struct {
	StructuredData *StructuredData `protobuf:"bytes,12,opt,name=structured_data,json=structuredData,proto3,oneof"` // ç»“æ„åŒ–é”®å€¼å¯¹æ•°æ®
}

func (*TransactionMetadata_BinaryData) isTransactionMetadata_Payload() {}

func (*TransactionMetadata_JsonData) isTransactionMetadata_Payload() {}

func (*TransactionMetadata_StructuredData) isTransactionMetadata_Payload() {}

type StructuredData struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Fields        map[string][]byte      `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // ç»“æ„åŒ–å­—æ®µæ˜ å°„
	SchemaVersion *string                `protobuf:"bytes,2,opt,name=schema_version,json=schemaVersion,proto3,oneof" json:"schema_version,omitempty"`                                  // æ•°æ®æ ¼å¼ç‰ˆæœ¬æ ‡è¯†
	ContentType   *string                `protobuf:"bytes,3,opt,name=content_type,json=contentType,proto3,oneof" json:"content_type,omitempty"`                                        // å†…å®¹ç±»å‹è¯´æ˜
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StructuredData) Reset() {
	*x = StructuredData{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StructuredData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StructuredData) ProtoMessage() {}

func (x *StructuredData) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StructuredData.ProtoReflect.Descriptor instead.
func (*StructuredData) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{40}
}

func (x *StructuredData) GetFields() map[string][]byte {
	if x != nil {
		return x.Fields
	}
	return nil
}

func (x *StructuredData) GetSchemaVersion() string {
	if x != nil && x.SchemaVersion != nil {
		return *x.SchemaVersion
	}
	return ""
}

func (x *StructuredData) GetContentType() string {
	if x != nil && x.ContentType != nil {
		return *x.ContentType
	}
	return ""
}

// *
// IdentityProof - èº«ä»½è¯æ˜ï¼ˆå¯†ç å­¦å®‰å…¨ä¿è¯ï¼‰
//
// ğŸ¯ æ ¸å¿ƒç›®çš„ï¼š
// - è¯æ˜"è°æ‰§è¡Œäº†ISPCæ“ä½œ"
// - é˜²æ­¢caller_addressè¢«ä¼ªé€ 
// - ä¿è¯å¯†ç å­¦å®‰å…¨æ€§
//
// ğŸ”‘ è®¾è®¡åŸåˆ™ï¼š
// - ç­¾åå¯¹execution contextçš„å“ˆå¸Œç­¾å
// - åŒ…å«å…¬é’¥ç”¨äºéªŒè¯
// - åŒ…å«nonceé˜²æ­¢é‡æ”¾æ”»å‡»
// - åŒ…å«æ—¶é—´æˆ³ç”¨äºæ—¶æ•ˆæ€§éªŒè¯
//
// ğŸ“ éªŒè¯æµç¨‹ï¼š
// 1. éªŒè¯signatureæ˜¯å¦åŒ¹é…context_hashï¼ˆä½¿ç”¨public_keyï¼‰
// 2. éªŒè¯caller_addressæ˜¯å¦ä»public_keyæ¨å¯¼ï¼ˆç¡®ä¿ä¸€è‡´æ€§ï¼‰
// 3. éªŒè¯nonceæ˜¯å¦æœªè¢«ä½¿ç”¨ï¼ˆé˜²é‡æ”¾æ”»å‡»ï¼‰
// 4. éªŒè¯timestampæ˜¯å¦åœ¨æœ‰æ•ˆæœŸå†…ï¼ˆæ—¶æ•ˆæ€§éªŒè¯ï¼‰
// 5. éªŒè¯context_hashæ˜¯å¦åŒ¹é…å®é™…çš„ExecutionContextï¼ˆå®Œæ•´æ€§éªŒè¯ï¼‰
type IdentityProof struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ========== èº«ä»½ä¿¡æ¯ ==========
	PublicKey     []byte `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`             // è°ƒç”¨è€…å…¬é’¥ï¼ˆ33-65å­—èŠ‚ï¼Œä¾ç®—æ³•è€Œå®šï¼‰
	CallerAddress []byte `protobuf:"bytes,2,opt,name=caller_address,json=callerAddress,proto3" json:"caller_address,omitempty"` // è°ƒç”¨è€…åœ°å€ï¼ˆä»public_keyæ¨å¯¼ï¼Œ20å­—èŠ‚ï¼‰
	// ========== å¯†ç å­¦è¯æ˜ ==========
	Signature   []byte             `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`                                                                   // å¯¹execution contextçš„ç­¾åï¼ˆ64-256å­—èŠ‚ï¼Œä¾ç®—æ³•è€Œå®šï¼‰
	Algorithm   SignatureAlgorithm `protobuf:"varint,4,opt,name=algorithm,proto3,enum=pb.blockchain.core.SignatureAlgorithm" json:"algorithm,omitempty"`                       // ç­¾åç®—æ³•
	SighashType SignatureHashType  `protobuf:"varint,5,opt,name=sighash_type,json=sighashType,proto3,enum=pb.blockchain.core.SignatureHashType" json:"sighash_type,omitempty"` // ç­¾åå“ˆå¸Œç±»å‹
	// ========== é˜²é‡æ”¾æ”»å‡» ==========
	Nonce     []byte `protobuf:"bytes,6,opt,name=nonce,proto3" json:"nonce,omitempty"`          // é˜²é‡æ”¾nonceï¼ˆ32å­—èŠ‚ï¼‰
	Timestamp uint64 `protobuf:"varint,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"` // æ—¶é—´æˆ³ï¼ˆUnixç§’ï¼‰
	// ========== ä¸Šä¸‹æ–‡å“ˆå¸Œ ==========
	ContextHash   []byte `protobuf:"bytes,8,opt,name=context_hash,json=contextHash,proto3" json:"context_hash,omitempty"` // æ‰§è¡Œä¸Šä¸‹æ–‡çš„å“ˆå¸Œï¼ˆ32å­—èŠ‚SHA-256ï¼‰
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IdentityProof) Reset() {
	*x = IdentityProof{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IdentityProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IdentityProof) ProtoMessage() {}

func (x *IdentityProof) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IdentityProof.ProtoReflect.Descriptor instead.
func (*IdentityProof) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{41}
}

func (x *IdentityProof) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *IdentityProof) GetCallerAddress() []byte {
	if x != nil {
		return x.CallerAddress
	}
	return nil
}

func (x *IdentityProof) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *IdentityProof) GetAlgorithm() SignatureAlgorithm {
	if x != nil {
		return x.Algorithm
	}
	return SignatureAlgorithm_SIGNATURE_ALGORITHM_UNKNOWN
}

func (x *IdentityProof) GetSighashType() SignatureHashType {
	if x != nil {
		return x.SighashType
	}
	return SignatureHashType_SIGHASH_UNKNOWN
}

func (x *IdentityProof) GetNonce() []byte {
	if x != nil {
		return x.Nonce
	}
	return nil
}

func (x *IdentityProof) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *IdentityProof) GetContextHash() []byte {
	if x != nil {
		return x.ContextHash
	}
	return nil
}

// *
// ComputeHashRequest - è®¡ç®—å“ˆå¸Œè¯·æ±‚ï¼ˆç¡®å®šæ€§è®¾è®¡ï¼‰
type ComputeHashRequest struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Transaction      *Transaction           `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`                                      // éœ€è¦è®¡ç®—å“ˆå¸Œçš„äº¤æ˜“
	IncludeDebugInfo bool                   `protobuf:"varint,2,opt,name=include_debug_info,json=includeDebugInfo,proto3" json:"include_debug_info,omitempty"` // æ˜¯å¦è¿”å›è°ƒè¯•ä¿¡æ¯ï¼ˆä¸å½±å“å“ˆå¸Œï¼‰
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ComputeHashRequest) Reset() {
	*x = ComputeHashRequest{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComputeHashRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComputeHashRequest) ProtoMessage() {}

func (x *ComputeHashRequest) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComputeHashRequest.ProtoReflect.Descriptor instead.
func (*ComputeHashRequest) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{42}
}

func (x *ComputeHashRequest) GetTransaction() *Transaction {
	if x != nil {
		return x.Transaction
	}
	return nil
}

func (x *ComputeHashRequest) GetIncludeDebugInfo() bool {
	if x != nil {
		return x.IncludeDebugInfo
	}
	return false
}

// *
// ComputeHashResponse - è®¡ç®—å“ˆå¸Œå“åº”
type ComputeHashResponse struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Hash    []byte                 `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`                       // è®¡ç®—å‡ºçš„äº¤æ˜“å“ˆå¸Œï¼ˆSHA-256ï¼‰
	IsValid bool                   `protobuf:"varint,2,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"` // äº¤æ˜“ç»“æ„æ˜¯å¦æœ‰æ•ˆ
	// è°ƒè¯•ä¿¡æ¯ï¼ˆä¸å½±å“å“ˆå¸Œï¼‰
	DebugInfo     *HashDebugInfo `protobuf:"bytes,3,opt,name=debug_info,json=debugInfo,proto3,oneof" json:"debug_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComputeHashResponse) Reset() {
	*x = ComputeHashResponse{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComputeHashResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComputeHashResponse) ProtoMessage() {}

func (x *ComputeHashResponse) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComputeHashResponse.ProtoReflect.Descriptor instead.
func (*ComputeHashResponse) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{43}
}

func (x *ComputeHashResponse) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *ComputeHashResponse) GetIsValid() bool {
	if x != nil {
		return x.IsValid
	}
	return false
}

func (x *ComputeHashResponse) GetDebugInfo() *HashDebugInfo {
	if x != nil {
		return x.DebugInfo
	}
	return nil
}

// *
// ValidateHashRequest - éªŒè¯å“ˆå¸Œè¯·æ±‚
type ValidateHashRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transaction   *Transaction           `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`                       // éœ€è¦éªŒè¯çš„äº¤æ˜“
	ExpectedHash  []byte                 `protobuf:"bytes,2,opt,name=expected_hash,json=expectedHash,proto3" json:"expected_hash,omitempty"` // æœŸæœ›çš„å“ˆå¸Œå€¼
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateHashRequest) Reset() {
	*x = ValidateHashRequest{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateHashRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateHashRequest) ProtoMessage() {}

func (x *ValidateHashRequest) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateHashRequest.ProtoReflect.Descriptor instead.
func (*ValidateHashRequest) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{44}
}

func (x *ValidateHashRequest) GetTransaction() *Transaction {
	if x != nil {
		return x.Transaction
	}
	return nil
}

func (x *ValidateHashRequest) GetExpectedHash() []byte {
	if x != nil {
		return x.ExpectedHash
	}
	return nil
}

// *
// ValidateHashResponse - éªŒè¯å“ˆå¸Œå“åº”
type ValidateHashResponse struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	IsValid      bool                   `protobuf:"varint,1,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`               // éªŒè¯ç»“æœ
	ComputedHash []byte                 `protobuf:"bytes,2,opt,name=computed_hash,json=computedHash,proto3" json:"computed_hash,omitempty"` // å®é™…è®¡ç®—çš„å“ˆå¸Œ
	ExpectedHash []byte                 `protobuf:"bytes,3,opt,name=expected_hash,json=expectedHash,proto3" json:"expected_hash,omitempty"` // æœŸæœ›çš„å“ˆå¸Œå€¼
	// éªŒè¯è¯¦æƒ…ï¼ˆä¸å½±å“å“ˆå¸Œï¼‰
	ErrorMessage  *string `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3,oneof" json:"error_message,omitempty"` // é”™è¯¯ä¿¡æ¯ï¼ˆéªŒè¯å¤±è´¥æ—¶ï¼‰
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateHashResponse) Reset() {
	*x = ValidateHashResponse{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateHashResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateHashResponse) ProtoMessage() {}

func (x *ValidateHashResponse) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateHashResponse.ProtoReflect.Descriptor instead.
func (*ValidateHashResponse) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{45}
}

func (x *ValidateHashResponse) GetIsValid() bool {
	if x != nil {
		return x.IsValid
	}
	return false
}

func (x *ValidateHashResponse) GetComputedHash() []byte {
	if x != nil {
		return x.ComputedHash
	}
	return nil
}

func (x *ValidateHashResponse) GetExpectedHash() []byte {
	if x != nil {
		return x.ExpectedHash
	}
	return nil
}

func (x *ValidateHashResponse) GetErrorMessage() string {
	if x != nil && x.ErrorMessage != nil {
		return *x.ErrorMessage
	}
	return ""
}

// *
// ComputeSignatureHashRequest - è®¡ç®—ç­¾åå“ˆå¸Œè¯·æ±‚
//
// ğŸ¯ **ç­¾åå“ˆå¸Œè®¡ç®—è§„åˆ™**ï¼š
// 1. æ’é™¤ç­¾åå­—æ®µï¼šæ¸…ç©ºæ‰€æœ‰ inputs[].unlocking_proof å­—æ®µ
// 2. æ ¹æ® SIGHASH ç±»å‹ä¿®æ”¹äº¤æ˜“ç»“æ„ï¼š
//   - SIGHASH_ALL: ä¿ç•™æ‰€æœ‰è¾“å…¥å’Œæ‰€æœ‰è¾“å‡º
//   - SIGHASH_NONE: ä¿ç•™æ‰€æœ‰è¾“å…¥ï¼Œæ¸…ç©ºæ‰€æœ‰è¾“å‡º
//   - SIGHASH_SINGLE: ä¿ç•™æ‰€æœ‰è¾“å…¥å’Œå¯¹åº”ç´¢å¼•çš„è¾“å‡ºï¼Œå…¶ä»–è¾“å‡ºæ¸…ç©º
//   - SIGHASH_ANYONECANPAY: åªä¿ç•™å½“å‰è¾“å…¥ï¼ˆinput_indexï¼‰ï¼Œæ¸…ç©ºå…¶ä»–è¾“å…¥
//   - ç»„åˆç±»å‹ï¼šå…ˆå¤„ç† ANYONECANPAYï¼Œå†å¤„ç† ALL/NONE/SINGLE
//
// 3. ä½¿ç”¨ç¡®å®šæ€§ Protobuf åºåˆ—åŒ–
// 4. è®¡ç®— SHA-256 å“ˆå¸Œ
type ComputeSignatureHashRequest struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Transaction      *Transaction           `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`                                                               // éœ€è¦è®¡ç®—ç­¾åå“ˆå¸Œçš„äº¤æ˜“
	InputIndex       uint32                 `protobuf:"varint,2,opt,name=input_index,json=inputIndex,proto3" json:"input_index,omitempty"`                                              // å½“å‰è¾“å…¥ç´¢å¼•ï¼ˆç”¨äº SIGHASH_SINGLE å’Œ ANYONECANPAYï¼‰
	SighashType      SignatureHashType      `protobuf:"varint,3,opt,name=sighash_type,json=sighashType,proto3,enum=pb.blockchain.core.SignatureHashType" json:"sighash_type,omitempty"` // ç­¾åå“ˆå¸Œç±»å‹
	IncludeDebugInfo bool                   `protobuf:"varint,4,opt,name=include_debug_info,json=includeDebugInfo,proto3" json:"include_debug_info,omitempty"`                          // æ˜¯å¦è¿”å›è°ƒè¯•ä¿¡æ¯ï¼ˆä¸å½±å“å“ˆå¸Œï¼‰
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ComputeSignatureHashRequest) Reset() {
	*x = ComputeSignatureHashRequest{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComputeSignatureHashRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComputeSignatureHashRequest) ProtoMessage() {}

func (x *ComputeSignatureHashRequest) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComputeSignatureHashRequest.ProtoReflect.Descriptor instead.
func (*ComputeSignatureHashRequest) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{46}
}

func (x *ComputeSignatureHashRequest) GetTransaction() *Transaction {
	if x != nil {
		return x.Transaction
	}
	return nil
}

func (x *ComputeSignatureHashRequest) GetInputIndex() uint32 {
	if x != nil {
		return x.InputIndex
	}
	return 0
}

func (x *ComputeSignatureHashRequest) GetSighashType() SignatureHashType {
	if x != nil {
		return x.SighashType
	}
	return SignatureHashType_SIGHASH_UNKNOWN
}

func (x *ComputeSignatureHashRequest) GetIncludeDebugInfo() bool {
	if x != nil {
		return x.IncludeDebugInfo
	}
	return false
}

// *
// ComputeSignatureHashResponse - è®¡ç®—ç­¾åå“ˆå¸Œå“åº”
type ComputeSignatureHashResponse struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Hash    []byte                 `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`                       // è®¡ç®—å‡ºçš„ç­¾åå“ˆå¸Œï¼ˆSHA-256ï¼Œ32å­—èŠ‚ï¼‰
	IsValid bool                   `protobuf:"varint,2,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"` // äº¤æ˜“ç»“æ„æ˜¯å¦æœ‰æ•ˆ
	// è°ƒè¯•ä¿¡æ¯ï¼ˆä¸å½±å“å“ˆå¸Œï¼‰
	DebugInfo     *HashDebugInfo `protobuf:"bytes,3,opt,name=debug_info,json=debugInfo,proto3,oneof" json:"debug_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComputeSignatureHashResponse) Reset() {
	*x = ComputeSignatureHashResponse{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComputeSignatureHashResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComputeSignatureHashResponse) ProtoMessage() {}

func (x *ComputeSignatureHashResponse) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComputeSignatureHashResponse.ProtoReflect.Descriptor instead.
func (*ComputeSignatureHashResponse) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{47}
}

func (x *ComputeSignatureHashResponse) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *ComputeSignatureHashResponse) GetIsValid() bool {
	if x != nil {
		return x.IsValid
	}
	return false
}

func (x *ComputeSignatureHashResponse) GetDebugInfo() *HashDebugInfo {
	if x != nil {
		return x.DebugInfo
	}
	return nil
}

// *
// ValidateSignatureHashRequest - éªŒè¯ç­¾åå“ˆå¸Œè¯·æ±‚
type ValidateSignatureHashRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transaction   *Transaction           `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`                                                               // éœ€è¦éªŒè¯çš„äº¤æ˜“
	InputIndex    uint32                 `protobuf:"varint,2,opt,name=input_index,json=inputIndex,proto3" json:"input_index,omitempty"`                                              // å½“å‰è¾“å…¥ç´¢å¼•
	SighashType   SignatureHashType      `protobuf:"varint,3,opt,name=sighash_type,json=sighashType,proto3,enum=pb.blockchain.core.SignatureHashType" json:"sighash_type,omitempty"` // ç­¾åå“ˆå¸Œç±»å‹
	ExpectedHash  []byte                 `protobuf:"bytes,4,opt,name=expected_hash,json=expectedHash,proto3" json:"expected_hash,omitempty"`                                         // æœŸæœ›çš„ç­¾åå“ˆå¸Œå€¼
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateSignatureHashRequest) Reset() {
	*x = ValidateSignatureHashRequest{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateSignatureHashRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateSignatureHashRequest) ProtoMessage() {}

func (x *ValidateSignatureHashRequest) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateSignatureHashRequest.ProtoReflect.Descriptor instead.
func (*ValidateSignatureHashRequest) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{48}
}

func (x *ValidateSignatureHashRequest) GetTransaction() *Transaction {
	if x != nil {
		return x.Transaction
	}
	return nil
}

func (x *ValidateSignatureHashRequest) GetInputIndex() uint32 {
	if x != nil {
		return x.InputIndex
	}
	return 0
}

func (x *ValidateSignatureHashRequest) GetSighashType() SignatureHashType {
	if x != nil {
		return x.SighashType
	}
	return SignatureHashType_SIGHASH_UNKNOWN
}

func (x *ValidateSignatureHashRequest) GetExpectedHash() []byte {
	if x != nil {
		return x.ExpectedHash
	}
	return nil
}

// *
// ValidateSignatureHashResponse - éªŒè¯ç­¾åå“ˆå¸Œå“åº”
type ValidateSignatureHashResponse struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	IsValid      bool                   `protobuf:"varint,1,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`               // éªŒè¯ç»“æœ
	ComputedHash []byte                 `protobuf:"bytes,2,opt,name=computed_hash,json=computedHash,proto3" json:"computed_hash,omitempty"` // å®é™…è®¡ç®—çš„ç­¾åå“ˆå¸Œ
	ExpectedHash []byte                 `protobuf:"bytes,3,opt,name=expected_hash,json=expectedHash,proto3" json:"expected_hash,omitempty"` // æœŸæœ›çš„ç­¾åå“ˆå¸Œå€¼
	// éªŒè¯è¯¦æƒ…ï¼ˆä¸å½±å“å“ˆå¸Œï¼‰
	ErrorMessage  *string `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3,oneof" json:"error_message,omitempty"` // é”™è¯¯ä¿¡æ¯ï¼ˆéªŒè¯å¤±è´¥æ—¶ï¼‰
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateSignatureHashResponse) Reset() {
	*x = ValidateSignatureHashResponse{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateSignatureHashResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateSignatureHashResponse) ProtoMessage() {}

func (x *ValidateSignatureHashResponse) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateSignatureHashResponse.ProtoReflect.Descriptor instead.
func (*ValidateSignatureHashResponse) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{49}
}

func (x *ValidateSignatureHashResponse) GetIsValid() bool {
	if x != nil {
		return x.IsValid
	}
	return false
}

func (x *ValidateSignatureHashResponse) GetComputedHash() []byte {
	if x != nil {
		return x.ComputedHash
	}
	return nil
}

func (x *ValidateSignatureHashResponse) GetExpectedHash() []byte {
	if x != nil {
		return x.ExpectedHash
	}
	return nil
}

func (x *ValidateSignatureHashResponse) GetErrorMessage() string {
	if x != nil && x.ErrorMessage != nil {
		return *x.ErrorMessage
	}
	return ""
}

// *
// ZKStateProof - é›¶çŸ¥è¯†çŠ¶æ€è¯æ˜æ•°æ®ç»“æ„
//
// ğŸ¯ æ ¸å¿ƒç›®çš„ï¼šä¸ºStateOutputæä¾›éšç§ä¿æŠ¤çš„çŠ¶æ€è½¬æ¢è¯æ˜èƒ½åŠ›
//
// ğŸ›¡ï¸ éšç§ä¿æŠ¤åŸç†ï¼š
// - é€šè¿‡é›¶çŸ¥è¯†è¯æ˜æŠ€æœ¯ï¼Œè¯æ˜çŠ¶æ€è½¬æ¢çš„æ­£ç¡®æ€§ï¼ŒåŒæ—¶ä¿æŠ¤çŠ¶æ€è½¬æ¢çš„å…·ä½“ç»†èŠ‚
// - å…¬å¼€è¾“å…¥ï¼šåœ¨åŒºå—é“¾ä¸Šå¯è§ï¼Œç”¨äºéªŒè¯ï¼ˆå¦‚çŠ¶æ€å“ˆå¸Œã€ç‰ˆæœ¬å·ï¼‰
// - ç§æœ‰è¾“å…¥ï¼šéšç§ä¿æŠ¤ï¼Œä¸åœ¨åŒºå—é“¾ä¸Šæš´éœ²ï¼ˆå¦‚å…·ä½“çŠ¶æ€å†…å®¹ã€è½¬æ¢è§„åˆ™ï¼‰
//
// ğŸ”§ æŠ€æœ¯é›†æˆï¼š
// - åŸºäºGnarké›¶çŸ¥è¯†è¯æ˜åº“å®ç°
// - æ”¯æŒGroth16ï¼ˆå¿«é€ŸéªŒè¯ï¼‰å’ŒPlonKï¼ˆé€šç”¨è®¾ç½®ï¼‰ä¸¤ç§è¯æ˜æ–¹æ¡ˆ
// - æ”¯æŒå¤šç§æ¤­åœ†æ›²çº¿ï¼ˆBN254ã€BLS12-381ç­‰ï¼‰
//
// ğŸ’¡ è®¾è®¡å“²å­¦ï¼š
// - æ ‡å‡†åŒ–ï¼šéµå¾ªé›¶çŸ¥è¯†è¯æ˜è¡Œä¸šæ ‡å‡†
// - æ€§èƒ½å¯æ§ï¼šæä¾›å®Œæ•´çš„æ€§èƒ½å…ƒæ•°æ®ç”¨äºä¼˜åŒ–
// - å®‰å…¨ä¼˜å…ˆï¼šåŒ…å«ç”µè·¯ç‰ˆæœ¬å’Œæ‰¿è¯ºï¼Œç¡®ä¿è¯æ˜çš„å®Œæ•´æ€§
// - å¯æ‰©å±•æ€§ï¼šæ”¯æŒæœªæ¥æ–°çš„è¯æ˜æ–¹æ¡ˆå’Œæ¤­åœ†æ›²çº¿
type ZKStateProof struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ========== æ ¸å¿ƒè¯æ˜æ•°æ® ==========
	Proof               []byte   `protobuf:"bytes,1,opt,name=proof,proto3" json:"proof,omitempty"`                                                          // é›¶çŸ¥è¯†è¯æ˜æ•°æ®ï¼ˆåºåˆ—åŒ–çš„è¯æ˜å¯¹è±¡ï¼‰
	PublicInputs        [][]byte `protobuf:"bytes,2,rep,name=public_inputs,json=publicInputs,proto3" json:"public_inputs,omitempty"`                        // å…¬å¼€è¾“å…¥æ•°ç»„ï¼ˆéªŒè¯æ—¶éœ€è¦çš„å…¬å¼€å‚æ•°ï¼‰
	ProvingScheme       string   `protobuf:"bytes,3,opt,name=proving_scheme,json=provingScheme,proto3" json:"proving_scheme,omitempty"`                     // è¯æ˜æ–¹æ¡ˆæ ‡è¯†ç¬¦
	Curve               string   `protobuf:"bytes,4,opt,name=curve,proto3" json:"curve,omitempty"`                                                          // æ¤­åœ†æ›²çº¿æ ‡è¯†ç¬¦
	VerificationKeyHash []byte   `protobuf:"bytes,5,opt,name=verification_key_hash,json=verificationKeyHash,proto3" json:"verification_key_hash,omitempty"` // éªŒè¯å¯†é’¥å“ˆå¸Œï¼ˆ32å­—èŠ‚SHA-256ï¼‰
	// ========== ç”µè·¯ä¿¡æ¯ ==========
	CircuitId         string `protobuf:"bytes,10,opt,name=circuit_id,json=circuitId,proto3" json:"circuit_id,omitempty"`                               // ç”µè·¯æ ‡è¯†ç¬¦ï¼ˆå…¨å±€å”¯ä¸€ï¼‰
	CircuitVersion    uint32 `protobuf:"varint,11,opt,name=circuit_version,json=circuitVersion,proto3" json:"circuit_version,omitempty"`               // ç”µè·¯ç‰ˆæœ¬å·ï¼ˆé€’å¢æ•´æ•°ï¼‰
	CircuitCommitment []byte `protobuf:"bytes,12,opt,name=circuit_commitment,json=circuitCommitment,proto3,oneof" json:"circuit_commitment,omitempty"` // ç”µè·¯æ‰¿è¯ºï¼ˆå¯é€‰ï¼Œç”¨äºé¢å¤–å®‰å…¨ä¿è¯ï¼‰
	// ========== æ€§èƒ½å’Œè°ƒè¯•ä¿¡æ¯ ==========
	ConstraintCount       uint64  `protobuf:"varint,20,opt,name=constraint_count,json=constraintCount,proto3" json:"constraint_count,omitempty"`                             // ç”µè·¯çº¦æŸæ•°é‡
	ProofGenerationTimeMs *uint64 `protobuf:"varint,21,opt,name=proof_generation_time_ms,json=proofGenerationTimeMs,proto3,oneof" json:"proof_generation_time_ms,omitempty"` // è¯æ˜ç”Ÿæˆæ—¶é—´ï¼ˆæ¯«ç§’ï¼Œå¯é€‰ï¼‰
	// ========== ä¸šåŠ¡æ‰©å±•å­—æ®µ ==========
	CustomAttributes map[string]string `protobuf:"bytes,30,rep,name=custom_attributes,json=customAttributes,proto3" json:"custom_attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // è‡ªå®šä¹‰å±æ€§ï¼ˆä¸šåŠ¡å±‚æ‰©å±•ï¼‰
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ZKStateProof) Reset() {
	*x = ZKStateProof{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ZKStateProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ZKStateProof) ProtoMessage() {}

func (x *ZKStateProof) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ZKStateProof.ProtoReflect.Descriptor instead.
func (*ZKStateProof) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{50}
}

func (x *ZKStateProof) GetProof() []byte {
	if x != nil {
		return x.Proof
	}
	return nil
}

func (x *ZKStateProof) GetPublicInputs() [][]byte {
	if x != nil {
		return x.PublicInputs
	}
	return nil
}

func (x *ZKStateProof) GetProvingScheme() string {
	if x != nil {
		return x.ProvingScheme
	}
	return ""
}

func (x *ZKStateProof) GetCurve() string {
	if x != nil {
		return x.Curve
	}
	return ""
}

func (x *ZKStateProof) GetVerificationKeyHash() []byte {
	if x != nil {
		return x.VerificationKeyHash
	}
	return nil
}

func (x *ZKStateProof) GetCircuitId() string {
	if x != nil {
		return x.CircuitId
	}
	return ""
}

func (x *ZKStateProof) GetCircuitVersion() uint32 {
	if x != nil {
		return x.CircuitVersion
	}
	return 0
}

func (x *ZKStateProof) GetCircuitCommitment() []byte {
	if x != nil {
		return x.CircuitCommitment
	}
	return nil
}

func (x *ZKStateProof) GetConstraintCount() uint64 {
	if x != nil {
		return x.ConstraintCount
	}
	return 0
}

func (x *ZKStateProof) GetProofGenerationTimeMs() uint64 {
	if x != nil && x.ProofGenerationTimeMs != nil {
		return *x.ProofGenerationTimeMs
	}
	return 0
}

func (x *ZKStateProof) GetCustomAttributes() map[string]string {
	if x != nil {
		return x.CustomAttributes
	}
	return nil
}

// *
// ZKProofMetadata - é›¶çŸ¥è¯†è¯æ˜å…ƒæ•°æ®
//
// ğŸ¯ è®¾è®¡ç›®çš„ï¼šæä¾›ZKè¯æ˜çš„æ€§èƒ½ã€è°ƒè¯•å’Œè¿ç»´ä¿¡æ¯ï¼Œä¸å½±å“è¯æ˜éªŒè¯è¿‡ç¨‹
//
// ğŸ“Š æ€§èƒ½ç›‘æ§ï¼š
// - è¯æ˜ç”Ÿæˆå’ŒéªŒè¯çš„æ€§èƒ½æŒ‡æ ‡
// - ç”¨äºç³»ç»Ÿä¼˜åŒ–å’Œå®¹é‡è§„åˆ’
// - æ”¯æŒæ€§èƒ½åŸºå‡†æµ‹è¯•å’Œå›å½’æ£€æµ‹
//
// ğŸ”§ è¿ç»´æ”¯æŒï¼š
// - è¯æ˜å™¨ç‰ˆæœ¬ä¿¡æ¯ï¼Œç”¨äºé—®é¢˜æ’æŸ¥
// - æ€§èƒ½æ•°æ®ï¼Œç”¨äºç³»ç»Ÿç›‘æ§å’Œå‘Šè­¦
// - ç‰ˆæœ¬ä¿¡æ¯ï¼Œç”¨äºå‡çº§å†³ç­–
//
// ğŸ’¡ å¯é€‰æ€§è®¾è®¡ï¼š
// - æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¯é€‰çš„ï¼Œç”Ÿäº§ç¯å¢ƒå¯æ ¹æ®éœ€è¦é€‰æ‹©æ€§åŒ…å«
// - å¼€å‘å’Œæµ‹è¯•ç¯å¢ƒå»ºè®®åŒ…å«å®Œæ•´ä¿¡æ¯
// - å…ƒæ•°æ®ä¸å½±å“è¯æ˜çš„å®‰å…¨æ€§å’Œæ­£ç¡®æ€§
type ZKProofMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ========== ç‰ˆæœ¬ä¿¡æ¯ ==========
	ProverVersion   *string `protobuf:"bytes,1,opt,name=prover_version,json=proverVersion,proto3,oneof" json:"prover_version,omitempty"`       // è¯æ˜å™¨ç‰ˆæœ¬ï¼ˆå¦‚ "gnark-v0.14.0"ï¼‰
	CompilerVersion *string `protobuf:"bytes,2,opt,name=compiler_version,json=compilerVersion,proto3,oneof" json:"compiler_version,omitempty"` // ç”µè·¯ç¼–è¯‘å™¨ç‰ˆæœ¬
	// ========== æ€§èƒ½æŒ‡æ ‡ ==========
	ProofSizeBytes     *uint64 `protobuf:"varint,10,opt,name=proof_size_bytes,json=proofSizeBytes,proto3,oneof" json:"proof_size_bytes,omitempty"`             // è¯æ˜å¤§å°ï¼ˆå­—èŠ‚ï¼‰
	VerificationTimeMs *uint64 `protobuf:"varint,11,opt,name=verification_time_ms,json=verificationTimeMs,proto3,oneof" json:"verification_time_ms,omitempty"` // éªŒè¯æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
	SetupTimeMs        *uint64 `protobuf:"varint,12,opt,name=setup_time_ms,json=setupTimeMs,proto3,oneof" json:"setup_time_ms,omitempty"`                      // å¯ä¿¡è®¾ç½®æ—¶é—´ï¼ˆæ¯«ç§’ï¼Œé¦–æ¬¡ç”Ÿæˆæ—¶ï¼‰
	MemoryUsageBytes   *uint64 `protobuf:"varint,13,opt,name=memory_usage_bytes,json=memoryUsageBytes,proto3,oneof" json:"memory_usage_bytes,omitempty"`       // å†…å­˜ä½¿ç”¨é‡ï¼ˆå­—èŠ‚ï¼‰
	// ========== å®‰å…¨å®¡è®¡ä¿¡æ¯ ==========
	SecurityLevel          *string `protobuf:"bytes,20,opt,name=security_level,json=securityLevel,proto3,oneof" json:"security_level,omitempty"`                                 // å®‰å…¨çº§åˆ«æ ‡è¯†
	TrustedSetupCeremonyId *uint64 `protobuf:"varint,21,opt,name=trusted_setup_ceremony_id,json=trustedSetupCeremonyId,proto3,oneof" json:"trusted_setup_ceremony_id,omitempty"` // å¯ä¿¡è®¾ç½®ä»ªå¼IDï¼ˆGroth16ä¸“ç”¨ï¼‰
	// ========== è°ƒè¯•å’Œæ‰©å±•ä¿¡æ¯ ==========
	ProofGenerationNode      *string           `protobuf:"bytes,30,opt,name=proof_generation_node,json=proofGenerationNode,proto3,oneof" json:"proof_generation_node,omitempty"`                                              // ç”Ÿæˆè¯æ˜çš„èŠ‚ç‚¹æ ‡è¯†ï¼ˆè°ƒè¯•ç”¨ï¼‰
	ProofGenerationTimestamp *uint64           `protobuf:"varint,31,opt,name=proof_generation_timestamp,json=proofGenerationTimestamp,proto3,oneof" json:"proof_generation_timestamp,omitempty"`                              // è¯æ˜ç”Ÿæˆæ—¶é—´æˆ³ï¼ˆUnixç§’ï¼‰
	CustomFields             map[string]string `protobuf:"bytes,40,rep,name=custom_fields,json=customFields,proto3" json:"custom_fields,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // è‡ªå®šä¹‰å­—æ®µï¼ˆä¸šåŠ¡æ‰©å±•ï¼‰
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *ZKProofMetadata) Reset() {
	*x = ZKProofMetadata{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ZKProofMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ZKProofMetadata) ProtoMessage() {}

func (x *ZKProofMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ZKProofMetadata.ProtoReflect.Descriptor instead.
func (*ZKProofMetadata) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{51}
}

func (x *ZKProofMetadata) GetProverVersion() string {
	if x != nil && x.ProverVersion != nil {
		return *x.ProverVersion
	}
	return ""
}

func (x *ZKProofMetadata) GetCompilerVersion() string {
	if x != nil && x.CompilerVersion != nil {
		return *x.CompilerVersion
	}
	return ""
}

func (x *ZKProofMetadata) GetProofSizeBytes() uint64 {
	if x != nil && x.ProofSizeBytes != nil {
		return *x.ProofSizeBytes
	}
	return 0
}

func (x *ZKProofMetadata) GetVerificationTimeMs() uint64 {
	if x != nil && x.VerificationTimeMs != nil {
		return *x.VerificationTimeMs
	}
	return 0
}

func (x *ZKProofMetadata) GetSetupTimeMs() uint64 {
	if x != nil && x.SetupTimeMs != nil {
		return *x.SetupTimeMs
	}
	return 0
}

func (x *ZKProofMetadata) GetMemoryUsageBytes() uint64 {
	if x != nil && x.MemoryUsageBytes != nil {
		return *x.MemoryUsageBytes
	}
	return 0
}

func (x *ZKProofMetadata) GetSecurityLevel() string {
	if x != nil && x.SecurityLevel != nil {
		return *x.SecurityLevel
	}
	return ""
}

func (x *ZKProofMetadata) GetTrustedSetupCeremonyId() uint64 {
	if x != nil && x.TrustedSetupCeremonyId != nil {
		return *x.TrustedSetupCeremonyId
	}
	return 0
}

func (x *ZKProofMetadata) GetProofGenerationNode() string {
	if x != nil && x.ProofGenerationNode != nil {
		return *x.ProofGenerationNode
	}
	return ""
}

func (x *ZKProofMetadata) GetProofGenerationTimestamp() uint64 {
	if x != nil && x.ProofGenerationTimestamp != nil {
		return *x.ProofGenerationTimestamp
	}
	return 0
}

func (x *ZKProofMetadata) GetCustomFields() map[string]string {
	if x != nil {
		return x.CustomFields
	}
	return nil
}

// *
// HashDebugInfo - å“ˆå¸Œè®¡ç®—è°ƒè¯•ä¿¡æ¯ï¼ˆä¸å½±å“å“ˆå¸Œï¼‰
type HashDebugInfo struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	CanonicalBytes       []byte                 `protobuf:"bytes,1,opt,name=canonical_bytes,json=canonicalBytes,proto3" json:"canonical_bytes,omitempty"`                      // æ ‡å‡†åŒ–åçš„å­—èŠ‚æ•°æ®
	CanonicalLength      uint64                 `protobuf:"varint,2,opt,name=canonical_length,json=canonicalLength,proto3" json:"canonical_length,omitempty"`                  // æ ‡å‡†åŒ–æ•°æ®é•¿åº¦
	IncludedFields       []string               `protobuf:"bytes,3,rep,name=included_fields,json=includedFields,proto3" json:"included_fields,omitempty"`                      // å‚ä¸å“ˆå¸Œè®¡ç®—çš„å­—æ®µåˆ—è¡¨
	ExcludedFields       []string               `protobuf:"bytes,4,rep,name=excluded_fields,json=excludedFields,proto3" json:"excluded_fields,omitempty"`                      // æ’é™¤çš„å­—æ®µåˆ—è¡¨ï¼ˆå¦‚ç­¾åï¼‰
	SerializationMethod  string                 `protobuf:"bytes,5,opt,name=serialization_method,json=serializationMethod,proto3" json:"serialization_method,omitempty"`       // åºåˆ—åŒ–æ–¹æ³•ï¼ˆå›ºå®šä¸º"protobuf"ï¼‰
	ComputationTimeNanos uint64                 `protobuf:"varint,6,opt,name=computation_time_nanos,json=computationTimeNanos,proto3" json:"computation_time_nanos,omitempty"` // è®¡ç®—è€—æ—¶ï¼ˆçº³ç§’ï¼Œä»…è°ƒè¯•ï¼‰
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *HashDebugInfo) Reset() {
	*x = HashDebugInfo{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HashDebugInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HashDebugInfo) ProtoMessage() {}

func (x *HashDebugInfo) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HashDebugInfo.ProtoReflect.Descriptor instead.
func (*HashDebugInfo) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{52}
}

func (x *HashDebugInfo) GetCanonicalBytes() []byte {
	if x != nil {
		return x.CanonicalBytes
	}
	return nil
}

func (x *HashDebugInfo) GetCanonicalLength() uint64 {
	if x != nil {
		return x.CanonicalLength
	}
	return 0
}

func (x *HashDebugInfo) GetIncludedFields() []string {
	if x != nil {
		return x.IncludedFields
	}
	return nil
}

func (x *HashDebugInfo) GetExcludedFields() []string {
	if x != nil {
		return x.ExcludedFields
	}
	return nil
}

func (x *HashDebugInfo) GetSerializationMethod() string {
	if x != nil {
		return x.SerializationMethod
	}
	return ""
}

func (x *HashDebugInfo) GetComputationTimeNanos() uint64 {
	if x != nil {
		return x.ComputationTimeNanos
	}
	return 0
}

type MultiKeyProof_SignatureEntry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	KeyIndex      uint32                 `protobuf:"varint,1,opt,name=key_index,json=keyIndex,proto3" json:"key_index,omitempty"`                                                    // å¯¹åº”authorized_keysçš„ç´¢å¼•
	Signature     *SignatureData         `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`                                                                   // ç­¾åæ•°æ®
	Algorithm     SignatureAlgorithm     `protobuf:"varint,3,opt,name=algorithm,proto3,enum=pb.blockchain.core.SignatureAlgorithm" json:"algorithm,omitempty"`                       // ç­¾åç®—æ³•
	SighashType   SignatureHashType      `protobuf:"varint,4,opt,name=sighash_type,json=sighashType,proto3,enum=pb.blockchain.core.SignatureHashType" json:"sighash_type,omitempty"` // ç­¾åå“ˆå¸Œç±»å‹
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiKeyProof_SignatureEntry) Reset() {
	*x = MultiKeyProof_SignatureEntry{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiKeyProof_SignatureEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiKeyProof_SignatureEntry) ProtoMessage() {}

func (x *MultiKeyProof_SignatureEntry) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiKeyProof_SignatureEntry.ProtoReflect.Descriptor instead.
func (*MultiKeyProof_SignatureEntry) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{18, 0}
}

func (x *MultiKeyProof_SignatureEntry) GetKeyIndex() uint32 {
	if x != nil {
		return x.KeyIndex
	}
	return 0
}

func (x *MultiKeyProof_SignatureEntry) GetSignature() *SignatureData {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *MultiKeyProof_SignatureEntry) GetAlgorithm() SignatureAlgorithm {
	if x != nil {
		return x.Algorithm
	}
	return SignatureAlgorithm_SIGNATURE_ALGORITHM_UNKNOWN
}

func (x *MultiKeyProof_SignatureEntry) GetSighashType() SignatureHashType {
	if x != nil {
		return x.SighashType
	}
	return SignatureHashType_SIGHASH_UNKNOWN
}

type ExecutionProof_ExecutionContext struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ========== èº«ä»½å’Œèµ„æºä¿¡æ¯ï¼ˆé€šç”¨ï¼Œå¿…éœ€ï¼‰==========
	CallerIdentity  *IdentityProof `protobuf:"bytes,10,opt,name=caller_identity,json=callerIdentity,proto3" json:"caller_identity,omitempty"`                                     // âœ… è°ƒç”¨è€…èº«ä»½è¯æ˜ï¼ˆå¿…éœ€ï¼‰
	ResourceAddress []byte         `protobuf:"bytes,14,opt,name=resource_address,json=resourceAddress,proto3" json:"resource_address,omitempty"`                                  // âœ… èµ„æºåœ°å€ï¼ˆé€šç”¨ï¼šåˆçº¦/æ¨¡å‹/å…¶ä»–ï¼Œ20å­—èŠ‚ï¼‰
	ExecutionType   ExecutionType  `protobuf:"varint,15,opt,name=execution_type,json=executionType,proto3,enum=pb.blockchain.core.ExecutionType" json:"execution_type,omitempty"` // âœ… æ‰§è¡Œç±»å‹ï¼ˆé€šç”¨ï¼‰
	// ========== æ‰§è¡Œä¿¡æ¯ï¼ˆé€šç”¨ï¼Œéšç§ä¿æŠ¤ï¼‰==========
	InputDataHash  []byte `protobuf:"bytes,1,opt,name=input_data_hash,json=inputDataHash,proto3" json:"input_data_hash,omitempty"`    // âœ… è¾“å…¥æ•°æ®å“ˆå¸Œï¼ˆ32å­—èŠ‚SHA-256ï¼Œä¿æŠ¤éšç§ï¼‰
	OutputDataHash []byte `protobuf:"bytes,2,opt,name=output_data_hash,json=outputDataHash,proto3" json:"output_data_hash,omitempty"` // âœ… è¾“å‡ºæ•°æ®å“ˆå¸Œï¼ˆ32å­—èŠ‚SHA-256ï¼Œä¿æŠ¤éšç§ï¼‰
	// ========== å…ƒæ•°æ®æ‰©å±•ï¼ˆç”¨äºå­˜å‚¨éæ•æ„Ÿä¿¡æ¯æˆ–å“ˆå¸Œï¼‰==========
	Metadata      map[string][]byte `protobuf:"bytes,40,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // âœ… æ‰©å±•å…ƒæ•°æ®ï¼ˆé€šç”¨ï¼Œä¸åŒ…å«æ•æ„ŸåŸå§‹æ•°æ®ï¼‰
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecutionProof_ExecutionContext) Reset() {
	*x = ExecutionProof_ExecutionContext{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecutionProof_ExecutionContext) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecutionProof_ExecutionContext) ProtoMessage() {}

func (x *ExecutionProof_ExecutionContext) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecutionProof_ExecutionContext.ProtoReflect.Descriptor instead.
func (*ExecutionProof_ExecutionContext) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{19, 0}
}

func (x *ExecutionProof_ExecutionContext) GetCallerIdentity() *IdentityProof {
	if x != nil {
		return x.CallerIdentity
	}
	return nil
}

func (x *ExecutionProof_ExecutionContext) GetResourceAddress() []byte {
	if x != nil {
		return x.ResourceAddress
	}
	return nil
}

func (x *ExecutionProof_ExecutionContext) GetExecutionType() ExecutionType {
	if x != nil {
		return x.ExecutionType
	}
	return ExecutionType_EXECUTION_TYPE_UNKNOWN
}

func (x *ExecutionProof_ExecutionContext) GetInputDataHash() []byte {
	if x != nil {
		return x.InputDataHash
	}
	return nil
}

func (x *ExecutionProof_ExecutionContext) GetOutputDataHash() []byte {
	if x != nil {
		return x.OutputDataHash
	}
	return nil
}

func (x *ExecutionProof_ExecutionContext) GetMetadata() map[string][]byte {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type ThresholdProof_ThresholdSignatureShare struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	PartyId         uint32                 `protobuf:"varint,1,opt,name=party_id,json=partyId,proto3" json:"party_id,omitempty"`                        // å‚ä¸æ–¹ID
	SignatureShare  []byte                 `protobuf:"bytes,2,opt,name=signature_share,json=signatureShare,proto3" json:"signature_share,omitempty"`    // é—¨é™ç­¾åä»½é¢
	VerificationKey []byte                 `protobuf:"bytes,3,opt,name=verification_key,json=verificationKey,proto3" json:"verification_key,omitempty"` // ä»½é¢éªŒè¯å¯†é’¥
	PartyProof      []byte                 `protobuf:"bytes,4,opt,name=party_proof,json=partyProof,proto3,oneof" json:"party_proof,omitempty"`          // å¯é€‰çš„å‚ä¸æ–¹èº«ä»½è¯æ˜
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ThresholdProof_ThresholdSignatureShare) Reset() {
	*x = ThresholdProof_ThresholdSignatureShare{}
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ThresholdProof_ThresholdSignatureShare) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThresholdProof_ThresholdSignatureShare) ProtoMessage() {}

func (x *ThresholdProof_ThresholdSignatureShare) ProtoReflect() protoreflect.Message {
	mi := &file_pb_blockchain_block_transaction_transaction_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThresholdProof_ThresholdSignatureShare.ProtoReflect.Descriptor instead.
func (*ThresholdProof_ThresholdSignatureShare) Descriptor() ([]byte, []int) {
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP(), []int{21, 0}
}

func (x *ThresholdProof_ThresholdSignatureShare) GetPartyId() uint32 {
	if x != nil {
		return x.PartyId
	}
	return 0
}

func (x *ThresholdProof_ThresholdSignatureShare) GetSignatureShare() []byte {
	if x != nil {
		return x.SignatureShare
	}
	return nil
}

func (x *ThresholdProof_ThresholdSignatureShare) GetVerificationKey() []byte {
	if x != nil {
		return x.VerificationKey
	}
	return nil
}

func (x *ThresholdProof_ThresholdSignatureShare) GetPartyProof() []byte {
	if x != nil {
		return x.PartyProof
	}
	return nil
}

var File_pb_blockchain_block_transaction_transaction_proto protoreflect.FileDescriptor

const file_pb_blockchain_block_transaction_transaction_proto_rawDesc = "" +
	"\n" +
	"1pb/blockchain/block/transaction/transaction.proto\x12\x12pb.blockchain.core\x1a7pb/blockchain/block/transaction/resource/resource.proto\"\x1c\n" +
	"\x04Hash\x12\x14\n" +
	"\x05value\x18\x01 \x01(\fR\x05value\"\xe0\x01\n" +
	"\aAddress\x12\x19\n" +
	"\braw_hash\x18\x01 \x01(\fR\arawHash\x12'\n" +
	"\x0fencoded_address\x18\x02 \x01(\tR\x0eencodedAddress\x12J\n" +
	"\faddress_type\x18\x03 \x01(\x0e2'.pb.blockchain.core.Address.AddressTypeR\vaddressType\x12!\n" +
	"\fversion_byte\x18\x04 \x01(\rR\vversionByte\"\"\n" +
	"\vAddressType\x12\t\n" +
	"\x05P2PKH\x10\x00\x12\b\n" +
	"\x04P2SH\x10\x01\"\x1f\n" +
	"\aTokenId\x12\x14\n" +
	"\x05value\x18\x01 \x01(\fR\x05value\"%\n" +
	"\rSignatureData\x12\x14\n" +
	"\x05value\x18\x01 \x01(\fR\x05value\"!\n" +
	"\tPublicKey\x12\x14\n" +
	"\x05value\x18\x01 \x01(\fR\x05value\"B\n" +
	"\bOutPoint\x12\x13\n" +
	"\x05tx_id\x18\x01 \x01(\fR\x04txId\x12!\n" +
	"\foutput_index\x18\x02 \x01(\rR\voutputIndex\"\xed\x06\n" +
	"\vTransaction\x12\x18\n" +
	"\aversion\x18\x01 \x01(\rR\aversion\x123\n" +
	"\x06inputs\x18\x02 \x03(\v2\x1b.pb.blockchain.core.TxInputR\x06inputs\x126\n" +
	"\aoutputs\x18\x03 \x03(\v2\x1c.pb.blockchain.core.TxOutputR\aoutputs\x12\x14\n" +
	"\x05nonce\x18\x14 \x01(\x04R\x05nonce\x12-\n" +
	"\x12creation_timestamp\x18\x15 \x01(\x04R\x11creationTimestamp\x12\x19\n" +
	"\bchain_id\x18\x18 \x01(\fR\achainId\x12F\n" +
	"\vtime_window\x18\x16 \x01(\v2#.pb.blockchain.core.TimeBasedWindowH\x00R\n" +
	"timeWindow\x12L\n" +
	"\rheight_window\x18\x17 \x01(\v2%.pb.blockchain.core.HeightBasedWindowH\x00R\fheightWindow\x12A\n" +
	"\vminimum_fee\x18\x1e \x01(\v2\x1e.pb.blockchain.core.MinimumFeeH\x01R\n" +
	"minimumFee\x12P\n" +
	"\x10proportional_fee\x18\x1f \x01(\v2#.pb.blockchain.core.ProportionalFeeH\x01R\x0fproportionalFee\x12M\n" +
	"\fcontract_fee\x18  \x01(\v2(.pb.blockchain.core.ContractExecutionFeeH\x01R\vcontractFee\x12D\n" +
	"\fpriority_fee\x18! \x01(\v2\x1f.pb.blockchain.core.PriorityFeeH\x01R\vpriorityFee\x12H\n" +
	"\bmetadata\x18\x06 \x01(\v2'.pb.blockchain.core.TransactionMetadataH\x02R\bmetadata\x88\x01\x01\x12<\n" +
	"\x1aresource_attachment_hashes\x182 \x03(\fR\x18resourceAttachmentHashesB\x11\n" +
	"\x0fvalidity_windowB\x0f\n" +
	"\rfee_mechanismB\v\n" +
	"\t_metadata\"\xbe\x05\n" +
	"\aTxInput\x12E\n" +
	"\x0fprevious_output\x18\x01 \x01(\v2\x1c.pb.blockchain.core.OutPointR\x0epreviousOutput\x12*\n" +
	"\x11is_reference_only\x18\x02 \x01(\bR\x0fisReferenceOnly\x12\x1a\n" +
	"\bsequence\x18\x03 \x01(\rR\bsequence\x12N\n" +
	"\x10single_key_proof\x18\n" +
	" \x01(\v2\".pb.blockchain.core.SingleKeyProofH\x00R\x0esingleKeyProof\x12K\n" +
	"\x0fmulti_key_proof\x18\v \x01(\v2!.pb.blockchain.core.MultiKeyProofH\x00R\rmultiKeyProof\x12M\n" +
	"\x0fexecution_proof\x18\x11 \x01(\v2\".pb.blockchain.core.ExecutionProofH\x00R\x0eexecutionProof\x12P\n" +
	"\x10delegation_proof\x18\r \x01(\v2#.pb.blockchain.core.DelegationProofH\x00R\x0fdelegationProof\x12M\n" +
	"\x0fthreshold_proof\x18\x0e \x01(\v2\".pb.blockchain.core.ThresholdProofH\x00R\x0ethresholdProof\x12>\n" +
	"\n" +
	"time_proof\x18\x0f \x01(\v2\x1d.pb.blockchain.core.TimeProofH\x00R\ttimeProof\x12D\n" +
	"\fheight_proof\x18\x10 \x01(\v2\x1f.pb.blockchain.core.HeightProofH\x00R\vheightProofB\x11\n" +
	"\x0funlocking_proof\"\xbb\x02\n" +
	"\bTxOutput\x12\x14\n" +
	"\x05owner\x18\x01 \x01(\fR\x05owner\x12S\n" +
	"\x12locking_conditions\x18\x02 \x03(\v2$.pb.blockchain.core.LockingConditionR\x11lockingConditions\x127\n" +
	"\x05asset\x18\n" +
	" \x01(\v2\x1f.pb.blockchain.core.AssetOutputH\x00R\x05asset\x127\n" +
	"\x05state\x18\f \x01(\v2\x1f.pb.blockchain.core.StateOutputH\x00R\x05state\x12@\n" +
	"\bresource\x18\r \x01(\v2\".pb.blockchain.core.ResourceOutputH\x00R\bresourceB\x10\n" +
	"\x0eoutput_content\"\x9a\x04\n" +
	"\x10LockingCondition\x12K\n" +
	"\x0fsingle_key_lock\x18\x01 \x01(\v2!.pb.blockchain.core.SingleKeyLockH\x00R\rsingleKeyLock\x12H\n" +
	"\x0emulti_key_lock\x18\x02 \x01(\v2 .pb.blockchain.core.MultiKeyLockH\x00R\fmultiKeyLock\x12G\n" +
	"\rcontract_lock\x18\x03 \x01(\v2 .pb.blockchain.core.ContractLockH\x00R\fcontractLock\x12M\n" +
	"\x0fdelegation_lock\x18\x04 \x01(\v2\".pb.blockchain.core.DelegationLockH\x00R\x0edelegationLock\x12J\n" +
	"\x0ethreshold_lock\x18\x05 \x01(\v2!.pb.blockchain.core.ThresholdLockH\x00R\rthresholdLock\x12;\n" +
	"\ttime_lock\x18\x06 \x01(\v2\x1c.pb.blockchain.core.TimeLockH\x00R\btimeLock\x12A\n" +
	"\vheight_lock\x18\a \x01(\v2\x1e.pb.blockchain.core.HeightLockH\x00R\n" +
	"heightLockB\v\n" +
	"\tcondition\"\x89\x03\n" +
	"\rSingleKeyLock\x12O\n" +
	"\x13required_public_key\x18\x01 \x01(\v2\x1d.pb.blockchain.core.PublicKeyH\x00R\x11requiredPublicKey\x124\n" +
	"\x15required_address_hash\x18\x02 \x01(\fH\x00R\x13requiredAddressHash\x12U\n" +
	"\x12required_algorithm\x18\x03 \x01(\x0e2&.pb.blockchain.core.SignatureAlgorithmR\x11requiredAlgorithm\x12H\n" +
	"\fsighash_type\x18\x04 \x01(\x0e2%.pb.blockchain.core.SignatureHashTypeR\vsighashType\x12*\n" +
	"\x0ecustom_message\x18\x05 \x01(\fH\x01R\rcustomMessage\x88\x01\x01B\x11\n" +
	"\x0fkey_requirementB\x11\n" +
	"\x0f_custom_message\"\xae\x03\n" +
	"\fMultiKeyLock\x12/\n" +
	"\x13required_signatures\x18\x01 \x01(\rR\x12requiredSignatures\x12F\n" +
	"\x0fauthorized_keys\x18\x02 \x03(\v2\x1d.pb.blockchain.core.PublicKeyR\x0eauthorizedKeys\x12U\n" +
	"\x12required_algorithm\x18\x03 \x01(\x0e2&.pb.blockchain.core.SignatureAlgorithmR\x11requiredAlgorithm\x12<\n" +
	"\x1arequire_ordered_signatures\x18\x04 \x01(\bR\x18requireOrderedSignatures\x12H\n" +
	"\fsighash_type\x18\x05 \x01(\x0e2%.pb.blockchain.core.SignatureHashTypeR\vsighashType\x120\n" +
	"\x11governance_policy\x18\x06 \x01(\tH\x00R\x10governancePolicy\x88\x01\x01B\x14\n" +
	"\x12_governance_policy\"\xb7\x04\n" +
	"\fContractLock\x12)\n" +
	"\x10contract_address\x18\x01 \x01(\fR\x0fcontractAddress\x12'\n" +
	"\x0frequired_method\x18\x02 \x01(\tR\x0erequiredMethod\x12)\n" +
	"\x10parameter_schema\x18\x03 \x01(\tR\x0fparameterSchema\x12-\n" +
	"\x12state_requirements\x18\x04 \x03(\tR\x11stateRequirements\x121\n" +
	"\x15max_execution_time_ms\x18\x05 \x01(\x04R\x12maxExecutionTimeMs\x12.\n" +
	"\x13contract_state_hash\x18\x06 \x01(\fR\x11contractStateHash\x12.\n" +
	"\x10execution_policy\x18\a \x01(\tH\x00R\x0fexecutionPolicy\x88\x01\x01\x12\"\n" +
	"\rmax_total_fee\x18\v \x01(\x04R\vmaxTotalFee\x12%\n" +
	"\x0eparameter_hash\x18\x14 \x01(\fR\rparameterHash\x12'\n" +
	"\x0fallowed_callers\x18\x15 \x03(\tR\x0eallowedCallers\x12?\n" +
	"\x19deadline_duration_seconds\x18\x16 \x01(\x04H\x01R\x17deadlineDurationSeconds\x88\x01\x01B\x13\n" +
	"\x11_execution_policyB\x1c\n" +
	"\x1a_deadline_duration_seconds\"\xee\x02\n" +
	"\x0eDelegationLock\x12%\n" +
	"\x0eoriginal_owner\x18\x01 \x01(\fR\roriginalOwner\x12+\n" +
	"\x11allowed_delegates\x18\x02 \x03(\fR\x10allowedDelegates\x123\n" +
	"\x15authorized_operations\x18\x03 \x03(\tR\x14authorizedOperations\x129\n" +
	"\x16expiry_duration_blocks\x18\x04 \x01(\x04H\x00R\x14expiryDurationBlocks\x88\x01\x01\x125\n" +
	"\x17max_value_per_operation\x18\x05 \x01(\x04R\x14maxValuePerOperation\x120\n" +
	"\x11delegation_policy\x18\x06 \x01(\fH\x01R\x10delegationPolicy\x88\x01\x01B\x19\n" +
	"\x17_expiry_duration_blocksB\x14\n" +
	"\x12_delegation_policy\"\xa1\x02\n" +
	"\rThresholdLock\x12\x1c\n" +
	"\tthreshold\x18\x01 \x01(\rR\tthreshold\x12#\n" +
	"\rtotal_parties\x18\x02 \x01(\rR\ftotalParties\x126\n" +
	"\x17party_verification_keys\x18\x03 \x03(\fR\x15partyVerificationKeys\x12)\n" +
	"\x10signature_scheme\x18\x04 \x01(\tR\x0fsignatureScheme\x12%\n" +
	"\x0esecurity_level\x18\x05 \x01(\rR\rsecurityLevel\x12.\n" +
	"\x10threshold_policy\x18\x06 \x01(\fH\x00R\x0fthresholdPolicy\x88\x01\x01B\x13\n" +
	"\x11_threshold_policy\"\xa6\x02\n" +
	"\bTimeLock\x12)\n" +
	"\x10unlock_timestamp\x18\x01 \x01(\x04R\x0funlockTimestamp\x12A\n" +
	"\tbase_lock\x18\x02 \x01(\v2$.pb.blockchain.core.LockingConditionR\bbaseLock\x12H\n" +
	"\vtime_source\x18\x03 \x01(\x0e2'.pb.blockchain.core.TimeLock.TimeSourceR\n" +
	"timeSource\"b\n" +
	"\n" +
	"TimeSource\x12\x1f\n" +
	"\x1bTIME_SOURCE_BLOCK_TIMESTAMP\x10\x00\x12\x1b\n" +
	"\x17TIME_SOURCE_MEDIAN_TIME\x10\x01\x12\x16\n" +
	"\x12TIME_SOURCE_ORACLE\x10\x02\"\xde\x01\n" +
	"\n" +
	"HeightLock\x12#\n" +
	"\runlock_height\x18\x01 \x01(\x04R\funlockHeight\x12A\n" +
	"\tbase_lock\x18\x02 \x01(\v2$.pb.blockchain.core.LockingConditionR\bbaseLock\x12/\n" +
	"\x13confirmation_blocks\x18\x03 \x01(\rR\x12confirmationBlocks\x12&\n" +
	"\fgrace_blocks\x18\x04 \x01(\x04H\x00R\vgraceBlocks\x88\x01\x01B\x0f\n" +
	"\r_grace_blocks\"\xf8\x02\n" +
	"\x0eSingleKeyProof\x12?\n" +
	"\tsignature\x18\x01 \x01(\v2!.pb.blockchain.core.SignatureDataR\tsignature\x12<\n" +
	"\n" +
	"public_key\x18\x02 \x01(\v2\x1d.pb.blockchain.core.PublicKeyR\tpublicKey\x12D\n" +
	"\talgorithm\x18\x03 \x01(\x0e2&.pb.blockchain.core.SignatureAlgorithmR\talgorithm\x12H\n" +
	"\fsighash_type\x18\x04 \x01(\x0e2%.pb.blockchain.core.SignatureHashTypeR\vsighashType\x12;\n" +
	"\x17custom_message_response\x18\x05 \x01(\fH\x00R\x15customMessageResponse\x88\x01\x01B\x1a\n" +
	"\x18_custom_message_response\"\xe2\x02\n" +
	"\rMultiKeyProof\x12P\n" +
	"\n" +
	"signatures\x18\x01 \x03(\v20.pb.blockchain.core.MultiKeyProof.SignatureEntryR\n" +
	"signatures\x1a\xfe\x01\n" +
	"\x0eSignatureEntry\x12\x1b\n" +
	"\tkey_index\x18\x01 \x01(\rR\bkeyIndex\x12?\n" +
	"\tsignature\x18\x02 \x01(\v2!.pb.blockchain.core.SignatureDataR\tsignature\x12D\n" +
	"\talgorithm\x18\x03 \x01(\x0e2&.pb.blockchain.core.SignatureAlgorithmR\talgorithm\x12H\n" +
	"\fsighash_type\x18\x04 \x01(\x0e2%.pb.blockchain.core.SignatureHashTypeR\vsighashType\"\xb9\x05\n" +
	"\x0eExecutionProof\x122\n" +
	"\x15execution_result_hash\x18\x01 \x01(\fR\x13executionResultHash\x124\n" +
	"\x16state_transition_proof\x18\x02 \x01(\fR\x14stateTransitionProof\x12*\n" +
	"\x11execution_time_ms\x18\x03 \x01(\x04R\x0fexecutionTimeMs\x12M\n" +
	"\acontext\x18\x04 \x01(\v23.pb.blockchain.core.ExecutionProof.ExecutionContextR\acontext\x1a\xc1\x03\n" +
	"\x10ExecutionContext\x12J\n" +
	"\x0fcaller_identity\x18\n" +
	" \x01(\v2!.pb.blockchain.core.IdentityProofR\x0ecallerIdentity\x12)\n" +
	"\x10resource_address\x18\x0e \x01(\fR\x0fresourceAddress\x12H\n" +
	"\x0eexecution_type\x18\x0f \x01(\x0e2!.pb.blockchain.core.ExecutionTypeR\rexecutionType\x12&\n" +
	"\x0finput_data_hash\x18\x01 \x01(\fR\rinputDataHash\x12(\n" +
	"\x10output_data_hash\x18\x02 \x01(\fR\x0eoutputDataHash\x12]\n" +
	"\bmetadata\x18( \x03(\v2A.pb.blockchain.core.ExecutionProof.ExecutionContext.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\x97\x03\n" +
	"\x0fDelegationProof\x12:\n" +
	"\x19delegation_transaction_id\x18\x01 \x01(\fR\x17delegationTransactionId\x126\n" +
	"\x17delegation_output_index\x18\x02 \x01(\rR\x15delegationOutputIndex\x12P\n" +
	"\x12delegate_signature\x18\x03 \x01(\v2!.pb.blockchain.core.SignatureDataR\x11delegateSignature\x12%\n" +
	"\x0eoperation_type\x18\x04 \x01(\tR\roperationType\x12!\n" +
	"\fvalue_amount\x18\x05 \x01(\x04R\vvalueAmount\x12)\n" +
	"\x10delegate_address\x18\x06 \x01(\fR\x0fdelegateAddress\x122\n" +
	"\x12delegation_context\x18\a \x01(\fH\x00R\x11delegationContext\x88\x01\x01B\x15\n" +
	"\x13_delegation_context\"\xff\x02\n" +
	"\x0eThresholdProof\x12R\n" +
	"\x06shares\x18\x01 \x03(\v2:.pb.blockchain.core.ThresholdProof.ThresholdSignatureShareR\x06shares\x12-\n" +
	"\x12combined_signature\x18\x02 \x01(\fR\x11combinedSignature\x12)\n" +
	"\x10signature_scheme\x18\x03 \x01(\tR\x0fsignatureScheme\x1a\xbe\x01\n" +
	"\x17ThresholdSignatureShare\x12\x19\n" +
	"\bparty_id\x18\x01 \x01(\rR\apartyId\x12'\n" +
	"\x0fsignature_share\x18\x02 \x01(\fR\x0esignatureShare\x12)\n" +
	"\x10verification_key\x18\x03 \x01(\fR\x0fverificationKey\x12$\n" +
	"\vparty_proof\x18\x04 \x01(\fH\x00R\n" +
	"partyProof\x88\x01\x01B\x0e\n" +
	"\f_party_proof\"\xc1\x02\n" +
	"\tTimeProof\x12+\n" +
	"\x11current_timestamp\x18\x01 \x01(\x04R\x10currentTimestamp\x12'\n" +
	"\x0ftimestamp_proof\x18\x02 \x01(\fR\x0etimestampProof\x12A\n" +
	"\n" +
	"base_proof\x18\x03 \x01(\v2\".pb.blockchain.core.UnlockingProofR\tbaseProof\x12H\n" +
	"\vtime_source\x18\x04 \x01(\x0e2'.pb.blockchain.core.TimeLock.TimeSourceR\n" +
	"timeSource\x127\n" +
	"\x15time_oracle_signature\x18\x05 \x01(\fH\x00R\x13timeOracleSignature\x88\x01\x01B\x18\n" +
	"\x16_time_oracle_signature\"\xa0\x02\n" +
	"\vHeightProof\x12%\n" +
	"\x0ecurrent_height\x18\x01 \x01(\x04R\rcurrentHeight\x12,\n" +
	"\x12block_header_proof\x18\x02 \x01(\fR\x10blockHeaderProof\x12A\n" +
	"\n" +
	"base_proof\x18\x03 \x01(\v2\".pb.blockchain.core.UnlockingProofR\tbaseProof\x12/\n" +
	"\x13confirmation_blocks\x18\x04 \x01(\rR\x12confirmationBlocks\x121\n" +
	"\x12light_client_proof\x18\x05 \x01(\fH\x00R\x10lightClientProof\x88\x01\x01B\x15\n" +
	"\x13_light_client_proof\"\xa6\x03\n" +
	"\x0eUnlockingProof\x12N\n" +
	"\x10single_key_proof\x18\x01 \x01(\v2\".pb.blockchain.core.SingleKeyProofH\x00R\x0esingleKeyProof\x12K\n" +
	"\x0fmulti_key_proof\x18\x02 \x01(\v2!.pb.blockchain.core.MultiKeyProofH\x00R\rmultiKeyProof\x12M\n" +
	"\x0fexecution_proof\x18\x03 \x01(\v2\".pb.blockchain.core.ExecutionProofH\x00R\x0eexecutionProof\x12P\n" +
	"\x10delegation_proof\x18\x05 \x01(\v2#.pb.blockchain.core.DelegationProofH\x00R\x0fdelegationProof\x12M\n" +
	"\x0fthreshold_proof\x18\x06 \x01(\v2\".pb.blockchain.core.ThresholdProofH\x00R\x0ethresholdProofB\a\n" +
	"\x05proof\"\xb7\x01\n" +
	"\vAssetOutput\x12F\n" +
	"\vnative_coin\x18\x01 \x01(\v2#.pb.blockchain.core.NativeCoinAssetH\x00R\n" +
	"nativeCoin\x12O\n" +
	"\x0econtract_token\x18\x02 \x01(\v2&.pb.blockchain.core.ContractTokenAssetH\x00R\rcontractTokenB\x0f\n" +
	"\rasset_content\")\n" +
	"\x0fNativeCoinAsset\x12\x16\n" +
	"\x06amount\x18\x01 \x01(\tR\x06amount\"\xf2\x02\n" +
	"\x12ContractTokenAsset\x12)\n" +
	"\x10contract_address\x18\x01 \x01(\fR\x0fcontractAddress\x12,\n" +
	"\x11fungible_class_id\x18\n" +
	" \x01(\fH\x00R\x0ffungibleClassId\x12$\n" +
	"\rnft_unique_id\x18\v \x01(\fH\x00R\vnftUniqueId\x12N\n" +
	"\x10semi_fungible_id\x18\f \x01(\v2\".pb.blockchain.core.SemiFungibleIdH\x00R\x0esemiFungibleId\x12\x16\n" +
	"\x06amount\x18\x02 \x01(\tR\x06amount\x12O\n" +
	"\rdisplay_cache\x18\x14 \x01(\v2%.pb.blockchain.core.TokenDisplayCacheH\x01R\fdisplayCache\x88\x01\x01B\x12\n" +
	"\x10token_identifierB\x10\n" +
	"\x0e_display_cache\"L\n" +
	"\x0eSemiFungibleId\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\fR\abatchId\x12\x1f\n" +
	"\vinstance_id\x18\x02 \x01(\x04R\n" +
	"instanceId\"\xb1\x01\n" +
	"\x11TokenDisplayCache\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x16\n" +
	"\x06symbol\x18\x02 \x01(\tR\x06symbol\x12\x1a\n" +
	"\bdecimals\x18\x03 \x01(\rR\bdecimals\x12\x1e\n" +
	"\bicon_uri\x18\x04 \x01(\tH\x00R\aiconUri\x88\x01\x01\x12'\n" +
	"\x0fcache_timestamp\x18\x05 \x01(\x04R\x0ecacheTimestampB\v\n" +
	"\t_icon_uri\"\xb8\x04\n" +
	"\vStateOutput\x12\x19\n" +
	"\bstate_id\x18\x01 \x01(\fR\astateId\x12#\n" +
	"\rstate_version\x18\x02 \x01(\x04R\fstateVersion\x12;\n" +
	"\bzk_proof\x18\x03 \x01(\v2 .pb.blockchain.core.ZKStateProofR\azkProof\x122\n" +
	"\x15execution_result_hash\x18\n" +
	" \x01(\fR\x13executionResultHash\x12/\n" +
	"\x11parent_state_hash\x18\x14 \x01(\fH\x00R\x0fparentStateHash\x88\x01\x01\x125\n" +
	"\x14ttl_duration_seconds\x18\x1e \x01(\x04H\x01R\x12ttlDurationSeconds\x88\x01\x01\x12I\n" +
	"\bmetadata\x18( \x03(\v2-.pb.blockchain.core.StateOutput.MetadataEntryR\bmetadata\x12I\n" +
	"\vzk_metadata\x182 \x01(\v2#.pb.blockchain.core.ZKProofMetadataH\x02R\n" +
	"zkMetadata\x88\x01\x01\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x14\n" +
	"\x12_parent_state_hashB\x17\n" +
	"\x15_ttl_duration_secondsB\x0e\n" +
	"\f_zk_metadata\"\x93\x04\n" +
	"\x0eResourceOutput\x12<\n" +
	"\bresource\x18\x01 \x01(\v2 .pb.blockchain.resource.ResourceR\bresource\x12-\n" +
	"\x12creation_timestamp\x18\n" +
	" \x01(\x04R\x11creationTimestamp\x12)\n" +
	"\x10creation_context\x18\v \x01(\tR\x0fcreationContext\x12]\n" +
	"\x10storage_strategy\x18\x14 \x01(\x0e22.pb.blockchain.core.ResourceOutput.StorageStrategyR\x0fstorageStrategy\x12+\n" +
	"\x11storage_locations\x18\x15 \x03(\fR\x10storageLocations\x12.\n" +
	"\x10expiry_timestamp\x18\x1e \x01(\x04H\x00R\x0fexpiryTimestamp\x88\x01\x01\x12!\n" +
	"\fis_immutable\x18\x1f \x01(\bR\visImmutable\"u\n" +
	"\x0fStorageStrategy\x12&\n" +
	"\"STORAGE_STRATEGY_CONTENT_ADDRESSED\x10\x00\x12\x1b\n" +
	"\x17STORAGE_STRATEGY_HYBRID\x10\x01\x12\x1d\n" +
	"\x19STORAGE_STRATEGY_ON_CHAIN\x10\x02B\x13\n" +
	"\x11_expiry_timestamp\"\xae\x01\n" +
	"\x0fTimeBasedWindow\x125\n" +
	"\x14not_before_timestamp\x18\x01 \x01(\x04H\x00R\x12notBeforeTimestamp\x88\x01\x01\x123\n" +
	"\x13not_after_timestamp\x18\x02 \x01(\x04H\x01R\x11notAfterTimestamp\x88\x01\x01B\x17\n" +
	"\x15_not_before_timestampB\x16\n" +
	"\x14_not_after_timestamp\"\x9e\x01\n" +
	"\x11HeightBasedWindow\x12/\n" +
	"\x11not_before_height\x18\x01 \x01(\x04H\x00R\x0fnotBeforeHeight\x88\x01\x01\x12-\n" +
	"\x10not_after_height\x18\x02 \x01(\x04H\x01R\x0enotAfterHeight\x88\x01\x01B\x14\n" +
	"\x12_not_before_heightB\x13\n" +
	"\x11_not_after_height\"p\n" +
	"\x0eTokenReference\x12#\n" +
	"\fnative_token\x18\x01 \x01(\bH\x00R\vnativeToken\x12+\n" +
	"\x10contract_address\x18\x02 \x01(\fH\x00R\x0fcontractAddressB\f\n" +
	"\n" +
	"token_type\"t\n" +
	"\n" +
	"MinimumFee\x12%\n" +
	"\x0eminimum_amount\x18\x01 \x01(\tR\rminimumAmount\x12?\n" +
	"\tfee_token\x18\x02 \x01(\v2\".pb.blockchain.core.TokenReferenceR\bfeeToken\"\xbc\x01\n" +
	"\x0fProportionalFee\x12*\n" +
	"\x11rate_basis_points\x18\x01 \x01(\rR\x0frateBasisPoints\x12)\n" +
	"\x0emax_fee_amount\x18\x02 \x01(\tH\x00R\fmaxFeeAmount\x88\x01\x01\x12?\n" +
	"\tfee_token\x18\x03 \x01(\v2\".pb.blockchain.core.TokenReferenceR\bfeeTokenB\x11\n" +
	"\x0f_max_fee_amount\"\x97\x01\n" +
	"\x14ContractExecutionFee\x12\x19\n" +
	"\bbase_fee\x18\x01 \x01(\tR\abaseFee\x12#\n" +
	"\rexecution_fee\x18\x02 \x01(\tR\fexecutionFee\x12?\n" +
	"\tfee_token\x18\x04 \x01(\v2\".pb.blockchain.core.TokenReferenceR\bfeeToken\"\x8e\x01\n" +
	"\vPriorityFee\x12\x19\n" +
	"\bbase_fee\x18\x01 \x01(\tR\abaseFee\x12#\n" +
	"\rpriority_rate\x18\x02 \x01(\tR\fpriorityRate\x12?\n" +
	"\tfee_token\x18\x03 \x01(\v2\".pb.blockchain.core.TokenReferenceR\bfeeToken\"\x88\x03\n" +
	"\x13TransactionMetadata\x12\x17\n" +
	"\x04memo\x18\x01 \x01(\tH\x01R\x04memo\x88\x01\x01\x12\x12\n" +
	"\x04tags\x18\x02 \x03(\tR\x04tags\x12!\n" +
	"\vbinary_data\x18\n" +
	" \x01(\fH\x00R\n" +
	"binaryData\x12\x1d\n" +
	"\tjson_data\x18\v \x01(\tH\x00R\bjsonData\x12M\n" +
	"\x0fstructured_data\x18\f \x01(\v2\".pb.blockchain.core.StructuredDataH\x00R\x0estructuredData\x12^\n" +
	"\rcustom_fields\x18\x14 \x03(\v29.pb.blockchain.core.TransactionMetadata.CustomFieldsEntryR\fcustomFields\x1a?\n" +
	"\x11CustomFieldsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01B\t\n" +
	"\apayloadB\a\n" +
	"\x05_memo\"\x8b\x02\n" +
	"\x0eStructuredData\x12F\n" +
	"\x06fields\x18\x01 \x03(\v2..pb.blockchain.core.StructuredData.FieldsEntryR\x06fields\x12*\n" +
	"\x0eschema_version\x18\x02 \x01(\tH\x00R\rschemaVersion\x88\x01\x01\x12&\n" +
	"\fcontent_type\x18\x03 \x01(\tH\x01R\vcontentType\x88\x01\x01\x1a9\n" +
	"\vFieldsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01B\x11\n" +
	"\x0f_schema_versionB\x0f\n" +
	"\r_content_type\"\xda\x02\n" +
	"\rIdentityProof\x12\x1d\n" +
	"\n" +
	"public_key\x18\x01 \x01(\fR\tpublicKey\x12%\n" +
	"\x0ecaller_address\x18\x02 \x01(\fR\rcallerAddress\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\fR\tsignature\x12D\n" +
	"\talgorithm\x18\x04 \x01(\x0e2&.pb.blockchain.core.SignatureAlgorithmR\talgorithm\x12H\n" +
	"\fsighash_type\x18\x05 \x01(\x0e2%.pb.blockchain.core.SignatureHashTypeR\vsighashType\x12\x14\n" +
	"\x05nonce\x18\x06 \x01(\fR\x05nonce\x12\x1c\n" +
	"\ttimestamp\x18\a \x01(\x04R\ttimestamp\x12!\n" +
	"\fcontext_hash\x18\b \x01(\fR\vcontextHash\"\x85\x01\n" +
	"\x12ComputeHashRequest\x12A\n" +
	"\vtransaction\x18\x01 \x01(\v2\x1f.pb.blockchain.core.TransactionR\vtransaction\x12,\n" +
	"\x12include_debug_info\x18\x02 \x01(\bR\x10includeDebugInfo\"\x9a\x01\n" +
	"\x13ComputeHashResponse\x12\x12\n" +
	"\x04hash\x18\x01 \x01(\fR\x04hash\x12\x19\n" +
	"\bis_valid\x18\x02 \x01(\bR\aisValid\x12E\n" +
	"\n" +
	"debug_info\x18\x03 \x01(\v2!.pb.blockchain.core.HashDebugInfoH\x00R\tdebugInfo\x88\x01\x01B\r\n" +
	"\v_debug_info\"}\n" +
	"\x13ValidateHashRequest\x12A\n" +
	"\vtransaction\x18\x01 \x01(\v2\x1f.pb.blockchain.core.TransactionR\vtransaction\x12#\n" +
	"\rexpected_hash\x18\x02 \x01(\fR\fexpectedHash\"\xb7\x01\n" +
	"\x14ValidateHashResponse\x12\x19\n" +
	"\bis_valid\x18\x01 \x01(\bR\aisValid\x12#\n" +
	"\rcomputed_hash\x18\x02 \x01(\fR\fcomputedHash\x12#\n" +
	"\rexpected_hash\x18\x03 \x01(\fR\fexpectedHash\x12(\n" +
	"\rerror_message\x18\x04 \x01(\tH\x00R\ferrorMessage\x88\x01\x01B\x10\n" +
	"\x0e_error_message\"\xf9\x01\n" +
	"\x1bComputeSignatureHashRequest\x12A\n" +
	"\vtransaction\x18\x01 \x01(\v2\x1f.pb.blockchain.core.TransactionR\vtransaction\x12\x1f\n" +
	"\vinput_index\x18\x02 \x01(\rR\n" +
	"inputIndex\x12H\n" +
	"\fsighash_type\x18\x03 \x01(\x0e2%.pb.blockchain.core.SignatureHashTypeR\vsighashType\x12,\n" +
	"\x12include_debug_info\x18\x04 \x01(\bR\x10includeDebugInfo\"\xa3\x01\n" +
	"\x1cComputeSignatureHashResponse\x12\x12\n" +
	"\x04hash\x18\x01 \x01(\fR\x04hash\x12\x19\n" +
	"\bis_valid\x18\x02 \x01(\bR\aisValid\x12E\n" +
	"\n" +
	"debug_info\x18\x03 \x01(\v2!.pb.blockchain.core.HashDebugInfoH\x00R\tdebugInfo\x88\x01\x01B\r\n" +
	"\v_debug_info\"\xf1\x01\n" +
	"\x1cValidateSignatureHashRequest\x12A\n" +
	"\vtransaction\x18\x01 \x01(\v2\x1f.pb.blockchain.core.TransactionR\vtransaction\x12\x1f\n" +
	"\vinput_index\x18\x02 \x01(\rR\n" +
	"inputIndex\x12H\n" +
	"\fsighash_type\x18\x03 \x01(\x0e2%.pb.blockchain.core.SignatureHashTypeR\vsighashType\x12#\n" +
	"\rexpected_hash\x18\x04 \x01(\fR\fexpectedHash\"\xc0\x01\n" +
	"\x1dValidateSignatureHashResponse\x12\x19\n" +
	"\bis_valid\x18\x01 \x01(\bR\aisValid\x12#\n" +
	"\rcomputed_hash\x18\x02 \x01(\fR\fcomputedHash\x12#\n" +
	"\rexpected_hash\x18\x03 \x01(\fR\fexpectedHash\x12(\n" +
	"\rerror_message\x18\x04 \x01(\tH\x00R\ferrorMessage\x88\x01\x01B\x10\n" +
	"\x0e_error_message\"\xfd\x04\n" +
	"\fZKStateProof\x12\x14\n" +
	"\x05proof\x18\x01 \x01(\fR\x05proof\x12#\n" +
	"\rpublic_inputs\x18\x02 \x03(\fR\fpublicInputs\x12%\n" +
	"\x0eproving_scheme\x18\x03 \x01(\tR\rprovingScheme\x12\x14\n" +
	"\x05curve\x18\x04 \x01(\tR\x05curve\x122\n" +
	"\x15verification_key_hash\x18\x05 \x01(\fR\x13verificationKeyHash\x12\x1d\n" +
	"\n" +
	"circuit_id\x18\n" +
	" \x01(\tR\tcircuitId\x12'\n" +
	"\x0fcircuit_version\x18\v \x01(\rR\x0ecircuitVersion\x122\n" +
	"\x12circuit_commitment\x18\f \x01(\fH\x00R\x11circuitCommitment\x88\x01\x01\x12)\n" +
	"\x10constraint_count\x18\x14 \x01(\x04R\x0fconstraintCount\x12<\n" +
	"\x18proof_generation_time_ms\x18\x15 \x01(\x04H\x01R\x15proofGenerationTimeMs\x88\x01\x01\x12c\n" +
	"\x11custom_attributes\x18\x1e \x03(\v26.pb.blockchain.core.ZKStateProof.CustomAttributesEntryR\x10customAttributes\x1aC\n" +
	"\x15CustomAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x15\n" +
	"\x13_circuit_commitmentB\x1b\n" +
	"\x19_proof_generation_time_ms\"\x9d\a\n" +
	"\x0fZKProofMetadata\x12*\n" +
	"\x0eprover_version\x18\x01 \x01(\tH\x00R\rproverVersion\x88\x01\x01\x12.\n" +
	"\x10compiler_version\x18\x02 \x01(\tH\x01R\x0fcompilerVersion\x88\x01\x01\x12-\n" +
	"\x10proof_size_bytes\x18\n" +
	" \x01(\x04H\x02R\x0eproofSizeBytes\x88\x01\x01\x125\n" +
	"\x14verification_time_ms\x18\v \x01(\x04H\x03R\x12verificationTimeMs\x88\x01\x01\x12'\n" +
	"\rsetup_time_ms\x18\f \x01(\x04H\x04R\vsetupTimeMs\x88\x01\x01\x121\n" +
	"\x12memory_usage_bytes\x18\r \x01(\x04H\x05R\x10memoryUsageBytes\x88\x01\x01\x12*\n" +
	"\x0esecurity_level\x18\x14 \x01(\tH\x06R\rsecurityLevel\x88\x01\x01\x12>\n" +
	"\x19trusted_setup_ceremony_id\x18\x15 \x01(\x04H\aR\x16trustedSetupCeremonyId\x88\x01\x01\x127\n" +
	"\x15proof_generation_node\x18\x1e \x01(\tH\bR\x13proofGenerationNode\x88\x01\x01\x12A\n" +
	"\x1aproof_generation_timestamp\x18\x1f \x01(\x04H\tR\x18proofGenerationTimestamp\x88\x01\x01\x12Z\n" +
	"\rcustom_fields\x18( \x03(\v25.pb.blockchain.core.ZKProofMetadata.CustomFieldsEntryR\fcustomFields\x1a?\n" +
	"\x11CustomFieldsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x11\n" +
	"\x0f_prover_versionB\x13\n" +
	"\x11_compiler_versionB\x13\n" +
	"\x11_proof_size_bytesB\x17\n" +
	"\x15_verification_time_msB\x10\n" +
	"\x0e_setup_time_msB\x15\n" +
	"\x13_memory_usage_bytesB\x11\n" +
	"\x0f_security_levelB\x1c\n" +
	"\x1a_trusted_setup_ceremony_idB\x18\n" +
	"\x16_proof_generation_nodeB\x1d\n" +
	"\x1b_proof_generation_timestamp\"\x9e\x02\n" +
	"\rHashDebugInfo\x12'\n" +
	"\x0fcanonical_bytes\x18\x01 \x01(\fR\x0ecanonicalBytes\x12)\n" +
	"\x10canonical_length\x18\x02 \x01(\x04R\x0fcanonicalLength\x12'\n" +
	"\x0fincluded_fields\x18\x03 \x03(\tR\x0eincludedFields\x12'\n" +
	"\x0fexcluded_fields\x18\x04 \x03(\tR\x0eexcludedFields\x121\n" +
	"\x14serialization_method\x18\x05 \x01(\tR\x13serializationMethod\x124\n" +
	"\x16computation_time_nanos\x18\x06 \x01(\x04R\x14computationTimeNanos*e\n" +
	"\rExecutionType\x12\x1a\n" +
	"\x16EXECUTION_TYPE_UNKNOWN\x10\x00\x12\x1b\n" +
	"\x17EXECUTION_TYPE_CONTRACT\x10\x01\x12\x1b\n" +
	"\x17EXECUTION_TYPE_AI_MODEL\x10\x02*\xdb\x01\n" +
	"\x11SignatureHashType\x12\x13\n" +
	"\x0fSIGHASH_UNKNOWN\x10\x00\x12\x0f\n" +
	"\vSIGHASH_ALL\x10\x01\x12\x10\n" +
	"\fSIGHASH_NONE\x10\x02\x12\x12\n" +
	"\x0eSIGHASH_SINGLE\x10\x03\x12\x19\n" +
	"\x14SIGHASH_ANYONECANPAY\x10\x80\x01\x12\x1d\n" +
	"\x18SIGHASH_ALL_ANYONECANPAY\x10\x81\x01\x12\x1e\n" +
	"\x19SIGHASH_NONE_ANYONECANPAY\x10\x82\x01\x12 \n" +
	"\x1bSIGHASH_SINGLE_ANYONECANPAY\x10\x83\x01*\xea\x01\n" +
	"\x12SignatureAlgorithm\x12\x1f\n" +
	"\x1bSIGNATURE_ALGORITHM_UNKNOWN\x10\x00\x12'\n" +
	"#SIGNATURE_ALGORITHM_ECDSA_SECP256K1\x10\x01\x12'\n" +
	"#SIGNATURE_ALGORITHM_ECDSA_SECP256R1\x10\x02\x12\x1f\n" +
	"\x1bSIGNATURE_ALGORITHM_ED25519\x10\x03\x12\x1f\n" +
	"\x1bSIGNATURE_ALGORITHM_SCHNORR\x10\x04\x12\x1f\n" +
	"\x1bSIGNATURE_ALGORITHM_RSA_PSS\x10\x052\xd4\x03\n" +
	"\x16TransactionHashService\x12^\n" +
	"\vComputeHash\x12&.pb.blockchain.core.ComputeHashRequest\x1a'.pb.blockchain.core.ComputeHashResponse\x12a\n" +
	"\fValidateHash\x12'.pb.blockchain.core.ValidateHashRequest\x1a(.pb.blockchain.core.ValidateHashResponse\x12y\n" +
	"\x14ComputeSignatureHash\x12/.pb.blockchain.core.ComputeSignatureHashRequest\x1a0.pb.blockchain.core.ComputeSignatureHashResponse\x12|\n" +
	"\x15ValidateSignatureHash\x120.pb.blockchain.core.ValidateSignatureHashRequest\x1a1.pb.blockchain.core.ValidateSignatureHashResponseB6Z4github.com/weisyn/v1/pb/blockchain/block/transactionb\x06proto3"

var (
	file_pb_blockchain_block_transaction_transaction_proto_rawDescOnce sync.Once
	file_pb_blockchain_block_transaction_transaction_proto_rawDescData []byte
)

func file_pb_blockchain_block_transaction_transaction_proto_rawDescGZIP() []byte {
	file_pb_blockchain_block_transaction_transaction_proto_rawDescOnce.Do(func() {
		file_pb_blockchain_block_transaction_transaction_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_pb_blockchain_block_transaction_transaction_proto_rawDesc), len(file_pb_blockchain_block_transaction_transaction_proto_rawDesc)))
	})
	return file_pb_blockchain_block_transaction_transaction_proto_rawDescData
}

var file_pb_blockchain_block_transaction_transaction_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_pb_blockchain_block_transaction_transaction_proto_msgTypes = make([]protoimpl.MessageInfo, 62)
var file_pb_blockchain_block_transaction_transaction_proto_goTypes = []any{
	(ExecutionType)(0),                             // 0: pb.blockchain.core.ExecutionType
	(SignatureHashType)(0),                         // 1: pb.blockchain.core.SignatureHashType
	(SignatureAlgorithm)(0),                        // 2: pb.blockchain.core.SignatureAlgorithm
	(Address_AddressType)(0),                       // 3: pb.blockchain.core.Address.AddressType
	(TimeLock_TimeSource)(0),                       // 4: pb.blockchain.core.TimeLock.TimeSource
	(ResourceOutput_StorageStrategy)(0),            // 5: pb.blockchain.core.ResourceOutput.StorageStrategy
	(*Hash)(nil),                                   // 6: pb.blockchain.core.Hash
	(*Address)(nil),                                // 7: pb.blockchain.core.Address
	(*TokenId)(nil),                                // 8: pb.blockchain.core.TokenId
	(*SignatureData)(nil),                          // 9: pb.blockchain.core.SignatureData
	(*PublicKey)(nil),                              // 10: pb.blockchain.core.PublicKey
	(*OutPoint)(nil),                               // 11: pb.blockchain.core.OutPoint
	(*Transaction)(nil),                            // 12: pb.blockchain.core.Transaction
	(*TxInput)(nil),                                // 13: pb.blockchain.core.TxInput
	(*TxOutput)(nil),                               // 14: pb.blockchain.core.TxOutput
	(*LockingCondition)(nil),                       // 15: pb.blockchain.core.LockingCondition
	(*SingleKeyLock)(nil),                          // 16: pb.blockchain.core.SingleKeyLock
	(*MultiKeyLock)(nil),                           // 17: pb.blockchain.core.MultiKeyLock
	(*ContractLock)(nil),                           // 18: pb.blockchain.core.ContractLock
	(*DelegationLock)(nil),                         // 19: pb.blockchain.core.DelegationLock
	(*ThresholdLock)(nil),                          // 20: pb.blockchain.core.ThresholdLock
	(*TimeLock)(nil),                               // 21: pb.blockchain.core.TimeLock
	(*HeightLock)(nil),                             // 22: pb.blockchain.core.HeightLock
	(*SingleKeyProof)(nil),                         // 23: pb.blockchain.core.SingleKeyProof
	(*MultiKeyProof)(nil),                          // 24: pb.blockchain.core.MultiKeyProof
	(*ExecutionProof)(nil),                         // 25: pb.blockchain.core.ExecutionProof
	(*DelegationProof)(nil),                        // 26: pb.blockchain.core.DelegationProof
	(*ThresholdProof)(nil),                         // 27: pb.blockchain.core.ThresholdProof
	(*TimeProof)(nil),                              // 28: pb.blockchain.core.TimeProof
	(*HeightProof)(nil),                            // 29: pb.blockchain.core.HeightProof
	(*UnlockingProof)(nil),                         // 30: pb.blockchain.core.UnlockingProof
	(*AssetOutput)(nil),                            // 31: pb.blockchain.core.AssetOutput
	(*NativeCoinAsset)(nil),                        // 32: pb.blockchain.core.NativeCoinAsset
	(*ContractTokenAsset)(nil),                     // 33: pb.blockchain.core.ContractTokenAsset
	(*SemiFungibleId)(nil),                         // 34: pb.blockchain.core.SemiFungibleId
	(*TokenDisplayCache)(nil),                      // 35: pb.blockchain.core.TokenDisplayCache
	(*StateOutput)(nil),                            // 36: pb.blockchain.core.StateOutput
	(*ResourceOutput)(nil),                         // 37: pb.blockchain.core.ResourceOutput
	(*TimeBasedWindow)(nil),                        // 38: pb.blockchain.core.TimeBasedWindow
	(*HeightBasedWindow)(nil),                      // 39: pb.blockchain.core.HeightBasedWindow
	(*TokenReference)(nil),                         // 40: pb.blockchain.core.TokenReference
	(*MinimumFee)(nil),                             // 41: pb.blockchain.core.MinimumFee
	(*ProportionalFee)(nil),                        // 42: pb.blockchain.core.ProportionalFee
	(*ContractExecutionFee)(nil),                   // 43: pb.blockchain.core.ContractExecutionFee
	(*PriorityFee)(nil),                            // 44: pb.blockchain.core.PriorityFee
	(*TransactionMetadata)(nil),                    // 45: pb.blockchain.core.TransactionMetadata
	(*StructuredData)(nil),                         // 46: pb.blockchain.core.StructuredData
	(*IdentityProof)(nil),                          // 47: pb.blockchain.core.IdentityProof
	(*ComputeHashRequest)(nil),                     // 48: pb.blockchain.core.ComputeHashRequest
	(*ComputeHashResponse)(nil),                    // 49: pb.blockchain.core.ComputeHashResponse
	(*ValidateHashRequest)(nil),                    // 50: pb.blockchain.core.ValidateHashRequest
	(*ValidateHashResponse)(nil),                   // 51: pb.blockchain.core.ValidateHashResponse
	(*ComputeSignatureHashRequest)(nil),            // 52: pb.blockchain.core.ComputeSignatureHashRequest
	(*ComputeSignatureHashResponse)(nil),           // 53: pb.blockchain.core.ComputeSignatureHashResponse
	(*ValidateSignatureHashRequest)(nil),           // 54: pb.blockchain.core.ValidateSignatureHashRequest
	(*ValidateSignatureHashResponse)(nil),          // 55: pb.blockchain.core.ValidateSignatureHashResponse
	(*ZKStateProof)(nil),                           // 56: pb.blockchain.core.ZKStateProof
	(*ZKProofMetadata)(nil),                        // 57: pb.blockchain.core.ZKProofMetadata
	(*HashDebugInfo)(nil),                          // 58: pb.blockchain.core.HashDebugInfo
	(*MultiKeyProof_SignatureEntry)(nil),           // 59: pb.blockchain.core.MultiKeyProof.SignatureEntry
	(*ExecutionProof_ExecutionContext)(nil),        // 60: pb.blockchain.core.ExecutionProof.ExecutionContext
	nil,                                            // 61: pb.blockchain.core.ExecutionProof.ExecutionContext.MetadataEntry
	(*ThresholdProof_ThresholdSignatureShare)(nil), // 62: pb.blockchain.core.ThresholdProof.ThresholdSignatureShare
	nil,                       // 63: pb.blockchain.core.StateOutput.MetadataEntry
	nil,                       // 64: pb.blockchain.core.TransactionMetadata.CustomFieldsEntry
	nil,                       // 65: pb.blockchain.core.StructuredData.FieldsEntry
	nil,                       // 66: pb.blockchain.core.ZKStateProof.CustomAttributesEntry
	nil,                       // 67: pb.blockchain.core.ZKProofMetadata.CustomFieldsEntry
	(*resource.Resource)(nil), // 68: pb.blockchain.resource.Resource
}
var file_pb_blockchain_block_transaction_transaction_proto_depIdxs = []int32{
	3,  // 0: pb.blockchain.core.Address.address_type:type_name -> pb.blockchain.core.Address.AddressType
	13, // 1: pb.blockchain.core.Transaction.inputs:type_name -> pb.blockchain.core.TxInput
	14, // 2: pb.blockchain.core.Transaction.outputs:type_name -> pb.blockchain.core.TxOutput
	38, // 3: pb.blockchain.core.Transaction.time_window:type_name -> pb.blockchain.core.TimeBasedWindow
	39, // 4: pb.blockchain.core.Transaction.height_window:type_name -> pb.blockchain.core.HeightBasedWindow
	41, // 5: pb.blockchain.core.Transaction.minimum_fee:type_name -> pb.blockchain.core.MinimumFee
	42, // 6: pb.blockchain.core.Transaction.proportional_fee:type_name -> pb.blockchain.core.ProportionalFee
	43, // 7: pb.blockchain.core.Transaction.contract_fee:type_name -> pb.blockchain.core.ContractExecutionFee
	44, // 8: pb.blockchain.core.Transaction.priority_fee:type_name -> pb.blockchain.core.PriorityFee
	45, // 9: pb.blockchain.core.Transaction.metadata:type_name -> pb.blockchain.core.TransactionMetadata
	11, // 10: pb.blockchain.core.TxInput.previous_output:type_name -> pb.blockchain.core.OutPoint
	23, // 11: pb.blockchain.core.TxInput.single_key_proof:type_name -> pb.blockchain.core.SingleKeyProof
	24, // 12: pb.blockchain.core.TxInput.multi_key_proof:type_name -> pb.blockchain.core.MultiKeyProof
	25, // 13: pb.blockchain.core.TxInput.execution_proof:type_name -> pb.blockchain.core.ExecutionProof
	26, // 14: pb.blockchain.core.TxInput.delegation_proof:type_name -> pb.blockchain.core.DelegationProof
	27, // 15: pb.blockchain.core.TxInput.threshold_proof:type_name -> pb.blockchain.core.ThresholdProof
	28, // 16: pb.blockchain.core.TxInput.time_proof:type_name -> pb.blockchain.core.TimeProof
	29, // 17: pb.blockchain.core.TxInput.height_proof:type_name -> pb.blockchain.core.HeightProof
	15, // 18: pb.blockchain.core.TxOutput.locking_conditions:type_name -> pb.blockchain.core.LockingCondition
	31, // 19: pb.blockchain.core.TxOutput.asset:type_name -> pb.blockchain.core.AssetOutput
	36, // 20: pb.blockchain.core.TxOutput.state:type_name -> pb.blockchain.core.StateOutput
	37, // 21: pb.blockchain.core.TxOutput.resource:type_name -> pb.blockchain.core.ResourceOutput
	16, // 22: pb.blockchain.core.LockingCondition.single_key_lock:type_name -> pb.blockchain.core.SingleKeyLock
	17, // 23: pb.blockchain.core.LockingCondition.multi_key_lock:type_name -> pb.blockchain.core.MultiKeyLock
	18, // 24: pb.blockchain.core.LockingCondition.contract_lock:type_name -> pb.blockchain.core.ContractLock
	19, // 25: pb.blockchain.core.LockingCondition.delegation_lock:type_name -> pb.blockchain.core.DelegationLock
	20, // 26: pb.blockchain.core.LockingCondition.threshold_lock:type_name -> pb.blockchain.core.ThresholdLock
	21, // 27: pb.blockchain.core.LockingCondition.time_lock:type_name -> pb.blockchain.core.TimeLock
	22, // 28: pb.blockchain.core.LockingCondition.height_lock:type_name -> pb.blockchain.core.HeightLock
	10, // 29: pb.blockchain.core.SingleKeyLock.required_public_key:type_name -> pb.blockchain.core.PublicKey
	2,  // 30: pb.blockchain.core.SingleKeyLock.required_algorithm:type_name -> pb.blockchain.core.SignatureAlgorithm
	1,  // 31: pb.blockchain.core.SingleKeyLock.sighash_type:type_name -> pb.blockchain.core.SignatureHashType
	10, // 32: pb.blockchain.core.MultiKeyLock.authorized_keys:type_name -> pb.blockchain.core.PublicKey
	2,  // 33: pb.blockchain.core.MultiKeyLock.required_algorithm:type_name -> pb.blockchain.core.SignatureAlgorithm
	1,  // 34: pb.blockchain.core.MultiKeyLock.sighash_type:type_name -> pb.blockchain.core.SignatureHashType
	15, // 35: pb.blockchain.core.TimeLock.base_lock:type_name -> pb.blockchain.core.LockingCondition
	4,  // 36: pb.blockchain.core.TimeLock.time_source:type_name -> pb.blockchain.core.TimeLock.TimeSource
	15, // 37: pb.blockchain.core.HeightLock.base_lock:type_name -> pb.blockchain.core.LockingCondition
	9,  // 38: pb.blockchain.core.SingleKeyProof.signature:type_name -> pb.blockchain.core.SignatureData
	10, // 39: pb.blockchain.core.SingleKeyProof.public_key:type_name -> pb.blockchain.core.PublicKey
	2,  // 40: pb.blockchain.core.SingleKeyProof.algorithm:type_name -> pb.blockchain.core.SignatureAlgorithm
	1,  // 41: pb.blockchain.core.SingleKeyProof.sighash_type:type_name -> pb.blockchain.core.SignatureHashType
	59, // 42: pb.blockchain.core.MultiKeyProof.signatures:type_name -> pb.blockchain.core.MultiKeyProof.SignatureEntry
	60, // 43: pb.blockchain.core.ExecutionProof.context:type_name -> pb.blockchain.core.ExecutionProof.ExecutionContext
	9,  // 44: pb.blockchain.core.DelegationProof.delegate_signature:type_name -> pb.blockchain.core.SignatureData
	62, // 45: pb.blockchain.core.ThresholdProof.shares:type_name -> pb.blockchain.core.ThresholdProof.ThresholdSignatureShare
	30, // 46: pb.blockchain.core.TimeProof.base_proof:type_name -> pb.blockchain.core.UnlockingProof
	4,  // 47: pb.blockchain.core.TimeProof.time_source:type_name -> pb.blockchain.core.TimeLock.TimeSource
	30, // 48: pb.blockchain.core.HeightProof.base_proof:type_name -> pb.blockchain.core.UnlockingProof
	23, // 49: pb.blockchain.core.UnlockingProof.single_key_proof:type_name -> pb.blockchain.core.SingleKeyProof
	24, // 50: pb.blockchain.core.UnlockingProof.multi_key_proof:type_name -> pb.blockchain.core.MultiKeyProof
	25, // 51: pb.blockchain.core.UnlockingProof.execution_proof:type_name -> pb.blockchain.core.ExecutionProof
	26, // 52: pb.blockchain.core.UnlockingProof.delegation_proof:type_name -> pb.blockchain.core.DelegationProof
	27, // 53: pb.blockchain.core.UnlockingProof.threshold_proof:type_name -> pb.blockchain.core.ThresholdProof
	32, // 54: pb.blockchain.core.AssetOutput.native_coin:type_name -> pb.blockchain.core.NativeCoinAsset
	33, // 55: pb.blockchain.core.AssetOutput.contract_token:type_name -> pb.blockchain.core.ContractTokenAsset
	34, // 56: pb.blockchain.core.ContractTokenAsset.semi_fungible_id:type_name -> pb.blockchain.core.SemiFungibleId
	35, // 57: pb.blockchain.core.ContractTokenAsset.display_cache:type_name -> pb.blockchain.core.TokenDisplayCache
	56, // 58: pb.blockchain.core.StateOutput.zk_proof:type_name -> pb.blockchain.core.ZKStateProof
	63, // 59: pb.blockchain.core.StateOutput.metadata:type_name -> pb.blockchain.core.StateOutput.MetadataEntry
	57, // 60: pb.blockchain.core.StateOutput.zk_metadata:type_name -> pb.blockchain.core.ZKProofMetadata
	68, // 61: pb.blockchain.core.ResourceOutput.resource:type_name -> pb.blockchain.resource.Resource
	5,  // 62: pb.blockchain.core.ResourceOutput.storage_strategy:type_name -> pb.blockchain.core.ResourceOutput.StorageStrategy
	40, // 63: pb.blockchain.core.MinimumFee.fee_token:type_name -> pb.blockchain.core.TokenReference
	40, // 64: pb.blockchain.core.ProportionalFee.fee_token:type_name -> pb.blockchain.core.TokenReference
	40, // 65: pb.blockchain.core.ContractExecutionFee.fee_token:type_name -> pb.blockchain.core.TokenReference
	40, // 66: pb.blockchain.core.PriorityFee.fee_token:type_name -> pb.blockchain.core.TokenReference
	46, // 67: pb.blockchain.core.TransactionMetadata.structured_data:type_name -> pb.blockchain.core.StructuredData
	64, // 68: pb.blockchain.core.TransactionMetadata.custom_fields:type_name -> pb.blockchain.core.TransactionMetadata.CustomFieldsEntry
	65, // 69: pb.blockchain.core.StructuredData.fields:type_name -> pb.blockchain.core.StructuredData.FieldsEntry
	2,  // 70: pb.blockchain.core.IdentityProof.algorithm:type_name -> pb.blockchain.core.SignatureAlgorithm
	1,  // 71: pb.blockchain.core.IdentityProof.sighash_type:type_name -> pb.blockchain.core.SignatureHashType
	12, // 72: pb.blockchain.core.ComputeHashRequest.transaction:type_name -> pb.blockchain.core.Transaction
	58, // 73: pb.blockchain.core.ComputeHashResponse.debug_info:type_name -> pb.blockchain.core.HashDebugInfo
	12, // 74: pb.blockchain.core.ValidateHashRequest.transaction:type_name -> pb.blockchain.core.Transaction
	12, // 75: pb.blockchain.core.ComputeSignatureHashRequest.transaction:type_name -> pb.blockchain.core.Transaction
	1,  // 76: pb.blockchain.core.ComputeSignatureHashRequest.sighash_type:type_name -> pb.blockchain.core.SignatureHashType
	58, // 77: pb.blockchain.core.ComputeSignatureHashResponse.debug_info:type_name -> pb.blockchain.core.HashDebugInfo
	12, // 78: pb.blockchain.core.ValidateSignatureHashRequest.transaction:type_name -> pb.blockchain.core.Transaction
	1,  // 79: pb.blockchain.core.ValidateSignatureHashRequest.sighash_type:type_name -> pb.blockchain.core.SignatureHashType
	66, // 80: pb.blockchain.core.ZKStateProof.custom_attributes:type_name -> pb.blockchain.core.ZKStateProof.CustomAttributesEntry
	67, // 81: pb.blockchain.core.ZKProofMetadata.custom_fields:type_name -> pb.blockchain.core.ZKProofMetadata.CustomFieldsEntry
	9,  // 82: pb.blockchain.core.MultiKeyProof.SignatureEntry.signature:type_name -> pb.blockchain.core.SignatureData
	2,  // 83: pb.blockchain.core.MultiKeyProof.SignatureEntry.algorithm:type_name -> pb.blockchain.core.SignatureAlgorithm
	1,  // 84: pb.blockchain.core.MultiKeyProof.SignatureEntry.sighash_type:type_name -> pb.blockchain.core.SignatureHashType
	47, // 85: pb.blockchain.core.ExecutionProof.ExecutionContext.caller_identity:type_name -> pb.blockchain.core.IdentityProof
	0,  // 86: pb.blockchain.core.ExecutionProof.ExecutionContext.execution_type:type_name -> pb.blockchain.core.ExecutionType
	61, // 87: pb.blockchain.core.ExecutionProof.ExecutionContext.metadata:type_name -> pb.blockchain.core.ExecutionProof.ExecutionContext.MetadataEntry
	48, // 88: pb.blockchain.core.TransactionHashService.ComputeHash:input_type -> pb.blockchain.core.ComputeHashRequest
	50, // 89: pb.blockchain.core.TransactionHashService.ValidateHash:input_type -> pb.blockchain.core.ValidateHashRequest
	52, // 90: pb.blockchain.core.TransactionHashService.ComputeSignatureHash:input_type -> pb.blockchain.core.ComputeSignatureHashRequest
	54, // 91: pb.blockchain.core.TransactionHashService.ValidateSignatureHash:input_type -> pb.blockchain.core.ValidateSignatureHashRequest
	49, // 92: pb.blockchain.core.TransactionHashService.ComputeHash:output_type -> pb.blockchain.core.ComputeHashResponse
	51, // 93: pb.blockchain.core.TransactionHashService.ValidateHash:output_type -> pb.blockchain.core.ValidateHashResponse
	53, // 94: pb.blockchain.core.TransactionHashService.ComputeSignatureHash:output_type -> pb.blockchain.core.ComputeSignatureHashResponse
	55, // 95: pb.blockchain.core.TransactionHashService.ValidateSignatureHash:output_type -> pb.blockchain.core.ValidateSignatureHashResponse
	92, // [92:96] is the sub-list for method output_type
	88, // [88:92] is the sub-list for method input_type
	88, // [88:88] is the sub-list for extension type_name
	88, // [88:88] is the sub-list for extension extendee
	0,  // [0:88] is the sub-list for field type_name
}

func init() { file_pb_blockchain_block_transaction_transaction_proto_init() }
func file_pb_blockchain_block_transaction_transaction_proto_init() {
	if File_pb_blockchain_block_transaction_transaction_proto != nil {
		return
	}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[6].OneofWrappers = []any{
		(*Transaction_TimeWindow)(nil),
		(*Transaction_HeightWindow)(nil),
		(*Transaction_MinimumFee)(nil),
		(*Transaction_ProportionalFee)(nil),
		(*Transaction_ContractFee)(nil),
		(*Transaction_PriorityFee)(nil),
	}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[7].OneofWrappers = []any{
		(*TxInput_SingleKeyProof)(nil),
		(*TxInput_MultiKeyProof)(nil),
		(*TxInput_ExecutionProof)(nil),
		(*TxInput_DelegationProof)(nil),
		(*TxInput_ThresholdProof)(nil),
		(*TxInput_TimeProof)(nil),
		(*TxInput_HeightProof)(nil),
	}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[8].OneofWrappers = []any{
		(*TxOutput_Asset)(nil),
		(*TxOutput_State)(nil),
		(*TxOutput_Resource)(nil),
	}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[9].OneofWrappers = []any{
		(*LockingCondition_SingleKeyLock)(nil),
		(*LockingCondition_MultiKeyLock)(nil),
		(*LockingCondition_ContractLock)(nil),
		(*LockingCondition_DelegationLock)(nil),
		(*LockingCondition_ThresholdLock)(nil),
		(*LockingCondition_TimeLock)(nil),
		(*LockingCondition_HeightLock)(nil),
	}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[10].OneofWrappers = []any{
		(*SingleKeyLock_RequiredPublicKey)(nil),
		(*SingleKeyLock_RequiredAddressHash)(nil),
	}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[11].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[12].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[13].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[14].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[16].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[17].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[20].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[22].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[23].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[24].OneofWrappers = []any{
		(*UnlockingProof_SingleKeyProof)(nil),
		(*UnlockingProof_MultiKeyProof)(nil),
		(*UnlockingProof_ExecutionProof)(nil),
		(*UnlockingProof_DelegationProof)(nil),
		(*UnlockingProof_ThresholdProof)(nil),
	}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[25].OneofWrappers = []any{
		(*AssetOutput_NativeCoin)(nil),
		(*AssetOutput_ContractToken)(nil),
	}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[27].OneofWrappers = []any{
		(*ContractTokenAsset_FungibleClassId)(nil),
		(*ContractTokenAsset_NftUniqueId)(nil),
		(*ContractTokenAsset_SemiFungibleId)(nil),
	}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[29].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[30].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[31].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[32].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[33].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[34].OneofWrappers = []any{
		(*TokenReference_NativeToken)(nil),
		(*TokenReference_ContractAddress)(nil),
	}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[36].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[39].OneofWrappers = []any{
		(*TransactionMetadata_BinaryData)(nil),
		(*TransactionMetadata_JsonData)(nil),
		(*TransactionMetadata_StructuredData)(nil),
	}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[40].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[43].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[45].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[47].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[49].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[50].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[51].OneofWrappers = []any{}
	file_pb_blockchain_block_transaction_transaction_proto_msgTypes[56].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_pb_blockchain_block_transaction_transaction_proto_rawDesc), len(file_pb_blockchain_block_transaction_transaction_proto_rawDesc)),
			NumEnums:      6,
			NumMessages:   62,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_pb_blockchain_block_transaction_transaction_proto_goTypes,
		DependencyIndexes: file_pb_blockchain_block_transaction_transaction_proto_depIdxs,
		EnumInfos:         file_pb_blockchain_block_transaction_transaction_proto_enumTypes,
		MessageInfos:      file_pb_blockchain_block_transaction_transaction_proto_msgTypes,
	}.Build()
	File_pb_blockchain_block_transaction_transaction_proto = out.File
	file_pb_blockchain_block_transaction_transaction_proto_goTypes = nil
	file_pb_blockchain_block_transaction_transaction_proto_depIdxs = nil
}
