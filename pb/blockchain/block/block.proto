syntax = "proto3";
package pb.blockchain.core;

option go_package = "github.com/weisyn/v1/pb/blockchain/block";

// ==================== 文件说明 ====================
/**
 * block.proto - 区块链区块数据结构定义
 * 
 * 本文件定义了区块链系统的核心数据结构 - 区块，主要包含：
 * - 区块头(BlockHeader): 存储元数据和各类哈希根
 * - 区块体(BlockBody): 包含交易列表
 * 
 * 在区块链中，区块扮演着至关重要的角色：
 * - 持久化交易记录并建立共识时间线
 * - 通过merkle_root和state_root维护交易与状态的一致性
 * - 通过区块头维护区块链状态和共识信息
 * 
 * +------------------+      +------------------+      +------------------+
 * |  上一个区块 N-1   |----->|    当前区块 N     |----->|  下一个区块 N+1   |
 * +------------------+      +------------------+      +------------------+
 *                                    |
 *                                    v
 * +----------------------------------------------------------------------+
 * |                               区块头                                  |
 * | • 链接信息(version, previous_hash, height)                            |
 * | • 共识数据(timestamp, nonce, difficulty)                               |
 * | • 状态摘要(merkle_root, state_root)                                   |
 * +----------------------------------------------------------------------+
 *                                    |
 *                                    v
 * +----------------------------------------------------------------------+
 * |                               区块体                                  |
 * | • 交易列表(转账交易、文件部署交易、资源调用交易等)                        |
 * +----------------------------------------------------------------------+
 */

import "pb/blockchain/block/transaction/transaction.proto";

// ==================== 区块结构 ====================
/**
 * 区块在链中的位置与关系:
 * 
 * +----------------+      +----------------+      +----------------+
 * |   区块 N-1     |----->|     区块 N     |----->|   区块 N+1     |
 * +----------------+      +----------------+      +----------------+
 *                                |
 *                                v
 *                         +----------------+
 *                         |    区块头      |
 *                         |    区块体      |
 *                         +----------------+
 *
 * 区块生命周期与状态:
 * 
 * +----------------+      +----------------+      +----------------+      +----------------+
 * |   提议/创建     |----->|    验证/共识    |----->|   提交/确认     |----->|   最终性/归档   |
 * +----------------+      +----------------+      +----------------+      +----------------+
 *        |                       |                       |                       |
 *        v                       v                       v                       v
 * +----------------+      +----------------+      +----------------+      +----------------+
 * | • 打包交易      |      | • 验证区块头    |      | • 写入存储      |      | • 确认最终性    |
 * | • 执行交易      |      | • 验证交易      |      | • 应用状态变更  |      | • 存档处理      |
 * | • 计算状态根    |      | • 共识投票      |      | • 更新全局状态   |      | • 修剪旧数据    |
 * +----------------+      +----------------+      +----------------+      +----------------+
 *
 * 区块结构与状态根关系:
 * 
 * +-------------------------------+
 * |           区块 N              |
 * |-------------------------------|
 * | 区块头:                       |
 * | • merkle_root ────────┐      |
 * | • state_root ──────┐  |      |
 * |                    |  |      |
 * | 区块体:            |  |      |
 * | • 交易列表         |  |      |
 * +-------------------─┼─────────+
 *                      |
 * +-------------------─┼─────────+
 * | 状态数据:          |         |
 * | • 交易执行后的      |         |
 * |   全局状态变更     |         |
 * |                    |         |
 * | 计算得到: ─────────┘         |
 * | state_root                   |
 * +-------------------------------+
 */
message Block {
  // 区块头
  BlockHeader header = 1;  // 区块头，由共识引擎生成，包含元数据和各种哈希根
  // 区块体
  BlockBody body = 2;      // 区块体，由交易池收集交易并组织生成，包含实际交易数据
}

// ==================== 区块头 ====================
/**
 * 区块头字段分组:
 * 
 * +--------------------------------------+
 * |              区块头                  |
 * +--------------------------------------+
 * | 网络标识        | Merkle验证          |
 * |----------------|-------------------|
 * | chain_id       | merkle_root       |
 * |                | state_root        |
 * +--------------------------------------+
 * | 基础链接        | 共识机制            |
 * |----------------|-------------------|
 * | version        | nonce             |
 * | previous_hash  | difficulty        |
 * | timestamp      |                   |
 * | height         |                   |
 * +--------------------------------------+
 *
 * 区块头字段用途与组合场景:
 * 
 * 1. 网络安全与身份验证（最重要）:
 *    - chain_id: 防止跨链重放攻击，确保区块只在指定链上有效
 * 
 * 2. 区块链接与定位:
 *    - version + previous_hash + height: 确定区块在链中的位置
 *    - timestamp: 提供区块时间戳，用于排序和共识
 *    
 * 3. Merkle根验证:
 *    - merkle_root: 验证区块中交易数据的完整性
 *    - state_root: 验证区块执行后的状态一致性，支持轻客户端
 *    
 * 4. 共识机制支持:
 *    - nonce + difficulty: 用于工作量证明(PoW)共识算法
 */
message BlockHeader { 
  // 网络标识（最重要，防止跨网重放）
  uint64 chain_id = 1;        // 链ID，防止跨链重放攻击
  
  // 基础链接字段
  uint64 version = 2;         // 区块版本号，用于协议版本控制
  bytes previous_hash = 3;    // 前一个区块的哈希值，确保区块链接性
  uint64 timestamp = 4;       // 区块生成时间戳，用于时间顺序和共识
  uint64 height = 5;          // 区块高度，用于标识区块位置
  
  // Merkle根验证字段
  bytes merkle_root = 6;      // 交易Merkle树根，用于快速验证交易
  optional bytes state_root = 7;   // 状态Merkle根，用于状态验证和轻客户端
  
  // 共识机制字段
  bytes nonce = 8;            // 随机数，用于PoW共识机制
  uint64 difficulty = 9;      // 挖矿难度，用于控制出块速度
}

// ==================== 区块体 ====================
/**
 * 区块体结构:
 * 
 * +--------------------------------------+
 * |              区块体                  |
 * +--------------------------------------+
 * | 交易列表                             |
 * |--------------------------------------|
 * | Transaction 1                        |
 * | Transaction 2                        |
 * | ...                                  |
 * | Transaction N                        |
 * +--------------------------------------+
 *
 * 交易排序和依赖关系:
 * 
 * +-------------+      +-------------+
 * | 交易1(独立) |      | 交易2(独立) |
 * +-------------+      +-------------+
 *       |                    |
 *       v                    v
 * +-------------+      +-------------+
 * | 交易3(依赖1)|      | 交易4(依赖2)|
 * +-------------+      +-------------+
 *       |                    |
 *       |                    v
 *       |             +-------------+
 *       +------------>| 交易5(依赖  |
 *                     | 交易3和交易4)|
 *                     +-------------+
 *
 * 在区块体中，交易按照特定规则排序:
 * 1. 首先是Coinbase交易(矿工奖励)
 * 2. 然后是独立交易(不依赖区块中其他交易)
 * 3. 最后是依赖交易(依赖区块中之前的交易)
 *
 * 这种排序确保了交易的顺序执行是有效的，避免依赖冲突。
 */
message BlockBody {
  repeated Transaction transactions = 1; // 交易列表，包含区块中的所有交易
}

// ==================== 区块哈希服务 ====================
/**
 * BlockHashService 提供确定性的区块哈希计算和验证
 * 
 * 设计原则：
 * - 哈希计算必须是确定性的（相同输入 -> 相同输出）
 * - 不依赖任何可变参数（算法、选项等）
 * - 遵循协议固定的哈希标准
 * - 保证跨平台一致性
 * 
 * 哈希标准：
 * - 区块哈希：仅对区块头进行SHA-256计算
 * - 交易哈希：由Transaction服务负责
 * - Merkle根：由区块构建过程内部计算
 */
service BlockHashService {
  // 计算区块哈希（确定性）
  // 固定算法：SHA-256，仅计算区块头
  rpc ComputeBlockHash(ComputeBlockHashRequest) returns (ComputeBlockHashResponse);
  
  // 验证区块哈希（确定性）
  // 重新计算哈希并与期望值比较
  rpc ValidateBlockHash(ValidateBlockHashRequest) returns (ValidateBlockHashResponse);
}

// 计算区块哈希请求（确定性设计）
message ComputeBlockHashRequest {
  Block block = 1;                    // 待计算哈希的区块
  bool include_debug_info = 2;        // 是否返回调试信息（不影响哈希）
}

// 计算区块哈希响应  
message ComputeBlockHashResponse {
  bytes hash = 1;                     // 计算得到的区块哈希（SHA-256）
  bool is_valid = 2;                  // 区块结构是否有效
  
  // 调试信息（不影响哈希）
  optional BlockHashDebugInfo debug_info = 3;
}

// 验证区块哈希请求
message ValidateBlockHashRequest {
  Block block = 1;                    // 待验证的区块
  bytes expected_hash = 2;            // 期望的区块哈希
}

// 验证区块哈希响应
message ValidateBlockHashResponse {
  bool is_valid = 1;                  // 验证结果
  bytes computed_hash = 2;            // 实际计算的哈希
  bytes expected_hash = 3;            // 期望的哈希值
  
  // 验证详情（不影响哈希）
  optional string error_message = 4;  // 错误信息（验证失败时）
}

// 区块哈希调试信息（不影响哈希）
message BlockHashDebugInfo {
  bytes canonical_bytes = 1;          // 标准化后的字节数据
  uint64 canonical_length = 2;        // 标准化数据长度
  repeated string included_fields = 3; // 参与哈希计算的字段列表
  repeated string excluded_fields = 4; // 排除的字段列表（如签名）
  string serialization_method = 5;    // 序列化方法（固定为"protobuf"）
  uint64 computation_time_nanos = 6;  // 计算耗时（纳秒，仅调试）
}